<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是缓存击穿、缓存穿透、缓存雪崩</title>
      <link href="/2025/02/18/shi-me-shi-huan-cun-ji-chuan-huan-cun-chuan-tou-huan-cun-xue-beng/"/>
      <url>/2025/02/18/shi-me-shi-huan-cun-ji-chuan-huan-cun-chuan-tou-huan-cun-xue-beng/</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓存击穿"><a href="#1-缓存击穿" class="headerlink" title="1.缓存击穿"></a>1.缓存击穿</h3><p>缓存击穿是指某个热点数据key在缓存中失效，大量的请求同时涌向后台数据库，对数据库造成很大的压力。</p><p><strong>解决方案</strong>：</p><ul><li>逻辑过期：在缓存数据中存储逻辑过期时间（如字段<code>expireTime</code>），实际缓存不设物理过期。当数据过期时，异步线程更新缓存，其他线程仍返回旧数据。</li><li>互斥锁：在过期后，通过加锁控制对数据库的访问，从而保证只有一个请求能够去查询数据库并更新缓存。</li></ul><p><img src="/2025/02/18/shi-me-shi-huan-cun-ji-chuan-huan-cun-chuan-tou-huan-cun-xue-beng/Snipaste_2024-03-04_21-05-32.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 逻辑过期方案解决缓存击穿问题     *     * @param id     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">Shop</span> <span class="token function">queryWithLogicalExpire</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.从redis中查询商铺缓存</span>        <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"cache:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.判断是否存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//3.不存在，直接返回</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//4.命中，需要先把json反序列化为对象</span>        <span class="token class-name">RedisData</span> redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JSONObject</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">LocalDateTime</span> expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5.判断是否过期</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//5.1未过期，直接返回店铺信息</span>            <span class="token keyword">return</span> shop<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//5.2已过期，需要缓存重建</span>        <span class="token comment">//6缓存重建</span>        <span class="token comment">//6.1获取互斥锁</span>        <span class="token class-name">String</span> lockKey <span class="token operator">=</span> <span class="token constant">LOCK_SHOP_KEY</span> <span class="token operator">+</span> id<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> isLock <span class="token operator">=</span> <span class="token function">tryLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//6.2判断是否获取锁成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isLock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//获取互斥锁成功，再次对redis缓存做DoubleCheck</span>            shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"cache:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>            redisData <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">RedisData</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">JSONObject</span><span class="token punctuation">)</span> redisData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            shop <span class="token operator">=</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            expireTime <span class="token operator">=</span> redisData<span class="token punctuation">.</span><span class="token function">getExpireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>expireTime<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//6.2.1未过期，直接返回店铺信息</span>                <span class="token function">unLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> shop<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//6.2.2已过期，开启独立线程，实现缓存重建</span>            <span class="token constant">CACHE_REBUILD_EXECUTOR</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveShop2Redis</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">20L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    <span class="token function">unLock</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要点：在缓存重建时需要<strong>双重检查</strong></p><hr><h3 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h3><p>缓存穿透是指用户请求的数据在缓存和数据库中都不存在，从而导致每次请求都落到数据库上。</p><p>解决方案：</p><ul><li><strong>缓存空对象</strong>：缓存空结果，但要设置短的过期时间。</li><li><strong>布隆过滤器</strong>：在访问缓存之前进行一次快速判断，过滤掉不可能存在的数据请求。由于哈希碰撞，会存在一定的误判率，但是这个误判率非常低。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 缓存穿透     *     * @param id     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">Shop</span> <span class="token function">queryWithPassThrough</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.从redis中查询商铺缓存</span>        <span class="token class-name">String</span> shopJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"cache:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.判断是否存在</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StrUtil</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//3.存在，直接返回</span>            <span class="token keyword">return</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toBean</span><span class="token punctuation">(</span>shopJson<span class="token punctuation">,</span> <span class="token class-name">Shop</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//判断命中的是否是空值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shopJson <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//4.不存在，根据id查询数据库</span>        <span class="token class-name">Shop</span> shop <span class="token operator">=</span> <span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5.数据库也不存在，返回错误</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>shop <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//将空值写入redis</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"cache:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//6.存在，写入redis</span>        stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"cache:shop:"</span> <span class="token operator">+</span> id<span class="token punctuation">,</span> <span class="token class-name">JSONUtil</span><span class="token punctuation">.</span><span class="token function">toJsonStr</span><span class="token punctuation">(</span>shop<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">30L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//7.返回</span>        <span class="token keyword">return</span> shop<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h3><p><strong>缓存雪崩</strong>：是指在某一时刻，大量缓存数据共同过期，导致瞬时大流量涌向数据库。或者由于分布式缓存节点故障导致缓存失效。</p><p><strong>解决方案：</strong></p><ul><li>过期时间设置为随机：避免大量缓存同一时间过期</li><li>多级缓存架构：采用本地缓存（如Caffeine）+分布式缓存（如Redis）组合，本地缓存作为二级缓冲层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何保证缓存一致性</title>
      <link href="/2024/12/29/ru-he-bao-zheng-huan-cun-yi-zhi-xing/"/>
      <url>/2024/12/29/ru-he-bao-zheng-huan-cun-yi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-如何保证缓存一致性？"><a href="#1-如何保证缓存一致性？" class="headerlink" title="1.如何保证缓存一致性？"></a>1.如何保证缓存一致性？</h3><p>使用缓存代表不需要强一致性，只需要最终一致性</p><h4 id="1-1数据库和缓存数据强一致场景："><a href="#1-1数据库和缓存数据强一致场景：" class="headerlink" title="1.1数据库和缓存数据强一致场景："></a>1.1数据库和缓存数据强一致场景：</h4><ul><li><p>同步双写：更新 DB 时同样更新 cache，保证在一个事务中，通过加锁来保证更新 cache 时不存在线程安全问题</p></li><li><p>延迟双删：先淘汰缓存再写数据库，休眠 1 秒再次淘汰缓存，可以将 1 秒内造成的缓存脏数据再次删除</p></li><li><p>异步通知：</p><ul><li>基于 MQ 的异步通知：对数据的修改后，代码需要发送一条消息到 MQ 中，缓存服务监听 MQ 消息</li><li>Canal 订阅 MySQL binlog 的变更上报给 Kafka，系统监听 Kafka 消息触发缓存失效，或者直接将变更发送到处理服务，<strong>没有任何代码侵入</strong></li></ul><p>低耦合，可以同时通知多个缓存服务，但是时效性一般，可能存在中间不一致状态</p></li></ul><h4 id="1-2低一致性场景："><a href="#1-2低一致性场景：" class="headerlink" title="1.2低一致性场景："></a>1.2低一致性场景：</h4><ul><li>更新 DB 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样就可以保证即使数据不一致影响也比较小</li><li>使用 Redis 自带的内存淘汰机制</li></ul><h3 id="2-先操作数据库还是先操作redis"><a href="#2-先操作数据库还是先操作redis" class="headerlink" title="2.先操作数据库还是先操作redis"></a>2.先操作数据库还是先操作redis</h3><p>在保证Redis缓存一致性时，<strong>优先选择先更新数据库再删除缓存</strong>（Cache-Aside Pattern），这是业界主流方案。</p><h4 id="2-1为什么先更新数据库再删除缓存？"><a href="#2-1为什么先更新数据库再删除缓存？" class="headerlink" title="2.1为什么先更新数据库再删除缓存？"></a>2.1<strong>为什么先更新数据库再删除缓存？</strong></h4><ul><li><strong>逻辑合理性</strong>：数据库是数据的唯一权威来源，缓存应作为数据库的从属。先更新数据库可确保数据源头的正确性.</li><li><strong>并发安全</strong>：若先删除缓存再更新数据库，在并发场景下可能导致<strong>旧数据回填缓存</strong>，例如：请求A把缓存删了，还没来得及更新数据库，请求B读取了数据库旧值并写入缓存（这里可以想象缓存是永不过期的），而先更新数据库再删除缓存能降低此类风险。</li></ul><h3 id="3-延迟双删"><a href="#3-延迟双删" class="headerlink" title="3.延迟双删"></a>3.延迟双删</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 第一次删除</span>    db<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 更新数据库</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 等待读请求完成</span>    redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 第二次异步删除</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Push消费和Pull消费</title>
      <link href="/2024/12/17/push-xiao-fei-he-pull-xiao-fei/"/>
      <url>/2024/12/17/push-xiao-fei-he-pull-xiao-fei/</url>
      
        <content type="html"><![CDATA[<p>MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。</p><ul><li>Push是服务端主动推送消息给客户端，由系统控制读取操作，收到消息后自动调用处理函数来处理消息。优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。</li><li>Pull是客户端需要主动到服务端取数据，读取操作中的大部分功能由使用者自主控制。优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。</li></ul><h3 id="1-DefaultMQPushConsumer的使用"><a href="#1-DefaultMQPushConsumer的使用" class="headerlink" title="1.DefaultMQPushConsumer的使用"></a>1.DefaultMQPushConsumer的使用</h3><p>RocketMQ Push消费的示例代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 初始化consumer，并设置group name</span>    <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 设置NameServer地址 </span>    consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"localhost:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息</span>    consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//注册回调接口来处理从Broker中收到的消息</span>    consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token annotation punctuation">@Override</span>      <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s Receive New Messages: %s %n"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回消息消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS为消费成功</span>        <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 启动Consumer</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Consumer Started.%n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要初始化消费者，初始化消费者时，必须填写ConsumerGroupName，同一个消费组的ConsumerGroupName是相同的，这是判断消费者是否属于同一个消费组的重要属性。然后是设置NameServer地址。然后是调用subscribe方法订阅Topic，subscribe方法需要指定需要订阅的Topic名，也可以增加消息过滤的条件，比如TagA等，上述代码中指定*表示接收所有tag的消息。除了订阅之外，还需要注册回调接口编写消费逻辑来处理从Broker中收到的消息，调用registerMessageListener方法，需要传入MessageListener的实现，上述代码中是并发消费，因此是MessageListenerConcurrently的实现</p><h4 id="集群模式和广播模式"><a href="#集群模式和广播模式" class="headerlink" title="集群模式和广播模式"></a>集群模式和广播模式</h4><p>我们可以通过以下代码来设置采用集群模式，RocketMQ Push Consumer默认为集群模式，同一个消费组内的消费者分担消费。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span><span class="token class-name">MessageModel</span><span class="token punctuation">.</span><span class="token constant">CLUSTERING</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过以下代码来设置采用广播模式，广播模式下，消费组内的每一个消费者都会消费全量消息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span><span class="token class-name">MessageModel</span><span class="token punctuation">.</span><span class="token constant">BROADCASTING</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="并发消费和顺序消费"><a href="#并发消费和顺序消费" class="headerlink" title="并发消费和顺序消费"></a>并发消费和顺序消费</h4><p>上面已经介绍设置Push Consumer并发消费的方法，通过在注册消费回调接口时传入MessageListenerConcurrently接口的实现来完成。在并发消费中，可能会有多个线程同时消费一个队列的消息，因此即使发送端通过发送顺序消息保证消息在同一个队列中按照FIFO的顺序，也无法保证消息实际被顺序消费。</p><p>因此RocketMQ提供了顺序消费的方式， 顺序消费设置与并发消费API层面只有一处不同，在注册消费回调接口时传入MessageListenerOrderly接口的实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerOrderly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">AtomicLong</span> consumeTimes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ConsumeOrderlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeOrderlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s Receive New Messages: %s %n"</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msgs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>consumeTimes<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>consumeTimes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token class-name">ConsumeOrderlyStatus</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>consumeTimes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            context<span class="token punctuation">.</span><span class="token function">setSuspendCurrentQueueTimeMillis</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">ConsumeOrderlyStatus</span><span class="token punctuation">.</span><span class="token constant">SUSPEND_CURRENT_QUEUE_A_MOMENT</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token class-name">ConsumeOrderlyStatus</span><span class="token punctuation">.</span><span class="token constant">SUCCESS</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序消费也有两种返回结果，ConsumeOrderlyStatus.SUCCESS表示消费成功，ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT表示消费失败。</p><p><strong>可以看到RocketMQ提供的消费者API却非常简单，用户并不需要关注重平衡或者拉取的逻辑，只需要写好自己的消费逻辑即可。</strong></p><h3 id="2-DefaultMQPullConsumer的使用"><a href="#2-DefaultMQPullConsumer的使用" class="headerlink" title="2.DefaultMQPullConsumer的使用"></a>2.DefaultMQPullConsumer的使用</h3><p>Pull Consumer的代码示例如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PullConsumerTest</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">DefaultMQPullConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPullConsumer</span><span class="token punctuation">(</span><span class="token string">"please_rename_unique_group_name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"localhost:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">MessageQueue</span> mq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mq<span class="token punctuation">.</span><span class="token function">setQueueId</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mq<span class="token punctuation">.</span><span class="token function">setTopic</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mq<span class="token punctuation">.</span><span class="token function">setBrokerName</span><span class="token punctuation">(</span><span class="token string">"jinrongtong-MacBook-Pro.local"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>      <span class="token class-name">PullResult</span> pullResult <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">pull</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>pullResult<span class="token punctuation">.</span><span class="token function">getPullStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">PullStatus</span><span class="token punctuation">.</span><span class="token constant">FOUND</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> pullResult<span class="token punctuation">.</span><span class="token function">getMsgFoundList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">updateConsumeOffset</span><span class="token punctuation">(</span>mq<span class="token punctuation">,</span> pullResult<span class="token punctuation">.</span><span class="token function">getNextBeginOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    consumer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要初始化<code>DefaultMQPullConsumer</code>并启动，然后构造需要拉取的队列<code>MessageQueue</code>，除了构造外也可以如下所示调用<code>fetchSubscribeMessageQueues</code>方法获取某个Topic的所有队列，然后挑选队列进行拉取。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">></span></span> queueSet <span class="token operator">=</span>  consumer<span class="token punctuation">.</span><span class="token function">fetchSubscribeMessageQueues</span><span class="token punctuation">(</span><span class="token string">"TopicTest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到或者构造完队列之后，调用pull方法就可以进行拉取，需要传入拉取的队列，过滤表达式，拉取的位点，最大拉取消息条数等参数。拉取完成后会返回拉取结果<code>PullResult</code>，PullResult中的PullStatus表示结果状态，如下所示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">PullStatus</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Founded     */</span>    <span class="token constant">FOUND</span><span class="token punctuation">,</span>    <span class="token comment">/**     * No new message can be pull     */</span>    <span class="token constant">NO_NEW_MSG</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Filtering results can not match     */</span>    <span class="token constant">NO_MATCHED_MSG</span><span class="token punctuation">,</span>    <span class="token comment">/**     * Illegal offset,may be too big or too small     */</span>    <span class="token constant">OFFSET_ILLEGAL</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FOUND表示拉取到消息，NO_NEW_MSG表示没有发现新消息，NO_MATCHED_MSG表示没有匹配的消息，OFFSET_ILLEGAL表示传入的拉取位点是非法的，有可能偏大或偏小。如果拉取状态是FOUND，我们可以通过<code>pullResult</code>的<code>getMsgFoundList</code>方法获取拉取到的消息列表。最后，如果消费完成，通过<code>updateConsumeOffset</code>方法更新消费位点。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9377游戏后端面经</title>
      <link href="/2024/11/21/9377-you-xi-hou-duan-mian-jing/"/>
      <url>/2024/11/21/9377-you-xi-hou-duan-mian-jing/</url>
      
        <content type="html"><![CDATA[<p>线下面试，先做笔试题再面试，先做笔试大概30分钟，面试大概45分钟</p><h4 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h4><p>全是简答题，主要有TCP的三次握手与四次挥手原理；手撕代码全排列，用回溯思想；一道sql题；一道数学的概率题，用贝叶斯原理</p><h4 id="1-口述算法思想，有一颗多叉树，每个节点有若干child，还有value属性，提供一个getChild-方法，找出所有value值大于50的节点"><a href="#1-口述算法思想，有一颗多叉树，每个节点有若干child，还有value属性，提供一个getChild-方法，找出所有value值大于50的节点" class="headerlink" title="1.口述算法思想，有一颗多叉树，每个节点有若干child，还有value属性，提供一个getChild()方法，找出所有value值大于50的节点"></a>1.口述算法思想，有一颗多叉树，每个节点有若干child，还有value属性，提供一个getChild()方法，找出所有value值大于50的节点</h4><p>使用广度优先遍历</p><h4 id="2-怎样自定义bean，并且设置bean的名称"><a href="#2-怎样自定义bean，并且设置bean的名称" class="headerlink" title="2.怎样自定义bean，并且设置bean的名称"></a>2.怎样自定义bean，并且设置bean的名称</h4><h4 id="3-讲一讲项目使用到了哪些微服务的组件，这些组件有什么用途"><a href="#3-讲一讲项目使用到了哪些微服务的组件，这些组件有什么用途" class="headerlink" title="3.讲一讲项目使用到了哪些微服务的组件，这些组件有什么用途"></a>3.讲一讲项目使用到了哪些微服务的组件，这些组件有什么用途</h4><h4 id="4-gateway是怎么实现限流的？"><a href="#4-gateway是怎么实现限流的？" class="headerlink" title="4.gateway是怎么实现限流的？"></a>4.gateway是怎么实现限流的？</h4><p>讲了一个令牌桶算法，如果不使用网关，用RateLimter也可以实现限流</p><h4 id="5-nacos是怎样实现服务注册与发现的，nacos上保存了哪些信息"><a href="#5-nacos是怎样实现服务注册与发现的，nacos上保存了哪些信息" class="headerlink" title="5.nacos是怎样实现服务注册与发现的，nacos上保存了哪些信息?"></a>5.nacos是怎样实现服务注册与发现的，nacos上保存了哪些信息?</h4><p>nacos上保存了服务名，ip地址+端口号，通过心跳机制确定服务是健康的</p><h4 id="6-B类继承A类，并且重写了a方法，再调用new-B-a-方法的时候的执行流程"><a href="#6-B类继承A类，并且重写了a方法，再调用new-B-a-方法的时候的执行流程" class="headerlink" title="6.B类继承A类，并且重写了a方法，再调用new B().a()方法的时候的执行流程"></a>6.B类继承A类，并且重写了a方法，再调用new B().a()方法的时候的执行流程</h4><h4 id="7-接口和抽象类的区别，什么情况下使用接口，什么情况下使用抽象类"><a href="#7-接口和抽象类的区别，什么情况下使用接口，什么情况下使用抽象类" class="headerlink" title="7.接口和抽象类的区别，什么情况下使用接口，什么情况下使用抽象类"></a>7.接口和抽象类的区别，什么情况下使用接口，什么情况下使用抽象类</h4><h4 id="8-注解和接口的区别"><a href="#8-注解和接口的区别" class="headerlink" title="8.注解和接口的区别"></a>8.注解和接口的区别</h4><h4 id="9-什么是回表？"><a href="#9-什么是回表？" class="headerlink" title="9.什么是回表？"></a>9.什么是回表？</h4><h4 id="10-讲解日志，如果服务器崩溃了应该怎么恢复数据"><a href="#10-讲解日志，如果服务器崩溃了应该怎么恢复数据" class="headerlink" title="10.讲解日志，如果服务器崩溃了应该怎么恢复数据"></a>10.讲解日志，如果服务器崩溃了应该怎么恢复数据</h4><h4 id="11-如果消费者没有收到消息，可能是什么原因"><a href="#11-如果消费者没有收到消息，可能是什么原因" class="headerlink" title="11.如果消费者没有收到消息，可能是什么原因"></a>11.如果消费者没有收到消息，可能是什么原因</h4><h4 id="12-谈谈你对redis的理解"><a href="#12-谈谈你对redis的理解" class="headerlink" title="12.谈谈你对redis的理解"></a>12.谈谈你对redis的理解</h4><p>开始吟唱，把知道的都讲了</p><h4 id="13-常用的Docker命令"><a href="#13-常用的Docker命令" class="headerlink" title="13.常用的Docker命令"></a>13.常用的Docker命令</h4><h4 id="14-谈一谈mysql的索引"><a href="#14-谈一谈mysql的索引" class="headerlink" title="14.谈一谈mysql的索引"></a>14.谈一谈mysql的索引</h4><h4 id="15-怎样在建表时选择索引的实现方式"><a href="#15-怎样在建表时选择索引的实现方式" class="headerlink" title="15.怎样在建表时选择索引的实现方式"></a>15.怎样在建表时选择索引的实现方式</h4>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ的两种消费模式</title>
      <link href="/2024/11/17/rocketmq-de-liang-chong-xiao-fei-mo-shi/"/>
      <url>/2024/11/17/rocketmq-de-liang-chong-xiao-fei-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>首先需要了解<strong>消费组</strong>的概念。在消费者中消费组的有非常重要的作用，如果多个消费者设置了相同的Consumer Group（GroupName相同），我们认为这些消费者在同一个消费组内。</p><p>在 Apache RocketMQ 有两种消费模式，分别是：</p><ul><li>集群消费模式（Clustering）：当使用集群消费模式时，RocketMQ 认为任意一条消息只需要被消费组内的任意一个消费者处理即可。</li><li>广播消费模式（Broadcasting）：当使用广播消费模式时，同一个消费组里的每个消费者都能消费到所订阅Topic的全部消息，也就是一条消息会被多次分发，被多个消费者消费。</li></ul><h3 id="1-集群消费模式"><a href="#1-集群消费模式" class="headerlink" title="1.集群消费模式"></a>1.集群消费模式</h3><p>集群消费模式适用于每条消息只需要被处理一次的场景，也就是说同一个消费组里面所有的消费者消费的内容合起来才是所订阅Topic内容的整体，因此可以通过扩缩消费者数量，来提升或降低消费能力，具体示例如下图所示，是最常见的消费方式。</p><p><img src="/2024/11/17/rocketmq-de-liang-chong-xiao-fei-mo-shi/Clustering.png"></p><h3 id="2-广播消费模式"><a href="#2-广播消费模式" class="headerlink" title="2.广播消费模式"></a>2.广播消费模式</h3><p>广播消费模式适用于每条消息需要被消费组的每个消费者处理的场景，也就是说消费组内的每个消费者都会收到订阅Topic的全量消息，因此即使扩缩消费者数量也无法提升或降低消费能力，具体示例如下图所示。</p><p><img src="/2024/11/17/rocketmq-de-liang-chong-xiao-fei-mo-shi/Clustering.png"></p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解零拷贝技术</title>
      <link href="/2024/07/28/shen-ru-li-jie-ling-kao-bei-ji-zhu/"/>
      <url>/2024/07/28/shen-ru-li-jie-ling-kao-bei-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-相关概念说明"><a href="#1-相关概念说明" class="headerlink" title="1.相关概念说明"></a>1.相关概念说明</h3><h4 id="1-1DMA介绍"><a href="#1-1DMA介绍" class="headerlink" title="1.1DMA介绍"></a>1.1DMA介绍</h4><p>DMA，英文全称是 <strong>Direct Memory Access</strong>，即直接内存访问。DMA 本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行 IO 数据传输，其过程不需要 CPU 的参与。</p><h4 id="1-2内核空间和用户空间介绍"><a href="#1-2内核空间和用户空间介绍" class="headerlink" title="1.2内核空间和用户空间介绍"></a>1.2内核空间和用户空间介绍</h4><p><strong>为什么要分成内核空间和用户空间？</strong></p><p>为了避免用户进程直接操作内核，保证内核安全，操作系统将虚拟内存划分为两部分，一部分是<strong>内核空间</strong>（Kernel-space），一部分是<strong>用户空间</strong>（User-space）。</p><p><strong>用户空间：</strong>当启动某个应用程序时，操作系统会给应用程序分配一个单独的用户空间，其实就是一个用户独享的虚拟内存，每个用户进程之间的用户空间是完全隔离的、不共享的，当用户进程结束的时候，用户空间的虚拟内存也会随之释放。用户空间的权限较低，应用程序不能直接访问硬件资源和执行某些关键操作，因为这些操作可能会影响系统的稳定性和安全性。</p><p><strong>内核空间：</strong>内核空间是操作系统的核心部分，它负责管理系统资源，包括CPU、内存、硬盘等，以及处理各种硬件设备的请求。内核空间拥有最高的权限，可以直接访问所有的硬件资源和执行任何操作。</p><p>当应用程序需要执行系统调用时，会从用户态切换到内核态，执行完毕后再切换回用户态。操作系统通过这种设计，确保了系统的稳定性和安全性，同时也为应用程序提供了一个相对安全和隔离的运行环境。</p><h3 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2.零拷贝"></a>2.零拷贝</h3><p>零拷贝并不是完全没有拷贝数据，而是减少用户态&#x2F;内核态的切换次数以及CPU拷贝的次数。它通过减少或消除数据在内核空间和用户空间之间的拷贝操作，直接将数据从输入&#x2F;输出设备传输到应用程序的内存空间，提高数据传输效率和性能。</p><h3 id="3-实现方式"><a href="#3-实现方式" class="headerlink" title="3.实现方式"></a>3.实现方式</h3><h4 id="3-1mmap"><a href="#3-1mmap" class="headerlink" title="3.1mmap"></a>3.1mmap</h4><p>mmap 内存映射的拷贝，指的是将用户空间的缓冲区和内核缓冲区进行映射处理，省略了数据在内核缓冲区和用户缓冲区之间的 CPU 拷贝，进而加快资源拷贝效率。</p><p>整个拷贝过程，可以用如下流程图来描述！</p><img src="/2024/07/28/shen-ru-li-jie-ling-kao-bei-ji-zhu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241213142012.png" style="zoom:67%;"><p>mmap 内存映射拷贝流程，从上图可以得出如下结论：</p><ul><li>数据拷贝次数：2 次 DMA 拷贝，1 次 CPU 拷贝</li><li>CPU 切换次数：4 次用户态和内核态的切换</li></ul><p>整个过程省掉了数据在内核缓冲区和用户缓冲区之间的 CPU 拷贝环节，在实际的应用中，对资源的拷贝能提升不少。</p><h4 id="3-2Linux系统的sendfile拷贝流程"><a href="#3-2Linux系统的sendfile拷贝流程" class="headerlink" title="3.2Linux系统的sendfile拷贝流程"></a>3.2Linux系统的sendfile拷贝流程</h4><p>在 Linux 2.1 内核版本中，引入了一个系统调用方法：<code>sendfile</code>。</p><p>当调用 sendfile() 时，DMA 将磁盘数据复制到内核缓冲区 kernel buffer；然后将内核中的 kernel buffer 直接拷贝到 socket buffer；最后利用 DMA 将  socket buffer 通过网卡传输给客户端。</p><p>整个拷贝过程，可以用如下流程图来描述！</p><img src="/2024/07/28/shen-ru-li-jie-ling-kao-bei-ji-zhu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241213143919.png" style="zoom:67%;"><p>在 Linux 2.4 内核版本中，对 sendfile 系统方法做了优化升级，引入 SG-DMA 技术，需要 DMA 控制器支持。</p><p>其实就是对 DMA 拷贝加入了 scatter&#x2F;gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡。使用这个特点来实现数据拷贝，可以多省去一次 CPU 拷贝。</p><blockquote><p>catter&#x2F;Gather技术是一种数据传输机制，它允许数据从一个或多个非连续的内存区域（scatter）传输到另一个或多个非连续的内存区域（gather），而不需要CPU介入处理这些非连续的内存区域的数据拷贝。这项技术在DMA（Direct Memory Access）操作中尤为重要，可以显著提高数据传输效率。</p><ul><li><strong>Scatter</strong>：指从通道中读取数据分散到多个缓冲区Buffer的过程，会将每个缓存区填满，直至通道中无数据或缓冲区没有空间。</li><li><strong>Gather</strong>：指将多个缓冲区Buffer聚集起来写入到通道的过程，类似于将多个缓冲区的内容连接起来写入通道</li></ul></blockquote><p>整个拷贝过程，可以用如下流程图来描述！</p><img src="/2024/07/28/shen-ru-li-jie-ling-kao-bei-ji-zhu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241213144034.png" style="zoom:67%;"><p>可以发现，sendfile With DMA scatter&#x2F;gather 实现的拷贝，其中 2 次数据拷贝都是 DMA 拷贝，全程都没有通过 CPU 来拷贝数据，所有的数据都是通过 DMA 来进行传输的，这就是操作系统真正意义上的<strong>零拷贝</strong>（Zero-copy) 技术，相比其他拷贝方式，传输效率最佳。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>从上面的内容总结可以看出，所谓的<strong>零拷贝</strong>，其目的并不是说不需要拷贝数据，而是通过一些手段省略 CPU 拷贝环节，减少了不必要的拷贝次数，提升数据拷贝效率。</p><p>以  Linux 操作系统为例，<strong>真正意义上大家比较认可的零拷贝</strong>主要有 sendfile、splice 等方法，它们完全通过 DMA 控制器来实现数据的拷贝，无需 CPU 来参与数据拷贝的过程，这个过程被称为<strong>零拷贝</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>详解两阶段提交</title>
      <link href="/2024/07/22/xiang-jie-liang-jie-duan-ti-jiao/"/>
      <url>/2024/07/22/xiang-jie-liang-jie-duan-ti-jiao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h3><p>两阶段提交协议是一种确保分布式系统中所有节点在事务提交时保持一致性的协议，它通常用于需要跨越多个数据库或多个数据节点的事务。</p><h4 id="1-1准备阶段"><a href="#1-1准备阶段" class="headerlink" title="1.1准备阶段"></a>1.1准备阶段</h4><p>在准备阶段（Prepare Phase），事务协调者（通常是发起事务的节点）向所有参与者（其他节点或数据库）发送准备请求，并要求他们预备提交事务。每个参与者在接收到请求后执行以下操作：</p><ul><li>执行事务操作，但不提交。</li><li>将操作的结果写入日志，以确保即使系统崩溃也能恢复到当前状态。</li><li>返回一个响应给协调者，指明它是否准备好提交事务（通常是“准备好”或“失败”）。</li></ul><p>如果所有参与者都返回“准备好”，则进入提交阶段。如果有任何参与者返回“失败”或超时未响应，协调者将中止事务。</p><h4 id="1-2提交阶段"><a href="#1-2提交阶段" class="headerlink" title="1.2提交阶段"></a>1.2提交阶段</h4><p>在提交阶段（Commit Phase），事务协调者根据准备阶段的结果决定是提交事务还是中止事务：</p><ul><li>如果所有参与者都准备好，协调者会发送提交请求，所有参与者提交事务并释放资源。</li><li>如果有任何参与者未准备好，协调者会发送回滚请求，所有参与者回滚事务。</li></ul><p>在提交或回滚完成后，参与者会将结果通知协调者，此时事务完成。</p><hr><h3 id="2-MySQL两阶段提交实现"><a href="#2-MySQL两阶段提交实现" class="headerlink" title="2.MySQL两阶段提交实现"></a>2.MySQL两阶段提交实现</h3><p>MySQL 中的两阶段提交主要用于支持分布式事务和 XA 事务（eXtended Architecture），尤其是在 InnoDB 存储引擎中。</p><h4 id="2-1InnoDB的两阶段提交"><a href="#2-1InnoDB的两阶段提交" class="headerlink" title="2.1InnoDB的两阶段提交"></a>2.1InnoDB的两阶段提交</h4><p>InnoDB 引擎通过 redo log（重做日志）和 binlog（二进制日志）实现两阶段提交，以确保事务的持久性和一致性。</p><ul><li><strong>准备阶段：</strong>在事务执行过程中，InnoDB 会先将事务的操作记录到 redo log 中，并标记为准备状态。在此阶段，事务可以被回滚。</li><li><strong>提交阶段：</strong>一旦事务准备完毕，InnoDB 会将事务的最终状态记录到 binlog 中。这一步成功后，事务才算真正提交。</li></ul><p>这种实现方式确保了即使在系统崩溃的情况下，数据库也能通过重做日志和二进制日志恢复到一致性状态。</p><hr><h3 id="3-两阶段提交的优势和劣势"><a href="#3-两阶段提交的优势和劣势" class="headerlink" title="3.两阶段提交的优势和劣势"></a>3.两阶段提交的优势和劣势</h3><h4 id="3-1优势"><a href="#3-1优势" class="headerlink" title="3.1优势"></a>3.1优势</h4><ol><li><strong>一致性</strong>：两阶段提交可以确保分布式系统中的数据一致性，这是它最大的优势。无论在何种故障情况下，系统都能恢复到一致状态。</li><li><strong>标准化</strong>：两阶段提交是分布式事务处理的标准协议，许多数据库系统和中间件都支持这一协议，便于系统集成。</li><li><strong>可靠性</strong>：通过日志机制，系统在崩溃后仍能恢复数据，保证事务的可靠性和持久性。</li></ol><h4 id="3-2劣势"><a href="#3-2劣势" class="headerlink" title="3.2劣势"></a>3.2劣势</h4><ol><li><strong>性能开销</strong>：两阶段提交需要多个网络往返和磁盘 I&#x2F;O 操作，导致事务开销较大，性能较单节点事务低。</li><li><strong>阻塞问题</strong>：在提交阶段，参与者可能因等待协调者的决定而阻塞，影响系统性能和可用性。</li><li><strong>单点故障</strong>：事务协调者是单点故障，如果它崩溃，整个事务可能无法继续。</li></ol><hr><h3 id="4-实际应用场景"><a href="#4-实际应用场景" class="headerlink" title="4.实际应用场景"></a>4.实际应用场景</h3><p>两阶段提交广泛应用于需要保证分布式系统一致性的场景，比如：</p><ul><li><strong>分布式数据库</strong>：在多个数据库节点之间执行事务，确保数据一致性。</li><li><strong>微服务架构</strong>：在微服务之间执行跨服务事务，确保服务间的数据一致性。</li><li><strong>跨数据中心的事务</strong>：在不同地理位置的数据中心之间执行事务，确保数据一致性。</li></ul><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>MySQL 的两阶段提交机制是确保分布式系统中事务一致性的重要协议，尽管存在性能开销和阻塞问题，但是在数据一致性和可靠性方面具备优势，在分布式系统中有广泛的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口和抽象类的区别</title>
      <link href="/2024/06/27/jie-kou-he-chou-xiang-lei-de-qu-bie/"/>
      <url>/2024/06/27/jie-kou-he-chou-xiang-lei-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>本文基于jdk1.8谈论接口和抽象类的区别</p><h3 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h3><h4 id="1-1抽象类的定义"><a href="#1-1抽象类的定义" class="headerlink" title="1.1抽象类的定义"></a>1.1抽象类的定义</h4><p>抽象类通常包含抽象方法、非抽象方法和属性。子类要么实现这些抽象方法，要么也声明为抽象类。非抽象方法和属性可以有具体的实现代码，并且可以被子类继承，根据需要进行覆盖和修改。由于抽象方法的存在，抽象类是一个不能被实例化的类，只能被用作其他类的父类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractExample</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 定义普通变量</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 定义私有变量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">// 定义抽象方法</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义普通方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hi,methodB."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><h4 id="1-2接口的定义"><a href="#1-2接口的定义" class="headerlink" title="1.2接口的定义"></a>1.2接口的定义</h4><p>接口是 Java 语言中的一个抽象类型，用于定义对象的公共行为。它的创建关键字是 interface，在 JDK 8 之后，接口中可以创建 static 和 default 方法了，并且这两种方法可以有默认的方法实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Interface_1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// default 方法</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Do print method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// static 方法</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">smethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Do static method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><ol><li><strong>定义方式</strong>：<ul><li>抽象类：使用<code>abstract</code>关键字定义。</li><li>接口：使用<code>interface</code>关键字定义。</li></ul></li><li><strong>实现</strong>：<ul><li>抽象类：可以部分实现（即包含抽象方法和非抽象方法）。</li><li>接口：在Java 8之前只能定义抽象方法，从Java 8开始可以包含默认方法（有默认实现的方法）和静态方法。</li></ul></li><li><strong>成员变量</strong>：<ul><li>抽象类：成员变量可以是各种类型，包括实例变量和类变量。</li><li>接口：在Java 8之前只能定义公共的静态的最终变量（public static final），从Java 8开始可以定义实例变量（默认是<code>public static final</code>）。</li></ul></li><li><strong>构造函数</strong>：<ul><li>抽象类：可以有构造函数。</li><li>接口：不能有构造函数。</li></ul></li><li><strong>访问修饰符</strong>：<ul><li>抽象类：除抽象方法不能用private修饰外，可以有各种访问修饰符。</li><li>接口：除了静态方法和默认方法外，其余的都是<code>public</code>的。属性默认是public static final修饰的</li></ul></li><li><strong>使用场景</strong>：<ul><li>抽象类：当你想要共享代码的时候，并且有明确的类层次结构时，可以使用抽象类。</li><li>接口：当你在定义职责而不是共享代码时，可以使用接口，或者当你想要实现多重继承时。</li></ul></li><li><strong>实现方式</strong>：<ul><li>抽象类：使用<code>extends</code>关键字实现。</li><li>接口：使用<code>implements</code>关键字实现。</li></ul></li><li><strong>方法实现</strong>：<ul><li>抽象类：子类可以不实现抽象类中的所有抽象方法（除非子类也是抽象类）。</li><li>接口：实现接口的类必须实现接口中的所有方法（Java 8之前），或者使用<code>default</code>关键字提供默认实现。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必知必会的Linux命令</title>
      <link href="/2024/06/23/bi-zhi-bi-hui-de-linux-ming-ling/"/>
      <url>/2024/06/23/bi-zhi-bi-hui-de-linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h3><p>Shell 俗称壳，取这个名字是用来区别内核的“核”字，它是Linux操作系统的命令语言，同时又是该命令语言解释器程序的简称。也就是说，Shell既是一门编程语言，又是一个用C语言编写的软件程序。</p><p>Shell的位置处在用户与内核之间，起到承上启下的作用。由于安全性、复杂性和步骤繁琐等各种原因，普通用户是不能直接接触Linux内核的，这个程序的作用就是接收用户的操作命令，进行一些处理，最终将这些操作信息传递给内核。</p><p>超级管理员用户的家目录是&#x2F;root，而普通用户的家目录是&#x2F;home&#x2F;用户名.</p><p><strong>绝对路径：</strong>永远都是相对于根目录，它的标志就是第一个字符永远都是“&#x2F;”</p><p><strong>相对路径：</strong>永远都是相对于现在所处的目录。它的第一个字符没有“&#x2F;”</p><p><strong>路径符号有以下3种：</strong></p><ul><li>~(波浪符号)：当前用户家目录的快捷符号</li><li>.（点）：当前目录</li><li>..（两点）：当前所处目录的上一级目录</li></ul><p>若想快速切换到上一级目录，执行cd .. 。若想快速回到家目录，执行cd ~。</p><hr><h3 id="2-常用Linux命令"><a href="#2-常用Linux命令" class="headerlink" title="2.常用Linux命令"></a>2.常用Linux命令</h3><h4 id="2-1系统基本管理、显示"><a href="#2-1系统基本管理、显示" class="headerlink" title="2.1系统基本管理、显示"></a>2.1系统基本管理、显示</h4><ol><li>shutdown 关机</li><li>reboot 重启</li><li>exit [状态值]  以指定的状态退出当前Shell或在Shell脚本中终止当前脚本的执行</li><li>free 显示内存的使用情况</li><li>df 显示磁盘空间的使用情况</li><li>top Linux操作系统的性能分析工具，可以实时的查看系统的整体运行情况。</li><li>ps 显示当前时间点系统的进程状态</li><li>netstat 用来打印网络系统的状态信息，比如可以显示出所有监听的TCP端口相关的信息</li></ol><h4 id="2-2文件"><a href="#2-2文件" class="headerlink" title="2.2文件"></a>2.2文件</h4><ol><li><p>ll -a 显示目录内容列表，经常用它来查看目录下有什么</p></li><li><p>pwd 以绝对路径的方式显示用户当前所在的工作目录</p></li><li><p>wc 统计指定文件中的行数，字数，字节数，并将统计结果显示输出</p></li><li><p>mkdir 用于创建目录</p></li><li><p>cd 切换用户当前的工作目录</p></li><li><p>mv 用来对文件或目录重新命名，或者将文件从一个目录移动到另一个目录</p></li><li><p>cp 文件或者目录复制</p></li><li><p>rm 用于删除指定的文件或目录</p></li><li><p>find [查找范围] [查找条件表达式] 用来在指定目录下查找文件，并返回文件或目录的绝对路径。当不添加查找范围时，默认在当前目录下查找子目录和文件<br>在&#x2F;var目录下查找文件名以cron开头的文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var <span class="token parameter variable">-name</span> cron* <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="2-3打包、压缩、解压"><a href="#2-3打包、压缩、解压" class="headerlink" title="2.3打包、压缩、解压"></a>2.3打包、压缩、解压</h4><h4 id="查找一个文件是否包含”text”字符串，用的Linux命令是什么"><a href="#查找一个文件是否包含”text”字符串，用的Linux命令是什么" class="headerlink" title="查找一个文件是否包含”text”字符串，用的Linux命令是什么"></a>查找一个文件是否包含”text”字符串，用的Linux命令是什么</h4><p>在Linux中，你可以使用<code>grep</code>命令来查找文件中是否包含特定的字符串。如果你想查找一个文件是否包含”text”字符串，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"text"</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的<code>filename</code>是你想要搜索的文件名。如果文件中包含”text”字符串，<code>grep</code>命令会显示包含该字符串的行。</p><p>如果你想在多个文件中搜索，可以使用通配符：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"text"</span> *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用递归搜索目录中的所有文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-r</span> <span class="token string">"text"</span> /path/to/directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的<code>/path/to/directory</code>是你想要搜索的目录路径。<code>-r</code>选项告诉<code>grep</code>递归地在所有子目录中搜索。</p><h4 id="Linux中vi和vim的区别"><a href="#Linux中vi和vim的区别" class="headerlink" title="Linux中vi和vim的区别"></a>Linux中vi和vim的区别</h4><p><code>vi</code>和<code>vim</code>是Linux系统中常用的文本编辑器，它们之间有着密切的关系：</p><ol><li><p><strong>vi</strong>：</p><ul><li><code>vi</code>是Linux系统中最基本的文本编辑器，它是一个模式编辑器，有命令模式、插入模式等。</li><li><code>vi</code>没有<code>vim</code>那么多的增强功能，比如语法高亮、标签页功能等。</li><li><code>vi</code>是<code>vim</code>的精简版，体积更小，功能更少。</li></ul></li><li><p><strong>vim</strong>：</p><ul><li><code>vim</code>是<code>vi</code>的增强版，它继承了<code>vi</code>的所有功能，并且增加了许多新的功能。</li><li><code>vim</code>支持语法高亮，可以更容易地区分代码中的不同元素。</li><li><code>vim</code>支持多标签页编辑，可以在同一个窗口中打开多个文件进行编辑。</li><li><code>vim</code>支持插件，可以通过安装插件来扩展其功能。</li><li><code>vim</code>通常被认为是一个程序而不是一个编辑器，因为它可以做很多编辑器之外的事情。</li></ul></li></ol><p>在大多数Linux发行版中，当你安装<code>vim</code>时，<code>vi</code>命令会被链接到<code>vim</code>，所以当你在终端中输入<code>vi</code>时，实际上是在运行<code>vim</code>。这意味着你可以使用<code>vi</code>命令来启动<code>vim</code>编辑器，但是<code>vim</code>提供了更多的功能和更好的用户体验。</p><p>简而言之，<code>vim</code>是<code>vi</code>的一个更现代、功能更丰富的版本。如果你只需要基本的编辑功能，可以使用<code>vi</code>；如果你需要更高级的功能，比如语法高亮、多标签页编辑等，那么<code>vim</code>会是更好的选择。</p><h4 id="Linux使用vim的基本操作"><a href="#Linux使用vim的基本操作" class="headerlink" title="Linux使用vim的基本操作"></a>Linux使用vim的基本操作</h4><h3 id="3-Linux的一些常用的目录？"><a href="#3-Linux的一些常用的目录？" class="headerlink" title="3.Linux的一些常用的目录？"></a>3.Linux的一些常用的目录？</h3><ol><li>**&#x2F;**：根目录，所有文件和目录的起始点。</li><li><strong>&#x2F;bin</strong>：存放基本的用户命令和系统命令，如<code>ls</code>、<code>cp</code>、<code>mv</code>等。</li><li><strong>&#x2F;dev</strong>：存放设备文件，如硬盘、USB设备、键盘、鼠标等。</li><li><strong>&#x2F;opt</strong>：存放可选安装的第三方软件。</li><li><strong>&#x2F;boot</strong>：存放启动加载程序和内核文件。</li><li><strong>&#x2F;root</strong>：系统管理员（root用户）的主目录。</li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解HashSet:可变对象引发的问题</title>
      <link href="/2024/06/12/shen-ru-li-jie-hashset-ke-bian-dui-xiang-yin-fa-de-wen-ti/"/>
      <url>/2024/06/12/shen-ru-li-jie-hashset-ke-bian-dui-xiang-yin-fa-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>遇到了一奇怪的问题，现象是同一个对象，在一个HashSet里面存了两份。当时以为是hashcode和equals方法没有写对，但是仔细检查后没有发现错误。仔细debug发现，其hashcode不同。于是想到也许是对象的hashcode发生了变化。</p><p>通过查看HashMap的源码（HashSet的add是用HashMap的put实现的）发现，加入HashSet的对象，其hashcode是在执行add方法的时候进行计算的。所以如果一个对象的hashCode方法中包含可变域，那么将对象加入HashSet后，将其中的某个用于计算hashcode的域改变，然后再次加入HashSet后，便会出现一个对象在HashSet中存在两份的奇怪现象。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashSet</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> field<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">TestClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>field<span class="token operator">=</span>field<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setField</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>field<span class="token operator">=</span>field<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">==</span>obj<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">TestClass</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token class-name">TestClass</span> testObj<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">TestClass</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span><span class="token keyword">return</span> field<span class="token operator">==</span>testObj<span class="token punctuation">.</span>field<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> field<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestClass</span><span class="token punctuation">></span></span> testSet<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestClass</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TestClass</span> obj1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TestClass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>testSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testSet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span><span class="token function">setField</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testSet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>testSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testSet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>testSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其输出如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token class-name">Main</span>$<span class="token class-name">TestClass</span><span class="token annotation punctuation">@1</span><span class="token punctuation">]</span><span class="token boolean">true</span><span class="token punctuation">[</span><span class="token class-name">Main</span>$<span class="token class-name">TestClass</span><span class="token annotation punctuation">@2</span><span class="token punctuation">]</span><span class="token boolean">false</span><span class="token punctuation">[</span><span class="token class-name">Main</span>$<span class="token class-name">TestClass</span><span class="token annotation punctuation">@2</span><span class="token punctuation">,</span> <span class="token class-name">Main</span>$<span class="token class-name">TestClass</span><span class="token annotation punctuation">@2</span><span class="token punctuation">]</span><span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，第一次将对象obj1加入testSet后，testSet中只有一个对象，且contains方法有效。然后将对象obj1中的field值改变，此时testSet的contains便失效了。因为此时obj1的hashcode改变，testSet无法根据hashcode来找到之前的那个对象。然后将obj1再次加入testSet中，此时testSet里面便有同一个对象的两个引用了。</p><h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><p>不要把对象的可变域作为hashcode的计算依据，否则会出现各种意想不到的情况。比如contains失效、remove失效等等。  建议将hashcode使用的域选定为不容易更改的，如id,name，并且将这些属性设为final。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何基于UDP实现可靠传输</title>
      <link href="/2024/04/30/ru-he-ji-yu-udp-shi-xian-ke-kao-chuan-shu/"/>
      <url>/2024/04/30/ru-he-ji-yu-udp-shi-xian-ke-kao-chuan-shu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小米集团暑期实习-一面面经</title>
      <link href="/2024/04/29/xiao-mi-ji-tuan-shu-qi-shi-xi-yi-mian-mian-jing/"/>
      <url>/2024/04/29/xiao-mi-ji-tuan-shu-qi-shi-xi-yi-mian-mian-jing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-最近在读什么技术书籍？"><a href="#1-最近在读什么技术书籍？" class="headerlink" title="1.最近在读什么技术书籍？"></a>1.最近在读什么技术书籍？</h3><h3 id="2-你的专业是信息与计算科学，和计算机科学与技术有什么区别？问了转专业相关的事情。"><a href="#2-你的专业是信息与计算科学，和计算机科学与技术有什么区别？问了转专业相关的事情。" class="headerlink" title="2.你的专业是信息与计算科学，和计算机科学与技术有什么区别？问了转专业相关的事情。"></a>2.你的专业是信息与计算科学，和计算机科学与技术有什么区别？问了转专业相关的事情。</h3><h3 id="3-校勤工官网的-资料文件下载-功能是怎么实现的？信息浏览页面有分页吗？"><a href="#3-校勤工官网的-资料文件下载-功能是怎么实现的？信息浏览页面有分页吗？" class="headerlink" title="3.校勤工官网的 资料文件下载 功能是怎么实现的？信息浏览页面有分页吗？"></a>3.校勤工官网的 资料文件下载 功能是怎么实现的？信息浏览页面有分页吗？</h3><h3 id="4-项目中的nacos是用来干什么的？"><a href="#4-项目中的nacos是用来干什么的？" class="headerlink" title="4.项目中的nacos是用来干什么的？"></a>4.项目中的nacos是用来干什么的？</h3><p>我们知道nacos有两大功能，一个是服务的发现与注册，另一个是管理配置信息。由于我们这个项目在后期可能会多实例部署，因此使用了nacos，使得在nacos一个地方修改，其他服务实例都能获取到最新的配置</p><h4 id="配置管理具体管理了哪些信息？"><a href="#配置管理具体管理了哪些信息？" class="headerlink" title="配置管理具体管理了哪些信息？"></a>配置管理具体管理了哪些信息？</h4><h4 id="修改配置信息后，需要重启服务吗？"><a href="#修改配置信息后，需要重启服务吗？" class="headerlink" title="修改配置信息后，需要重启服务吗？"></a>修改配置信息后，需要重启服务吗？</h4><h4 id="nacos适用于哪些场景呢？"><a href="#nacos适用于哪些场景呢？" class="headerlink" title="nacos适用于哪些场景呢？"></a>nacos适用于哪些场景呢？</h4><h3 id="5-讲一下常用的垃圾回收算法和垃圾回收器"><a href="#5-讲一下常用的垃圾回收算法和垃圾回收器" class="headerlink" title="5.讲一下常用的垃圾回收算法和垃圾回收器"></a>5.讲一下常用的垃圾回收算法和垃圾回收器</h3><h3 id="6-讲一讲HTTP-3-0的QUIC协议"><a href="#6-讲一讲HTTP-3-0的QUIC协议" class="headerlink" title="6.讲一讲HTTP&#x2F;3.0的QUIC协议"></a>6.讲一讲HTTP&#x2F;3.0的QUIC协议</h3><h4 id="QUIC协议为了保证可靠传输，做了哪些工作"><a href="#QUIC协议为了保证可靠传输，做了哪些工作" class="headerlink" title="QUIC协议为了保证可靠传输，做了哪些工作"></a>QUIC协议为了保证可靠传输，做了哪些工作</h4><h3 id="7-TCP协议为了保证可靠传输，做了哪些工作"><a href="#7-TCP协议为了保证可靠传输，做了哪些工作" class="headerlink" title="7.TCP协议为了保证可靠传输，做了哪些工作"></a>7.TCP协议为了保证可靠传输，做了哪些工作</h3><h3 id="8-做一道算法题，组合总和"><a href="#8-做一道算法题，组合总和" class="headerlink" title="8.做一道算法题，组合总和"></a>8.做一道算法题，组合总和</h3>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里国际暑期实习-一面&amp;二面面经</title>
      <link href="/2024/04/16/a-li-guo-ji-shu-qi-shi-xi-yi-mian-er-mian-mian-jing/"/>
      <url>/2024/04/16/a-li-guo-ji-shu-qi-shi-xi-yi-mian-er-mian-mian-jing/</url>
      
        <content type="html"><![CDATA[<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>主要是问项目，问实习，问的很仔细。我说在更新热门博客这个功能上，是每15min更新一次，使用了分布式锁保证每次只有一台机器来执行这个定时任务。面试官问为什么没有使用分布式任务调度中间件？然后问分布式锁是怎样实现的。</p><p>问实习干了什么，为什么项目中要使用MongoDB数据库。</p><p>最后问我在做过的所有项目中，你觉得遇到的最大困难是什么？是如何解决的？</p><p>唯一的八股文，他问我有没有使用过jvm，有没有调过jvm参数什么的，我说没有。然后他就让我讲一下类加载机制，内存结构，垃圾回收算法这些。</p><img src="/2024/04/16/a-li-guo-ji-shu-qi-shi-xi-yi-mian-er-mian-mian-jing/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240428170908.jpg" style="zoom: 25%;"><p>阿里系的约面试很快，你上午投完，下午可能就会接到电话，然后问你啥时候有空可以面试。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><h4 id="1-平时是如何学习Java的，学习多久了？"><a href="#1-平时是如何学习Java的，学习多久了？" class="headerlink" title="1.平时是如何学习Java的，学习多久了？"></a>1.平时是如何学习Java的，学习多久了？</h4><h4 id="2-说一说快排算法的思路。"><a href="#2-说一说快排算法的思路。" class="headerlink" title="2.说一说快排算法的思路。"></a>2.说一说快排算法的思路。</h4><h4 id="3-TCP挥手为什么要有TIME-WAIT状态？为什么TIME-WAIT的时间是2MSL？"><a href="#3-TCP挥手为什么要有TIME-WAIT状态？为什么TIME-WAIT的时间是2MSL？" class="headerlink" title="3.TCP挥手为什么要有TIME_WAIT状态？为什么TIME_WAIT的时间是2MSL？"></a>3.TCP挥手为什么要有TIME_WAIT状态？为什么TIME_WAIT的时间是2MSL？</h4><h4 id="4-有若干包裹，重量在50g-2000g之间，我们可以将多个包裹打包一起用快速发出。现在规定一个快递的重量不能超过2000g，为了减少运费，应该怎样编排，才能使发出的总快递数最少？"><a href="#4-有若干包裹，重量在50g-2000g之间，我们可以将多个包裹打包一起用快速发出。现在规定一个快递的重量不能超过2000g，为了减少运费，应该怎样编排，才能使发出的总快递数最少？" class="headerlink" title="4.有若干包裹，重量在50g~2000g之间，我们可以将多个包裹打包一起用快速发出。现在规定一个快递的重量不能超过2000g，为了减少运费，应该怎样编排，才能使发出的总快递数最少？"></a>4.有若干包裹，重量在50g~2000g之间，我们可以将多个包裹打包一起用快速发出。现在规定一个快递的重量不能超过2000g，为了减少运费，应该怎样编排，才能使发出的总快递数最少？</h4><h4 id="5-Redis为什么要使用B-树而不是B树"><a href="#5-Redis为什么要使用B-树而不是B树" class="headerlink" title="5.Redis为什么要使用B+树而不是B树"></a>5.Redis为什么要使用B+树而不是B树</h4><h4 id="6-有4个线程，怎样使他们按顺序执行？"><a href="#6-有4个线程，怎样使他们按顺序执行？" class="headerlink" title="6.有4个线程，怎样使他们按顺序执行？"></a>6.有4个线程，怎样使他们按顺序执行？</h4><h4 id="7-java-util-concurrent有了解吗？"><a href="#7-java-util-concurrent有了解吗？" class="headerlink" title="7.java.util.concurrent有了解吗？"></a>7.java.util.concurrent有了解吗？</h4>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>淘天集团暑期实习-面经</title>
      <link href="/2024/04/02/tao-tian-ji-tuan-shu-qi-shi-xi-mian-jing/"/>
      <url>/2024/04/02/tao-tian-ji-tuan-shu-qi-shi-xi-mian-jing/</url>
      
        <content type="html"><![CDATA[<h3 id="1-讲一下http协议的历史各版本以及主要特点"><a href="#1-讲一下http协议的历史各版本以及主要特点" class="headerlink" title="1.讲一下http协议的历史各版本以及主要特点"></a>1.讲一下http协议的历史各版本以及主要特点</h3><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h4><p>1991年提出了HTTP&#x2F;0.9，它最主要的特点就是简单，只有一个GET命令，它虽然简单，但是充分验证了WEB服务的可行性。</p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p><code>HTTP/1.0</code>的最重要的特征就是<code>短连接</code>，也就是每次发送请求的时候都会建立TCP连接，等收到响应就会断开连接。因此在大量请求到来的时候，会反复的创建和销毁连接，性能就会严重下降。</p><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>于是<code>HTTP/1.1</code>引入了长连接，这种机制就是说，只要请求的收发双方没有一方明确提出要断开连接，那么就会保留这条<code>TCP</code>连接，减少了<code>TCP</code>连接的三报文握手和四报文挥手的开销。</p><p>同时，由于多个<code>请求-响应</code>复用同一条<code>TCP</code>连接，这使得<code>管道网络传输</code>成为可能，也就是说，这时候客户端发送请求时，不必等待前一个请求的响应到达即可发送请求。</p><h4 id="问：管道网络传输中，客户端发来的请求1，2，3，服务端返回一定要按顺序1-2-3吗？"><a href="#问：管道网络传输中，客户端发来的请求1，2，3，服务端返回一定要按顺序1-2-3吗？" class="headerlink" title="问：管道网络传输中，客户端发来的请求1，2，3，服务端返回一定要按顺序1,2,3吗？"></a>问：管道网络传输中，客户端发来的请求1，2，3，服务端返回一定要按顺序1,2,3吗？</h4><p>是的，这是因为如果不按请求顺序进行响应，就有可能将A的响应给到B，将B的响应给A，造成错乱</p><hr><p>但是<code>HTTP/1.1</code>还是有一部分缺点</p><ul><li>报文的头部没有做压缩，而只能对<code>body</code>做压缩，因此当头部的体积过大时，将导致网络<code>I/O</code>传输性能下降</li><li>将导致队头阻塞问题，虽然使用管道网络传输能够异步发送请求，但是接收响应却是同步的，在这种情况下，如果前面的响应没有发回来，然后后面的请求将一直无法接收到响应</li><li>没有提供解决队头阻塞的优先级机制</li><li>请求只能从客户端开始，服务器只能够被动响应，服务端无法主动推送服务</li></ul><h4 id="HTTP-2-0做了哪些优化？这个问题应该要从两个方面进行回答，第一个方面是安全方面。"><a href="#HTTP-2-0做了哪些优化？这个问题应该要从两个方面进行回答，第一个方面是安全方面。" class="headerlink" title="HTTP&#x2F;2.0做了哪些优化？这个问题应该要从两个方面进行回答，第一个方面是安全方面。"></a>HTTP&#x2F;2.0做了哪些优化？这个问题应该要从两个方面进行回答，第一个方面是<strong>安全方面</strong>。</h4><p><code>HTTP/2</code>引入了<code>TLS1.2+</code>，也就是基于<code>HTTPS</code>的机制，使得<code>HTTP/2</code>的传输变得更加安全了。</p><p><img src="/2024/04/02/tao-tian-ji-tuan-shu-qi-shi-xi-mian-jing/%E4%B8%8B%E8%BD%BD%20(4).png"></p><p>第二个是<strong>性能方面</strong>做了比较大的改动。</p><p><strong>1.压缩首部，减少冗余传输</strong></p><p>我们刚刚提到HTTP&#x2F;1.1的报文的头部没有压缩，如果头部比较冗长，就会导致大量冗余的信息在网络中传输。</p><blockquote><p>对于这个痛点，HTTP&#x2F;2提供的解决方案是，客户端和服务端双方维护一张<code>头信息表</code>，这张表在初始化就被静态写入一些常用的头部字段，当需要使用到这些头部字段<code>(以key-value的形式存储)</code>的时候，就在数据包的头部中封装一个字段<code>header：1 xxxx</code>，其中1代表着这个头部字段在头信息表存在，xxx代表的是索引号，当第一个字段为0的时候，代表不存在，然后后边的这些xxx就是实际上的头部字段，然后传输到对等端的时候，会将这个字段记录到动态表中，方便下次使用</p></blockquote><p><strong>2.全面二进制，节省了传输所需的数据量</strong></p><p><code>HTTP/1.1</code>的数据传输是基于<code>文本传输</code>的，而计算机只能读取二进制数据，因此在发送时需要将文本转换成二进制，在接收时需要将二进制转换成文本。我们采用全面二进制编码之后，比如状态码’2’ ‘0’ ‘0’ ，在http&#x2F;1.1中需要占用三个字节，然而在<code>HTTP/2</code>中它表示为表示为<code>1100 1000</code>，节省了两个字节。</p><p><strong>3.引入Stream机制，解决队头阻塞问题</strong></p><p>我们上面提到，客户端发送了请求1,2,3后，服务端响应也要按照1,2,3的顺序来，这就会产生<strong>队头阻塞现象</strong>，</p><blockquote><p>当第一个请求发送出去之后，由于I&#x2F;O或者其他原因很长时间都没有收到响应，但是这时候后面的请求又都在排队，从而导致后面的请求无法得到响应，客户端陷入阻塞状态</p></blockquote><p>HTTP&#x2F;2.0引入了Stream流，它的核心思想就是给响应包加上一个控制字段，让这些包能够标识出来是属于谁的响应。在同一个<code>TCP</code>连接中存在多个<code>Strteam</code>，这多个<code>Stream</code>就代表着同一对<code>请求-响应</code>，他们通过标识<code>StreamId</code>对这些<code>Stream</code>进行标识，从而确保请求能够收到对应的响应。</p><p>这样的话，我们假设响应是乱序返回的，比如请求1，2发送，然后响应2，1返回，因为存在<code>StreamId</code>，接收方就能够通过不同<code>Id</code>标识拿到自己想要的数据包。<strong>本质上就是IO多路复用，提高了传输性能</strong></p><p><strong>4.允许服务端主动推送</strong></p><p>主动推送是通过服务器在接收到客户端请求后，主动向客户端推送额外的资源，而不需要客户端单独请求这些资源。 例如，可以提前向客户端发送一些与请求相关的资源，以提高页面加载速度。</p><p>服务器向客户端发送一个带有 PUSH_PROMISE 帧的响应，告诉客户端将要推送的资源。  4. 客户端收到 PUSH_PROMISE 帧后，可以决定是否接受推送的资源。</p><p><strong>HTTP&#x2F;2.0的缺陷</strong></p><p>它同样存在队头阻塞的问题，<code>只不过它的队头阻塞问题</code>是因为滑动窗口的限制而产生的，也就是队头阻塞产生在<code>TCP</code>层面，先来讲讲它是怎么产生的。</p><p>我们假设发送双方维护了一个窗口，然后A同时发送了<code>P1/P2/P3/p4/p5</code>然后等待ACK，然后B能够接收<code>P1/P2</code></p><p>接收完P1之后，但是P2丢掉了，于是它只能够等待<code>P2</code>的超时重传，那么这期间，如果A再发送<code>P3/P4/P5</code>，都不能够再次接收。</p><h4 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h4><p>既然谈到了优化，那么肯定就是解决<code>HTTP/2</code>所没有解决的问题，<code>HTTP/2</code>没有解决<code>TCP</code>层面的队头阻塞问题</p><blockquote><p>但是这个问题是致命的，因为发送窗口和接收窗口不可能无限制大小，而且为了可靠传输，必须保证数据包的有序接收，因此一个思路就是，修改底层的实现，改为<code>UDP</code>实现</p></blockquote><p>首先要解决的问题是：之前提供的<code>HTTP</code>协议都是<code>TCP</code>的可靠传输，那么我们必须基于<code>UDP</code>实现可靠传输</p><blockquote><p>核心就是上图中的<code>QUIC</code>协议</p></blockquote><p><code>QUIC</code>协议也有类似的<code>HTTP/2</code>中的<code>Stream</code>的机制，也就是说一条连接中有也有多个<code>Stream</code>，但是每一个<code>Stream</code>并不公用一个窗口，而是有各自的滑动窗口，因此如果流中的包丢失了，只会导致这个<code>请求-响应</code>被阻塞，其他的不被阻塞，这就解决了队头问题</p><p>与此同时，<code>QUIC</code>协议还基于<code>UDP</code>协议提高了性能</p><p><strong>更快的连接建立</strong></p><p>对比与<code>HTTP/1.0、HTTP/1.1</code>的实现，由于<code>TCP+TLS</code>的实现基于内核的<code>TCP</code>传输层和<code>openssl</code>库实现的，因此难以解耦，而<code>QUIC</code>的思路是：在完成连接握手的时候，在帧的首部携带上<code>TLS</code>认证信息，这个过程主要是为了确认双方的连接<code>ID</code></p><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p><strong>连接的迁移</strong></p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><hr><h3 id="2-讲一下进程和线程的区别？"><a href="#2-讲一下进程和线程的区别？" class="headerlink" title="2.讲一下进程和线程的区别？"></a>2.讲一下进程和线程的区别？</h3><p>本质区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位。</p><ul><li>在开销方面：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器</li><li>稳定性方面：进程中每个线程如果崩溃了，可能导致整个进程崩溃。而一个进程的崩溃不会影响其他进程。</li><li>包含关系来看：没有线程的进程可以看作单线程的，一个线程可以有多个线程。</li></ul><p>具体到Java里面，使用main方法的时候其实就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>。</p><h3 id="3-讲一下虚拟内存"><a href="#3-讲一下虚拟内存" class="headerlink" title="3.讲一下虚拟内存"></a>3.讲一下虚拟内存</h3><h4 id="虚拟内存是怎么换页的，怎么寻址的？"><a href="#虚拟内存是怎么换页的，怎么寻址的？" class="headerlink" title="虚拟内存是怎么换页的，怎么寻址的？"></a>虚拟内存是怎么换页的，怎么寻址的？</h4><h4 id="虚拟内存除了解决内存不够的问题，还有哪些好处？"><a href="#虚拟内存除了解决内存不够的问题，还有哪些好处？" class="headerlink" title="虚拟内存除了解决内存不够的问题，还有哪些好处？"></a>虚拟内存除了解决内存不够的问题，还有哪些好处？</h4><h4 id="虚拟内存有哪些坏处？"><a href="#虚拟内存有哪些坏处？" class="headerlink" title="虚拟内存有哪些坏处？"></a>虚拟内存有哪些坏处？</h4><hr><h3 id="4-Java中的String，StringBuilder，StringBuffer有哪些区别？"><a href="#4-Java中的String，StringBuilder，StringBuffer有哪些区别？" class="headerlink" title="4.Java中的String，StringBuilder，StringBuffer有哪些区别？"></a>4.Java中的String，StringBuilder，StringBuffer有哪些区别？</h3><h4 id="StringBuffer是怎么保证线程安全的？"><a href="#StringBuffer是怎么保证线程安全的？" class="headerlink" title="StringBuffer是怎么保证线程安全的？"></a>StringBuffer是怎么保证线程安全的？</h4><hr><h3 id="5-讲一下Java虚拟机的垃圾回收算法"><a href="#5-讲一下Java虚拟机的垃圾回收算法" class="headerlink" title="5.讲一下Java虚拟机的垃圾回收算法"></a>5.讲一下Java虚拟机的垃圾回收算法</h3><h4 id="CMS垃圾回收器"><a href="#CMS垃圾回收器" class="headerlink" title="CMS垃圾回收器"></a>CMS垃圾回收器</h4><hr><h3 id="6-MySQL的隔离级别，各个级别有什么问题？"><a href="#6-MySQL的隔离级别，各个级别有什么问题？" class="headerlink" title="6.MySQL的隔离级别，各个级别有什么问题？"></a>6.MySQL的隔离级别，各个级别有什么问题？</h3><h4 id="为什么InnoDB的默认隔离级别不是串行化？"><a href="#为什么InnoDB的默认隔离级别不是串行化？" class="headerlink" title="为什么InnoDB的默认隔离级别不是串行化？"></a>为什么InnoDB的默认隔离级别不是串行化？</h4><p>我答串行化的并发能力很低，在一些业务下可以牺牲数据的准确性来换取性能。在他提示下我才反应过来是MVCC机制解决了RR级别下的幻读问题。</p><hr><h3 id="7-讲一下MVCC"><a href="#7-讲一下MVCC" class="headerlink" title="7.讲一下MVCC"></a>7.讲一下MVCC</h3><p>mvcc我的回答中提到了undo-log</p><hr><h3 id="8-对于MySQL中的日志有哪些了解？"><a href="#8-对于MySQL中的日志有哪些了解？" class="headerlink" title="8.对于MySQL中的日志有哪些了解？"></a>8.对于MySQL中的日志有哪些了解？</h3><h4 id="bin-log是什么？"><a href="#bin-log是什么？" class="headerlink" title="bin-log是什么？"></a>bin-log是什么？</h4><h4 id="redo-log是怎么保证持久化的？"><a href="#redo-log是怎么保证持久化的？" class="headerlink" title="redo-log是怎么保证持久化的？"></a>redo-log是怎么保证持久化的？</h4><hr><h3 id="9-问了项目中的分布式锁"><a href="#9-问了项目中的分布式锁" class="headerlink" title="9.问了项目中的分布式锁"></a>9.问了项目中的分布式锁</h3><hr><h3 id="10-你的项目中用到了Netty是吧，讲一下你对bio和nio的了解"><a href="#10-你的项目中用到了Netty是吧，讲一下你对bio和nio的了解" class="headerlink" title="10.你的项目中用到了Netty是吧，讲一下你对bio和nio的了解"></a>10.你的项目中用到了Netty是吧，讲一下你对bio和nio的了解</h3><h4 id="nio的底层实现，如epoll这些有没有了解"><a href="#nio的底层实现，如epoll这些有没有了解" class="headerlink" title="nio的底层实现，如epoll这些有没有了解"></a>nio的底层实现，如epoll这些有没有了解</h4><hr><h3 id="11-怎样解决缓存穿透问题？"><a href="#11-怎样解决缓存穿透问题？" class="headerlink" title="11.怎样解决缓存穿透问题？"></a>11.怎样解决缓存穿透问题？</h3><h4 id="布隆过滤器的底层数据结构"><a href="#布隆过滤器的底层数据结构" class="headerlink" title="布隆过滤器的底层数据结构"></a>布隆过滤器的底层数据结构</h4><hr><h3 id="12-反问"><a href="#12-反问" class="headerlink" title="12.反问"></a>12.反问</h3><h4 id="Java的竞争太激烈，如果我去转岗到测试开发怎么样？"><a href="#Java的竞争太激烈，如果我去转岗到测试开发怎么样？" class="headerlink" title="Java的竞争太激烈，如果我去转岗到测试开发怎么样？"></a>Java的竞争太激烈，如果我去转岗到测试开发怎么样？</h4><h4 id="网有非常多的人渴望到互联网大厂工作，同时也有小部分人在劝退，你是怎么看待这样一份工作的？"><a href="#网有非常多的人渴望到互联网大厂工作，同时也有小部分人在劝退，你是怎么看待这样一份工作的？" class="headerlink" title="网有非常多的人渴望到互联网大厂工作，同时也有小部分人在劝退，你是怎么看待这样一份工作的？"></a>网有非常多的人渴望到互联网大厂工作，同时也有小部分人在劝退，你是怎么看待这样一份工作的？</h4>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM之类加载机制</title>
      <link href="/2024/04/02/jvm-zhi-lei-jia-zai-ji-zhi/"/>
      <url>/2024/04/02/jvm-zhi-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当 Java 虚拟机将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程，这个过程我们叫：Java 虚拟机的类加载机制。JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：<strong>加载、验证、准备、解析、初始化、使用、卸载。</strong></p><h3 id="1-你简单说说类加载的七个阶段干了什么？"><a href="#1-你简单说说类加载的七个阶段干了什么？" class="headerlink" title="1.你简单说说类加载的七个阶段干了什么？"></a>1.你简单说说类加载的七个阶段干了什么？</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>将字节码文件从磁盘加载到内存，接着会为这个类在 JVM 的方法区创建一个对应的 <strong>Class 对象</strong>，这个 Class 对象就是这个类各种数据的访问入口。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型：</p><ul><li><strong>JVM规范校验。</strong>JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 <code>0x cafe bene</code>开头，主次版本号是否在当前虚拟机处理范围之内等。</li><li><strong>代码逻辑校验。</strong>JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类。</li></ul><h4 id="准备（重点）"><a href="#准备（重点）" class="headerlink" title="准备（重点）"></a>准备（重点）</h4><p>当完成字节码文件的校验之后，JVM 便会开始为类变量<strong>分配内存并初始化</strong>。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。</p><ul><li><p><strong>内存分配的对象。</strong>Java 中的变量有<code>类变量</code>和<code>类成员变量</code>两种类型，<code>类变量</code>指的是被 static 修饰的变量，而其他所有类型的变量都属于<code>类成员变量</code>。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</p></li><li><p>在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该<strong>数据类型的零值</strong>，而不是用户代码里初始化的值。</p><p>例如下面的代码在准备阶段之后，sector 的值将是 0，而不是 3。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> sector <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，number 的值将是 3，而不是 0。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之所以 static final 会直接被复制，而 static 变量会被赋予零值。其实我们稍微思考一下就能想明白了。</p><p>两个语句的区别是一个有 final 关键字修饰，另外一个没有。而 final  关键字在 Java 中代表不可改变的意思，意思就是说 number 的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p></li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>  当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的<strong>符号引用替换成直接其在内存中的直接引用</strong>。</p><h4 id="初始化（重点）"><a href="#初始化（重点）" class="headerlink" title="初始化（重点）"></a>初始化（重点）</h4><p>  到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p><ul><li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p></li><li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li><li><p>当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以。    </p><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之垃圾回收器</title>
      <link href="/2024/03/30/jvm-zhi-la-ji-hui-shou-qi/"/>
      <url>/2024/03/30/jvm-zhi-la-ji-hui-shou-qi/</url>
      
        <content type="html"><![CDATA[<p>总的来说，Java 虚拟机的垃圾回收器可以分为四大类别：<strong>串行回收器、并行回收器、CMS 回收器、G1 回收器。</strong></p><p><img src="/2024/03/30/jvm-zhi-la-ji-hui-shou-qi/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240411114836.jpg"></p><h3 id="1-串行回收器"><a href="#1-串行回收器" class="headerlink" title="1.串行回收器"></a>1.串行回收器</h3><p>串行回收器是指使用单线程进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。</p><p>串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为<strong>新生代串行回收器</strong>和<strong>老年代串行回收器</strong>。</p><h4 id="1-1新生代串行回收器"><a href="#1-1新生代串行回收器" class="headerlink" title="1.1新生代串行回收器"></a>1.1新生代串行回收器</h4><p>串行回收器是所有垃圾回收器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。</p><p>在新生代串行回收器中使用的是复制算法。在串行回收器进行垃圾回收时，会产生 Stop-The-World 现象，即其他线程都需要暂停，等待垃圾回收完成。因此在某些情况下，其会造成较为糟糕的用户体验。</p><blockquote><p>“Stop-the-World”现象：在进行垃圾回收时，Java应用程序的所有线程都会被暂停，直到垃圾回收完成。这意味着在这段时间内，应用程序无法继续执行任何任务，会导致应用程序的性能下降和响应时间延长。</p></blockquote><h4 id="1-2老年代串行回收器"><a href="#1-2老年代串行回收器" class="headerlink" title="1.2老年代串行回收器"></a>1.2老年代串行回收器</h4><p>在老年代串行回收器中使用的是标记压缩算法。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。</p><p>但老年代串行回收器的好处之一，就是其可以与多种新生代回收器配合使用。若要启用老年代串行回收器，可以尝试以下参数：</p><ul><li><code>-XX:UseSerialGC</code>：新生代、老年代都使用串行回收器。</li><li><code>-XX:UseParNewGC</code>：新生代使用 ParNew 回收器，老年代使用串行回收器。</li><li><code>-XX:UseParallelGC</code>：新生代使用 ParallelGC 回收器，老年代使用串行回收器。</li></ul><hr><h3 id="2并行回收器"><a href="#2并行回收器" class="headerlink" title="2并行回收器"></a>2并行回收器</h3><p>并行回收器在串行回收器的基础上做了改进，其使用多线程进行垃圾回收。对于并行能力强的机器，可以有效缩短垃圾回收所使用的时间。</p><p>根据作用内存区域的不同，并行回收器也有三个不同的回收器：<strong>新生代 ParNew 回收器</strong>、<strong>新生代 ParallelGC 回收器</strong>、<strong>老年代 ParallelGC 回收器</strong>。</p><h4 id="2-1新生代-ParNew-回收器"><a href="#2-1新生代-ParNew-回收器" class="headerlink" title="2.1新生代 ParNew 回收器"></a>2.1新生代 ParNew 回收器</h4><p>新生代 ParNew 回收器工作在新生代，其只是简单地将串行回收器多线程化，其回收策略、算法以及参数和新生代串行回收器一样。</p><p>新生代 ParNew 回收器同样使用复制的垃圾回收算法，其垃圾收集过程中同样会触发 Stop-The-World 现象。但因为其使用多线程进行垃圾回收，因此在并发能力强的 CPU 上，其产生的停顿时间要短于串行回收器。</p><p>但在单 CPU 或并能能力弱的系统中，并行回收器效果会因为线程切换的原因，其实际表现反而不如串行回收器。</p><h4 id="2-2新生代-Parallel-GC-回收器"><a href="#2-2新生代-Parallel-GC-回收器" class="headerlink" title="2.2新生代 Parallel GC 回收器"></a>2.2新生代 Parallel GC 回收器</h4><p>新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World。但其余 ParNew 回收器的一个重大不同是：其非常注重系统的吞吐量。</p><p>之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应 GC 调节策略。我们可以使用  <code>-XX:+UseAdaptiveSizePolicy</code> 参数打开这个策略，在这个模式下，新生代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数都会被自动调节，已达到堆大小、吞吐量、停顿时间的平衡点。</p><p>Parallel GC 回收器提供了两个重要参数用于控制系统的吞吐量。</p><ul><li><code>-XX:MaxGCPauseMillis</code>：设置最大垃圾收集停顿时间。在 ParallelGC 工作时，其会自动调整响应参数，将停顿时间控制在设置范围内。为了达到目的，其可能会使用较小的堆，但这会导致 GC 较为频繁。</li><li><code>-XX:GCTimeRatio</code>：设置吞吐量大小，其实一个 0 - 100 的整数。假设 GCTimeRatio 的值为 n，那么系统将不花费超过 1&#x2F;(1+n) 的时间用于垃圾手机。比如 GCTimeRatio 值为 19，那么系统用于垃圾收集的时间不超过 1 &#x2F;(1+19) &#x3D; 5%。默认情况下，它的取值是 99，即不超过 1% 的时间用于垃圾收集。</li></ul><h4 id="2-3老年代-ParallelOldGC-回收器"><a href="#2-3老年代-ParallelOldGC-回收器" class="headerlink" title="2.3老年代 ParallelOldGC 回收器"></a>2.3老年代 ParallelOldGC 回收器</h4><p>老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代 ParallelGC 收集器一样，其也是注重吞吐量的收集器，只不过其是作用于老年代。</p><p>ParallelOldGC 回收器使用的是标记压缩算法，只有在 JDK 1.6 中才可以使用。我们可以使用<code>-XX:UseParallelOldGC</code>参数在新生代中使用 ParallelGC 收集器，在老年代中使用 ParallelOldGC 收集器。参数 <code>-XX:ParallelGCThreads</code>也可以用于设置垃圾回收时的线程数量。</p><hr><h3 id="3-CMS回收器"><a href="#3-CMS回收器" class="headerlink" title="3.CMS回收器"></a>3.CMS回收器</h3><p>与 ParallelGC 和 ParallelOldGC 不同，CMS 回收器主要关注系统停顿时间。CMS 回收器全称为 Concurrent Mark Sweep，意为标记清除算法，其是一个使用多线程并行回收的垃圾回收器。</p><h4 id="3-1工作步骤"><a href="#3-1工作步骤" class="headerlink" title="3.1工作步骤"></a>3.1工作步骤</h4><p>CMS 的主要工作步骤有：初始标记、并发标记、预清理、重新标记、并发清除和并发充值。其中初始标记和重新标记是独占系统资源的，而其他阶段则可以和用户线程一起执行。</p><p>在整个 CMS 回收过程中，默认情况下会有预清理的操作，我们可以关闭开关 <code>-XX:-CMSPrecleaningEnabled</code> 不进行预清理。因为重新标记是独占 CPU 的，因此如果新生代 GC 发生之后，立刻出发一次新生代 GC，那么停顿时间就会很长。为了避免这种情况，预处理时会刻意等待一次新生代 GC 的发生，之后在进行预处理。</p><h4 id="3-2主要参数"><a href="#3-2主要参数" class="headerlink" title="3.2主要参数"></a>3.2主要参数</h4><p>启动 CMS 回收器刻意使用参数：<code>-XX:+UseConcMarkSweepGC</code>，线程并发数量刻意通过 <code>-XX:ConcGCThreads</code> 或 <code>-XX:ParallelCMSThreads</code> 参数设定。</p><p>此外，我们还可以设置 <code>-XX:CMSInitiatingOccupancyFraction</code> 来指定老年代空间使用阈值。当老年代空间使用率达到这个阈值时，会执行一次 CMS 回收，而不像其他回收器一样等到内存不够用的时候才进行 GC。</p><p>我们之前说过标记清除算法的缺点是会产生内存碎片，因此 CMS 回收器会产生较多内存碎片。我们可以使用 <code>XX:+UseCMSCompactAtFullCollection</code> 参数让 CMS 在完成垃圾回收后，进行一次内存碎片整理。使用 <code>-XX:CMSFullGCsBeforeCompaction</code> 参数设置进行多少次 CMS 回收后，进行一次内存压缩。</p><p>此外，如果希望使用 CMS 回收 Perm 区，那么则可以打开 <code>-XX:+CMSClassUnloadingEnabled</code> 开关。打开该开关后，如果条件允许，那么系统会使用 CMS 的机制回收 Perm 区 Class 数据。</p><hr><h3 id="4-G1回收器"><a href="#4-G1回收器" class="headerlink" title="4.G1回收器"></a>4.G1回收器</h3><p>G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。</p><p>G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。但它最大的改变是使用了分区算法，从而使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续。</p><p>在 G1 回收器之前，所有的垃圾回收器其内存分配都是连续的一块内存，如下图所示：</p><p><img src="/2024/03/30/jvm-zhi-la-ji-hui-shou-qi/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240411134552.png"></p><p>而在 G1 回收器中，其将一大块的内存分为许多细小的区块，从而不要求内存是连续的。</p><p><img src="/2024/03/30/jvm-zhi-la-ji-hui-shou-qi/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240411134559.png"></p><p>从上图可以看到，每个Region被标记了 E、S、O 和 H，说明每个 Region 在运行时都充当了一种角色。所有标记为 E 的都是 Eden 区的内存，它们散落在内存的各个角落，并不要求内存连续。同理，Survivor 区、老年代（Old）也是如此。</p><p>从上图我们还可以看到 H 是以往算法中没有的，它代表 Humongous。这表示这些 Region 存储的是巨型对象（humongous object，H-obj），当新建对象大小超过 Region 大小一半时，直接在新的一个或多个连续 Region 中分配，并标记为 H。</p><p>堆内存中一个 Region 的大小可以通过 <code>-XX:G1HeapRegionSize</code> 参数指定，大小区间只能是1M、2M、4M、8M、16M 和 32M，总之是2的幂次方。如果G1HeapRegionSize 为默认值，即把设置的最小堆内存按照2048份均分，最后得到一个合理的大小。</p><h4 id="4-1工作步骤"><a href="#4-1工作步骤" class="headerlink" title="4.1工作步骤"></a>4.1工作步骤</h4><p>G1 收集器的收集过程主要有四个阶段：</p><ul><li>新生代 GC</li><li>并发标记周期</li><li>混合收集</li><li>如果需要，可能进行 FullGC</li></ul><p>新生代 GC 与其他垃圾收集器的类似，就是清空 Eden 区，将存活对象移动到 Survivor 区，部分年龄到了就移动到老年代。</p><p>并发标记周期则分为：初始标记、根区域扫描、并发标记、重新标记、独占清理、并发清理阶段。其中初始标记、重新标记、独占清理是独占式的，会引起停顿。并且初始标记会引发一次新生代 GC。在这个阶段，所有将要被回收的区域会被 G1 记录在一个称之为 Collection Set 的集合中。</p><p>混合回收阶段会首先针对 Collection Set 中的内存进行回收，因为这些垃圾比例较高。G1 回收器的名字 Garbage First 就是这个意思，垃圾优先处理的意思。在混合回收的时候，也会执行多次新生代 GC 和 混合 GC，从而来进行内存的回收。</p><p>必要时进行 Full GC。当在回收阶段遇到内存不足时，G1 会停止垃圾回收并进行一次 Full GC，从而腾出更多空间进行垃圾回收。</p><h4 id="4-2相关参数"><a href="#4-2相关参数" class="headerlink" title="4.2相关参数"></a>4.2相关参数</h4><p>打开 G1 收集器，我们可以使用参数：<code>-XX:+UseG1GC</code>。 设置目标最大停顿时间，可以使用参数：<code>-XX:MaxGCPauseMillis</code>。 设置 GC 工作线程数量，可以使用参数：<code>-XX:ParallelGCThreads</code>。 设置堆使用率触发并发标记周期的执行，可以使用参数：<code>-XX:InitiatingHeapOccupancyPercent</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring常见面试题</title>
      <link href="/2024/03/27/spring-chang-jian-mian-shi-ti/"/>
      <url>/2024/03/27/spring-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-BeanFactory和FactoryBean有什么区别"><a href="#1-BeanFactory和FactoryBean有什么区别" class="headerlink" title="1.BeanFactory和FactoryBean有什么区别"></a>1.BeanFactory和FactoryBean有什么区别</h3><ul><li>BeanFactory：IoC容器顶层接口，给IoC容器提供了一套完整的规范。以Factory结尾，表示它是一个工厂类（接口），用于管理Bean的一个工厂。</li><li>FactoryBean：也是一个工厂类接口，用户可以通过该接口定制实例化Bean的逻辑，Spring自身就提供了70多个FactoryBean的实现，他们隐藏了一些实例化复杂Bean的细节，从而给上层应用带来便捷。</li></ul><h3 id="2-Autowired注解和-Resource注解有什么区别"><a href="#2-Autowired注解和-Resource注解有什么区别" class="headerlink" title="2.@Autowired注解和@Resource注解有什么区别"></a>2.@Autowired注解和@Resource注解有什么区别</h3><ul><li>Resource默认按 byName自动注入。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略.</li><li>@Autowired同样实现了bean注入功能。只不过他是默认按照byType进行装配，如果匹配类型是多个直接抛出异常、当然这个问题是可以解决的那就是@Qualifier注解进行匹配</li></ul><h3 id="3-谈谈Spring中Bean的作用域"><a href="#3-谈谈Spring中Bean的作用域" class="headerlink" title="3.谈谈Spring中Bean的作用域"></a>3.谈谈Spring中Bean的作用域</h3><p>Spring中Bean的作用域指的是Bean在容器中的存在范围，Spring框架支持以下五种Bean的作用域 ：</p><ul><li>singleton：在每个Spring IoC容器中只有一个Bean实例。</li><li>prototype：一个Bean的定义可以有多个实例。</li><li>request：在Web应用中，为每个HTTP请求创建一个Bean实例。</li><li>session：在Web应用中，为每个HTTP会话创建一个Bean实例。</li><li>global session：在基于portlet的Web应用中，为每个全局HTTP会话创建一个Bean实例。</li></ul><p>这些作用域都是通过在Bean定义中使用作用域属性来指定的。如果没有指定作用域，则默认为singleton。</p><h3 id="4-谈谈你对AOP的理解"><a href="#4-谈谈你对AOP的理解" class="headerlink" title="4.谈谈你对AOP的理解"></a>4.谈谈你对AOP的理解</h3><p>AOP也叫面向切面编程，是基于动态代理来实现的，通过代理原始类来增加额外功能，我们可以将额外功能一次定义然后配合切面达到多次使用的效果，比如记录日志，事物管理等等，提高了代码复用性，开发效率。</p><p>AOP有五类通知，通知就是在目标方法执行前或者执行后要做的动作：</p><ol><li>前置通知[Before advice]：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 </li><li>正常返回通知[After returning advice]：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 </li><li>异常返回通知[After throwing advice]：在连接点抛出异常后执行。</li><li>返回通知[After (finally) advice]：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。</li><li>环绕通知[Around advice]：环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</li></ol><p>spring使用了两种代理机制：</p><p>第一种也就是JDK自带的动态代理<br>1.JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，也就是代理实例，在代理实例中会织入代码，它是基于接口的。</p><p>第二种也就是Cglib的动态代理<br>2.Cglib是动态代理采用底层的字节码技术，在运行时创建子类的代理对象。Cglib是基于继承父类生成的代理类.</p><p>在Spirng当中动态代理的使用<br>1.如果目标对象实现了接口，默认情况下会采用JDK的动态代理来实现AOP<br>2.如果目标对象实现了接口，也可以强制使用CGlib来实现AOP<br>3.如果目标对象没有实现接口，必须采用Cglib库，Spirng会自动在JDK和CGlib用切换</p><p>JDK和动态代理和CGlib字节码的生成区别？<br>1.JDK动态代理制能对实现了接口的类生成代理，而不是针对类<br>2.CGLIB是针对类实现代理，主要对指定的类生成一个子类，覆盖其中的方法，添加额外功能，因为是继承，所以该类方法不能用final来声明.</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoC </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型介绍(select,poll,epoll)</title>
      <link href="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/"/>
      <url>/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是操作系统的IO"><a href="#1-什么是操作系统的IO" class="headerlink" title="1.什么是操作系统的IO?"></a>1.什么是操作系统的IO?</h3><p>我们如果需要对磁盘进行读取或者写入数据的时候必须得有主体去操作，这个主体就是应用程序。 应用程序是不能直接进行一些读写操作（IO）的,因为用户可能会利用此程序直接或者间接的对计算机造成破坏，只能交给底层软件—操作系统。也就是说应用程序想要对磁盘进行读取或者写入数据，只能通过操作系统对上层开放的API来进行。在任何一个应用程序里面,都会有进程地址空间，该空间分为两部分，一部分称为<strong>用户空间</strong>（允许应用程序进行访问的空间），另一部分称为<strong>内核空间</strong>（只能给操作系统进行访问的空间，它受到保护）。</p><p><strong>应用程序想要进行一次IO操作分为两个阶段：</strong></p><ul><li><strong>IO调用：</strong>应用程序进程向操作系统内核发起调用【1】</li><li><strong>IO执行：</strong>操作系统内核完成IO操作【2】</li></ul><p>操作系统完成一次IO操作包括两个过程：</p><ul><li>数据准备阶段：内核等待I&#x2F;O设备准备好数据(从网卡copy到内核缓冲区)【3】</li><li>数据copy阶段：将数据从内核缓冲区copy到用户进程缓冲区【4】</li></ul><p>总结来说，应用程序一次完整的I&#x2F;O流程包括以下步骤：</p><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430151742.png" style="zoom:80%;"><ol><li>应用程序进程向操作系统发起IO调用请求</li><li>操作系统准备数据，外部设备的数据通过网卡加载到内核缓冲区</li><li>操作系统拷贝数据，即将内核缓冲区的数据copy到用户进程缓冲区</li></ol><p><strong>而一次IO的本质其实就是：等待+拷贝</strong></p><h3 id="2-IO模型有哪些？"><a href="#2-IO模型有哪些？" class="headerlink" title="2.IO模型有哪些？"></a>2.IO模型有哪些？</h3><h4 id="2-1阻塞式IO"><a href="#2-1阻塞式IO" class="headerlink" title="2.1阻塞式IO"></a>2.1阻塞式IO</h4><p>服务端为了处理客户端的连接和数据处理：</p><p>伪代码具体如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打开一个网络通信套接字</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 绑定</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 监听</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  buf <span class="token operator">=</span> <span class="token keyword">new</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读取数据容器</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞 等待建立连接</span>  <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞 读数据</span>  <span class="token function">doSomeThing</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 处理数据</span>  <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 关闭连接</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的伪代码中我们可以看出，服务端处理客户端的请求阻塞在两个地方，一个是 accept、一个是 read ，我们这里主要研究 read 的过程，可以分为两个阶段：等待读就绪（等待数据到达网卡 &amp; 将网卡的数据拷贝到内核缓冲区）、读数据。</p><p>阻塞IO流程如下：</p><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430153145.png" style="zoom:100%;"><h4 id="2-2非阻塞式IO"><a href="#2-2非阻塞式IO" class="headerlink" title="2.2非阻塞式IO"></a>2.2非阻塞式IO</h4><p>非阻塞式 IO 我们应该让操作系统提供一个非阻塞的 read() 函数，当第一阶段读未就绪时返回 -1 ，当读已就绪时才进行数据的读取。</p><p>非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符, 这个过程称为轮询(for(connfd : arr)). 这对CPU来说是较大的浪费， 一般只有特定场景下才使用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arr</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打开一个网络通信套接字</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 绑定</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 监听</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞 等待建立连接</span>  arr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 异步线程检测 连接是否可读</span><span class="token keyword">new</span> <span class="token class-name">Tread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>connfd <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    buf <span class="token operator">=</span> <span class="token keyword">new</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读取数据容器</span>    <span class="token comment">// 非阻塞 read 最重要的是提供了我们在一个线程内管理多个文件描述符的能力</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 检测 connfd 是否可读</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token function">newThreadDeal</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 创建新线程处理</span>       <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 关闭连接 </span>       arr<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 移除已处理的连接</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">newTheadDeal</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">doSomeThing</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 处理数据</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所谓非阻塞 IO 只是将第一阶段的等待读就绪改为非阻塞，但是第二阶段的数据读取还是阻塞的，<strong>非阻塞 read 最重要的是提供了我们在一个线程内管理多个文件描述符的能力</strong>。</p><p>非阻塞具体流程如下：</p><p><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430153908.png"></p><h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3.IO多路复用"></a>3.IO多路复用</h3><p>上面的实现看着很不错，但是却存在一个很大的问题，我们需要不断的调用 read() 进行系统调用，这里的系统调用我们可以理解为分布式系统的 RPC 调用，性能损耗十分严重，因为这依然是用户层的一些小把戏。</p><p>多路复用就是系统提供了一种函数可以同时监控多个文件描述符的操作，这个函数就是我们常说到的select、poll、epoll函数，可以通过它们同时监控多个文件描述符，只要有任何一个数据状态准备就绪了，就返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起read()请求去读取数据。实际上最核心之处在于IO多路转接<strong>能够同时</strong>等待多个文件描述符的就绪状态,来达到不必为每个文件描述符创建一个对应的监控线程，从而减少线程资源创建的目的。</p><h4 id="3-1select"><a href="#3-1select" class="headerlink" title="3.1select"></a>3.1select</h4><p>select 是操作系统提供的系统函数，通过它我们可以将文件描述符发送给系统，<strong>让系统内核帮我们遍历检测是否可读</strong>，并告诉我们进行读取数据。</p><p>流程简图：</p><p><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430155044.png"></p><p><strong>优点：</strong></p><ol><li>减少大量系统调用</li><li>系统内核帮我们遍历检测是否可读</li></ol><p><strong>存在一些问题：</strong></p><ol><li>每次调用需要在用户态和内核态之间拷贝文件描述符数组，但高并发场景下这个拷贝的消耗是很大的</li><li>内核检测文件描述符是否可读还是通过遍历实现，当文件描述符数组很长时，遍历操作耗时也很长</li><li>内核检测完文件描述符数组后，当存在可读的文件描述符数组时，用户态需要再遍历检测一遍</li></ol><h4 id="3-2poll"><a href="#3-2poll" class="headerlink" title="3.2poll"></a>3.2poll</h4><ul><li>poll 和 select 原理基本一致，最大的区别是去掉了最大 1024 个文件描述符的限制</li><li>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符</li><li>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制</li></ul><h4 id="3-3epoll"><a href="#3-3epoll" class="headerlink" title="3.3epoll"></a>3.3epoll</h4><p>epoll 主要优化了上面三个问题实现：</p><ol><li>每次调用需要在用户态和内核态之间拷贝文件描述符数组，但高并发场景下这个拷贝的消耗是很大的。<br>方案：内核中保存一份文件描述符，无需用户每次传入，而是仅同步修改部分。</li><li>内核检测文件描述符可读还是通过遍历实现，当文件描述符数组很长时，遍历操作耗时也很长。<br>方案：通过事件唤醒机制唤醒替代遍历</li><li>内核检测完文件描述符数组后，当存在可读的文件描述符数组时，用户态需要再遍历检测一遍<br>方案：仅将可读部分文件描述符同步给用户态，不需要用户态再次遍历</li></ol><p>epoll 基于高效的红黑树结构，提供了三个核心操作：epoll_create、epoll_ctl、epoll_wait，也就是三步走：创建、登记、等待事件。</p><p><strong>第一步：创建epoll对象</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> epoll_fd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有了epoll_fd就可以管理所有的网络连接（fd）了</p><p><strong>为什么epoll使用的数据结构是红黑树？</strong></p><ol><li>自平衡、节点有序：红黑树是一种自平衡二叉树，确保 <code>fd</code> 列表始终保持有序，方便快速查找。</li><li>操作高效：红黑树的增、删、查操作的时间复杂度为 <code>O(log N)</code>，即使面对成百上千的 （<code>fd</code>），也能迅速找到或更新信息。</li></ol><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430160508.png" style="zoom:50%;"><p><strong>第二步：添加fd并设定监听事件</strong></p><p>epoll_ctl函数用于增加，删除，修改epoll事件，epoll事件会存储于内核epoll结构体红黑树中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ev<span class="token punctuation">;</span>ev<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>        <span class="token comment">// 设置监听“有新请求”事件</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>       <span class="token comment">// 客户的文件描述符</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430160758.png" style="zoom: 50%;"><p><strong>第三步：等待事件触发-集中处理fd的请求</strong></p><p>当所有fd都登记好之后，<strong>epoll</strong> 就进入了“待命模式”，它会专注于那些“真的有事”的 VIP 客户，其他客户保持静默就不用理会。这个等待事件触发的过程通过 <strong>epoll_wait</strong> 完成，epoll_wait用于监听套接字事件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> events<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// 用来存储触发事件的客户</span><span class="token keyword">int</span> nfds <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epoll_fd<span class="token punctuation">,</span> events<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待事件</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nfds<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 处理客户的请求</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>epoll_wait</strong>  只会通知我们那些“有需求”的 VIP 客户。每当调用 <strong>epoll_wait</strong>，它会检查所有已登记的 VIP 客户，并把有事件的客户集中放在 <strong>events</strong> 数组里，返回给我们。这样一来，我们只需处理这些真正有需求的 VIP 客户，其他静默的客户则可以忽略，省时省力。</p><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430161014.png" style="zoom:50%;"><p><strong>epoll 采用的另一个数据结构：双向链表：</strong></p><p>在内核中，<strong>epoll</strong> 会把所有“发出请求”的 VIP 客户(真正有数据到来的客户端fd)从红黑树移到双向链表中。双向链表中只存储那些有数据到来的客户端 fd，这样 <strong>epoll_wait</strong> 能一次性返回所有“有数据到来”的客户端fd，进一步提高效率。</p><p><strong>红黑树 + 双向链表：epoll 的高效组合</strong></p><ul><li>红黑树：负责管理所有 VIP 客户的注册信息，确保增删查的效率。</li><li>双向链表：只存放那些已触发事件的客户，保证我们只需集中处理“有需求”的客户。</li></ul><p>这种红黑树和双向链表的组合，让 epoll 能高效筛选出有请求的 VIP 客户，把系统资源集中在真正有需求的连接上，大大提高了性能。epoll_wait 就像 epoll贴心的“智能秘书”，只提醒我们需要处理的 VIP 客户，保证我们高效完成所有请求。</p><p><strong>整体运转如下：</strong></p><img src="/2024/03/27/io-mo-xing-jie-shao-select-poll-epoll/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240430161140.png" style="zoom:50%;"><p>伪代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打开一个网络通信套接字</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 绑定</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 监听</span><span class="token keyword">int</span> ep_fd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 epoll 对象</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞 等待建立连接</span>  <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将新连接加入到 epoll 对象</span><span class="token punctuation">&#125;</span><span class="token comment">// 异步线程检测 通过 epoll_wait 阻塞获取可读的套接字</span><span class="token keyword">new</span> <span class="token class-name">Tread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>arr <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>connfd <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 仅返回可读套接字</span>        <span class="token function">newTheadDeal</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">newTheadDeal</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    buf <span class="token operator">=</span> <span class="token keyword">new</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读取数据容器</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞读取数据</span>    <span class="token function">doSomeThing</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 处理数据</span>    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 关闭连接 </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4为什么epoll高效？"><a href="#3-4为什么epoll高效？" class="headerlink" title="3.4为什么epoll高效？"></a>3.4为什么epoll高效？</h4><ul><li>红黑树：红黑树提高了epoll事件增删改查的效率</li><li>回调通知机制：当epoll监听套接字有数据读或者写时，会通过注册到socket的回调函数通知epoll，epoll检测到事件后，将事件存储在就绪队列（rdllist）。</li><li>就绪队列：epoll_wait返回成功后，会将所有就绪事件存储在事件数组，用户不需要进行无效的轮询，从而提高了效率</li></ul><h3 id="4-异步IO"><a href="#4-异步IO" class="headerlink" title="4.异步IO"></a>4.异步IO</h3><p>应用只需要向内核发送一个读取请求，告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种模式为异步IO模型。</p><p>异步IO的优化思路是解决应用程序需要先后发送询问请求、接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。</p><h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5.同步和异步的区别"></a>5.同步和异步的区别</h3><p>同步和异步关注的是消息通信机制.</p><p>同步：就是在发出一个调用时，自己需要参与等待结果的过程，则为同步，前面的select,poll,epoll都自己参与了，所以也称为同步IO。</p><p>异步：则指出发出调用以后,到数据准备完成，自己都未参与，则为异步IO</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志系统详解</title>
      <link href="/2024/03/17/mysql-ri-zhi-xi-tong-xiang-jie/"/>
      <url>/2024/03/17/mysql-ri-zhi-xi-tong-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的过程，可以帮助数据库管理员追踪数据库曾经发生过的各种事件</p><p>MySQL日志主要包括六种：</p><ol><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>归档日志（binlog）（二进制日志）</li><li>错误日志（errorlog）</li><li>慢查询日志（slow query log）</li><li>一般查询日志（general log）</li><li>中继日志（relay log）</li></ol><p>本文我们重点介绍前3种日志。redo log保证了事务的持久性，undo log可以实现事务回滚，保证了事务的原子性和隔离性，bin log保证服务器可以基于时间点回复数据，还用于主从复制</p><hr><h3 id="1-redo-log是什么？为什么需要redo-log"><a href="#1-redo-log是什么？为什么需要redo-log" class="headerlink" title="1.redo log是什么？为什么需要redo log?"></a>1.redo log是什么？为什么需要redo log?</h3><p>我们知道，InnoDB存储引擎是<strong>以页为单位</strong>来进行增删改查这些操作的。在访问页面之前，需要到磁盘中把页加载到内存中的<code>Buffer Pool</code>中，但是内存中的数据在宕机或者系统突然崩溃的时候是会丢失的，事务又需要保证持久性，redo log就是用来保证持久性的。</p><blockquote><ol><li><strong>作用</strong>：Buffer Pool用于存储数据库中的数据页，包括表数据和索引数据。当查询需要访问某个数据页时，MySQL首先会在Buffer Pool中查找，如果数据页已经在内存中，则直接返回数据，避免了频繁的磁盘读写操作。</li><li><strong>LRU算法</strong>：Buffer Pool采用LRU（Least Recently Used）算法来管理内存中的数据页。当内存空间不足时，MySQL会根据LRU算法淘汰最近最少使用的数据页，以腾出空间给新的数据页。</li></ol></blockquote><hr><h3 id="2-为什么不把事务修改过的数据页立即刷新到磁盘？"><a href="#2-为什么不把事务修改过的数据页立即刷新到磁盘？" class="headerlink" title="2.为什么不把事务修改过的数据页立即刷新到磁盘？"></a>2.为什么不把事务修改过的数据页立即刷新到磁盘？</h3><ol><li>刷新一个完整的数据页太浪费了。有时我们仅仅修改了某个页面的一个字节，但是InnoDB是以页为单位来进行磁盘I&#x2F;O的，一页的默认大小是16KB，这样太浪费了。</li><li>随机I&#x2F;O刷新起来比较慢。事务修改的页面可能并不相邻，这意为着将这些页面刷新到磁盘时，需要进行很多随机I&#x2F;O。随机I&#x2F;O比顺序IO慢，尤其是对比传统IO。</li><li>redo log是把修改过的内容记录下来。比如sql语句是<code>update user set age = 20 where id = 1</code>，那么在日志里面写入的可能是<em>将第0号表空间的第100号页面中偏移量为1000处的值更新为2</em><br>事务在提交时把上述内容刷新到磁盘就可以了。redo log占用的空间不是很大，而且使用顺序IO</li></ol><hr><h3 id="3-redo-log的写入过程是怎样的？"><a href="#3-redo-log的写入过程是怎样的？" class="headerlink" title="3.redo log的写入过程是怎样的？"></a>3.redo log的写入过程是怎样的？</h3><p>InnoDB为了解决磁盘速度过慢的问题而引入了Buffer Pool。同理，写入redo日志时也不能直接写到磁盘中，在数据库服务器内部有一片连续的内存空间，称为<code>redo log buffer</code>（redo 日志缓冲区），简称为log buffer，这片空间被划分为若干连续的<code>redo log block</code>，日志缓冲区是<strong>顺序写入</strong>的，先写前面的block，写满后继续写下一个。log buffer 中有一个指针 buf_free，来标识该位置之前都是填满的 block，该位置之后都是空闲区域。</p><p>InnoDB 引擎会在适当的时候，把内存中 redo 日志缓冲区 持久化到磁盘，具体的<strong>刷盘策略</strong>：</p><ul><li>在事务提交时需要进行刷盘，通过修改参数 <code>innodb_flush_log_at_trx_commit</code> 设置：<ul><li>0：表示当提交事务时，并不将缓冲区的 redo 日志写入磁盘，而是等待<strong>后台线程每秒刷新一次</strong></li><li>1：在事务提交时将缓冲区的 redo 日志<strong>同步写入</strong>到磁盘，保证一定会写入成功（默认值）</li><li>2：在事务提交时将缓冲区的 redo 日志异步写入到磁盘，不能保证提交时肯定会写入，只是有这个动作。日志已经在操作系统的缓存，如果操作系统没有宕机而 MySQL 宕机，也是可以恢复数据的</li></ul></li><li>写入 redo log buffer 的日志超过了总容量的一半，就会将日志刷入到磁盘文件，这会影响执行效率，所以开发中应<strong>避免大事务</strong></li><li>服务器关闭时</li><li>并行的事务提交（组提交）时，会将将其他事务的 redo log 持久化到磁盘。假设事务 A 已经写入 redo log  buffer 中，这时另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么事务 B 要把 redo log buffer 里的日志全部持久化到磁盘，<strong>因为多个事务共用一个 redo log buffer</strong>，所以一次 fsync 可以刷盘多个事务的 redo log，提升了并发量。</li></ul><p>服务器启动后 redo 日志文件的磁盘空间不变，所以磁盘中的日志文件是被<strong>循环使用</strong>的，采用循环写数据的方式，写完尾部重新写头部，并且也是顺序IO，比随机IO快。</p><hr><h3 id="4-讲解undo-log"><a href="#4-讲解undo-log" class="headerlink" title="4.讲解undo log"></a>4.讲解undo log</h3><p>undo log 用于保证事务原子性和隔离性，当事务对数据库进行修改时，InnoDB 会先记录对应的 undo log，如果事务执行失败或调用了 rollback 导致事务回滚，InnoDB 会根据 undo log 的内容<strong>做与之前相反的操作</strong>：</p><ul><li><p>对于每个 insert，回滚时会执行 delete</p></li><li><p>对于每个 delete，回滚时会执行 insert</p></li><li><p>对于每个 update，回滚时会执行一个相反的 update，把数据修改回去</p></li></ul><p>在对一个数据行修改前，会把这个数据行的隐藏列<strong>trx_id</strong>和<strong>roll_pointer</strong>的旧值写到undo log对应的属性中，这样当前记录的roll_pointer会指向当前undo_log的记录，当前undo_log的记录的roll_pointer会指向旧的 undo log 记录，<strong>形成一个版本链</strong>。</p><hr><h3 id="5-讲解bin-log"><a href="#5-讲解bin-log" class="headerlink" title="5.讲解bin log"></a>5.讲解bin log</h3><p>binlog（二进制日志）也可以记录写操作并用于数据的恢复，<strong>保证数据不丢失</strong>。</p><p>MySQL的Binlog有三种录入格式，分别是Statement格式、Row格式和Mixed格式。它们的主要区别如下:</p><ul><li><strong>Statement格式</strong>：将SQL语句本身记录到Binlog中。记录的是在主库上执行的SQL语句，从库通过解析并执行相同的SQL来达到复制的目的。简单、易读，节省存储空间。但是，在某些情况下，由于执行计划或函数等因素的影响，相同的SQL语句在主从库上执行结果可能不一致，导致复制错误。（SQL语句以二进制编码的形式写入binlog）</li><li><strong>Row格式</strong>：记录被修改的每一行数据的变化。不记录具体的SQL语句，而是记录每行数据的变动情况，如插入、删除、更新操作前后的值。保证了复制的准确性，不受SQL语句执行结果的差异影响，适用于任何情况。但是，相比Statement格式，Row格式会占用更多的存储空间。</li><li><strong>Mixed格式</strong>：Statement格式和Row格式的结合，MySQL自动选择适合的格式，大多数情况下使用Statement格式进行记录，但对于无法保证安全复制的情况，如使用非确定性函数、存储过程等，会自动切换到Row格式进行记录。结合了两种格式的优势，既减少了存储空间的占用，又保证了复制的准确性。</li></ul><p><strong>小结：</strong></p><ul><li>Statement格式适用于简单的SQL语句，对存储空间要求较高</li><li>Row格式适用于需要精确复制的场景</li><li>Mixed格式是综合考虑两种格式的优势而出现的折中方案。</li></ul><hr><h3 id="6-redolog和binlog对比"><a href="#6-redolog和binlog对比" class="headerlink" title="6.redolog和binlog对比"></a>6.redolog和binlog对比</h3><ul><li>作用不同：redo log 是用于 crash recovery （故障恢复），保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制</li><li>层次不同：redo log 是 InnoDB 存储引擎实现的，而 binlog 是MySQL的 Server 层实现的，同时支持 InnoDB 和其他存储引擎</li><li>内容不同：redo log 是物理日志，内容基于磁盘的 Page；binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于SQL 语句、基于数据本身或者二者的混合（日志部分详解）</li><li>写入时机不同：binlog 在事务提交时一次写入；redo log 的写入时机相对多元</li></ul><p>binlog 为什么不支持崩溃恢复？</p><ul><li>binlog 记录的是语句，并不记录数据页级的数据（哪个页改了哪些地方），所以没有能力恢复数据页</li><li>binlog 是追加写，保存全量的日志，没有标志确定从哪个点开始的数据是已经刷盘了，而 redo log 只要在 checkpoint_lsn 后面的就是没有刷盘的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redo log </tag>
            
            <tag> bin log </tag>
            
            <tag> undo log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用设计模式</title>
      <link href="/2024/03/15/chang-yong-she-ji-mo-shi-shang/"/>
      <url>/2024/03/15/chang-yong-she-ji-mo-shi-shang/</url>
      
        <content type="html"><![CDATA[<h3 id="1-设计模式的六大原则"><a href="#1-设计模式的六大原则" class="headerlink" title="1.设计模式的六大原则"></a>1.设计模式的六大原则</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>一个类，应当只有一个引起它变化的原因；即一个类应该只有一个职责。</p><p>就一个类而言，应该只专注于做一件事和仅有一个引起变化的原因，这就是所谓的单一职责原则。该原则提出了对对象职责的一种理想期望，对象不应该承担太多职责，正如人不应该一心分为二用。唯有专注，才能保证对象的高内聚；唯有单一，才能保证对象的细粒度。对象的高内聚与细粒度有利于对象的重用。一个庞大的对象承担了太多的职责，当客户端需要该对象的某一个职责时，就不得不将所有的职责都包含进来，从而造成冗余代码。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>在面向对象的语言中，继承是必不可少的、优秀的语言机制，它主要有以下几个优点：</p><ul><li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</li><li>提高代码的可重用性；</li><li>提高代码的可扩展性；</li><li>提高产品或项目的开放性。</li></ul><p>相应的，继承也存在缺点，主要体现在以下几个方面：</p><ul><li>继承是入侵式的。只要继承，就必须拥有父类的所有属性和方法；</li><li>降低代码的灵活性。子类必须拥有父类的属性和方法，使子类受到限制；</li><li>增强了耦合性。当父类的常量、变量和方法修改时，必须考虑子类的修改，这种修改可能造成大片的代码需要重构。</li></ul><p>从整体上看，继承的“利”大于“弊”，然而如何让继承中“利”的因素发挥最大作用，同时减少“弊”所带来的麻烦，这就需要引入“里氏替换原则”。里氏替换原则的定义有以下两种：</p><ul><li>如果对一个类型为S的对象o1，都有类型为T的对象o2，使得以S定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T是类型S的子类型。</li><li>所有引用基类的地方必须能透明地使用其子类对象。清晰明确地说明只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类；但是反过来则不可以，有子类的地方，父类未必就能适应。</li></ul><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>依赖倒置原则包括三种含义：</p><ul><li>高层模块不应该依赖低层模块，两者都依赖其抽象；</li><li>抽象不依赖细节；</li><li>细节应该依赖于抽象。</li></ul><p>传统的过程性系统的设计办法倾向于高层次的模块依赖于低层次的模块；抽象层次依赖于具体层次。“倒置”原则将这个错误的依赖关系倒置了过来，如下图所示，由此命名为“依赖倒置原则”。</p><p>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是具体的实现类，实现类实现了接口或继承了抽象类，其特点是可以直接被实例化。依赖倒置原则在Java语言中的表现是：</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生；</li><li>接口或抽象类不依赖于实现类；</li><li>实现类依赖于接口或抽象类。</li></ul><p>依赖倒置原则更加精确的定义就是“面向接口编程”——OOD（Object-Oriented Design）的精髓之一。依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。依赖倒置原则是JavaBean、EJB和COM等组件设计模型背后的基本原则。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>接口隔离原则有如下两种定义：</p><ol><li>客户端不应该依赖它不需要的接口。</li><li>类间的依赖关系应该建立在最小的接口上。</li></ol><p>接口隔离原则的具体含义如下：</p><ul><li>一个类对另外一个类的依赖性应当是建立在最小的接口上的。</li><li>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。因此使用多个专门的接口比使用单一的总接口要好。</li><li>不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构，即不要强迫客户使用它们不用的方法，否则这些客户就会面临由于这些不使用的方法的改变所带来的改变。</li></ul><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>迪米特法则又叫最少知识原则，意思是一个对象应当对其他对象尽可能少的了解。迪米特法则不同于其他的OO设计原则，它具有很多种表述方式，其中具有代表性的是以下几种表述：</p><ul><li>只与你直接的朋友们通信；</li><li>不要跟“陌生人”说话；</li><li>每一个软件单位对其他的单位都只有最少的了解，这些了解仅局限于那些与本单位密切相关的软件单位。</li></ul><p>按照迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。</p><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>开闭原则的定义是：一个软件实体应当对扩展开放，对修改关闭。这个原则说的是，在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即应当可以在不必修改源代码的情况下改变这个模块的行为。</p><p>在面向对象的编程中，开闭原则是最基础的原则，起到总的指导作用，其他原则（单一职责、里氏替换、依赖倒置、接口隔离、迪米特法则）都是开闭原则的具体形态，即其他原则都是开闭原则的手段和工具。开闭原则的重要性可以通过以下几个方面来体现。</p><ul><li>开闭原则提高复用性。在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑，代码粒度越小，被复用的可能性就越大，避免相同的逻辑重复增加。开闭原则的设计保证系统是一个在高层次上实现了复用的系统。</li><li>开闭原则提高可维护性。一个软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能对程序进行扩展，就是扩展一个类，而不是修改一个类。开闭原则对已有软件模块，特别是最重要的抽象层模块要求不能再修改，这就使变化中的软件系统有一定的稳定性和延续性，便于系统的维护。</li><li>开闭原则提高灵活性。所有的软件系统都有一个共同的性质，即对系统的需求都会随时间的推移而发生变化。在软件系统面临新的需求时，系统的设计必须是稳定的。开闭原则可以通过扩展已有的软件系统，提供新的行为，能快速应对变化，以满足对软件新的需求，使变化中的软件系统有一定的适应性和灵活性。</li><li>开闭原则易于测试。测试是软件开发过程中必不可少的一个环节。测试代码不仅要保证逻辑的正确性，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码”（Poisonous Code），因此当有变化提出时，原有健壮的代码要尽量不修改，而是通过扩展来实现。否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试，甚至是验收测试。开闭原则的使用，保证软件是通过扩展来实现业务逻辑的变化，而不是修改。因此，对于新增加的类，只需新增相应的测试类，编写对应的测试方法，只要保证新增的类是正确的就可以了。</li></ul><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建</p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费。</p><ul><li><p>静态变量的方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 私有构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 在成员位置创建该类的对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 解决序列化问题</span>    <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p></li><li><p>防止反序列化破坏单例的方式：</p><ul><li><p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p><p>条件：访问权限为 private&#x2F;protected、返回值必须是 Object、异常可以不抛</p></li><li><p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p></li></ul></li><li><p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p></li><li><p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p></li><li><p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p></li></ul></li><li><p>静态代码块的方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 私有构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 在成员位置创建该类的对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doSomething"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li><li>问题2：枚举单例在创建时是否有并发问题？否</li><li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li><li>问题4：枚举单例能否被反序列化破坏单例？否</li><li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li><li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li></ul><p>反编译结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Enum</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Singleton</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span> <span class="token comment">// Enum实现序列化接口</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li><p>线程不安全</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 私有构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 在成员位置创建该类的对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>    <span class="token comment">// 对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 多线程环境，会出现线程安全问题，可能多个线程同时进入这里</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双端检锁机制</p><p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 私有构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>    <span class="token comment">// 对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 抢到锁之后再次判断是否为null</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>静态内部类方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 私有构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p><p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p></li><li><p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p></li></ul></li></ul><h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a>3.代理模式</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p><p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li></ul><p>买票案例，火车站是目标对象，代售点是代理对象</p><ul><li><p>卖票接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>火车站，具有卖票功能，需要实现SellTickets接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TrainStation</span> <span class="token keyword">implements</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"火车站卖票"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>代售点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyPoint</span> <span class="token keyword">implements</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">TrainStation</span> station <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrainStation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理点收取一些服务费用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        station<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ProxyPoint</span> pp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pp<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p></li></ul><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p><p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p><ul><li><p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p></li><li><p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p></li><li><p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p></li></ul><p>代码实现：</p><ul><li><p>代理工厂：创建代理对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">TrainStation</span> station <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrainStation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//也可以在参数中提供 getProxyObject(TrainStation station)</span>    <span class="token keyword">public</span> <span class="token class-name">SellTickets</span> <span class="token function">getProxyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//使用 Proxy 获取代理对象</span>        <span class="token class-name">SellTickets</span> sellTickets <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SellTickets</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>            station<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                station<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理点(JDK动态代理方式)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//执行真实对象</span>                        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>station<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> result<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sellTickets<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取代理对象</span>        <span class="token class-name">ProxyFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//必须时代理ji</span>        <span class="token class-name">SellTickets</span> proxyObject <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getProxyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyObject<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>JDK 动态代理方式的优缺点：</p><ul><li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li><li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li><li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li></ul><p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p><ul><li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li><li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li><li>代理类（$Proxy0）的修饰符是 public final</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 程序运行过程中动态生成的代理类</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> $<span class="token class-name">Proxy0</span> <span class="token keyword">extends</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m3<span class="token punctuation">;</span>    <span class="token keyword">public</span> $<span class="token class-name">Proxy0</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> invocationHandler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>invocationHandler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//InvocationHandler对象传递给父类</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        m3 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"proxy.dynamic.jdk.SellTickets"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"sell"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 调用InvocationHandler的invoke方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m3<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Java提供的动态代理相关类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span><span class="token keyword">protected</span> <span class="token class-name">InvocationHandler</span> h<span class="token punctuation">;</span> <span class="token keyword">protected</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>h <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell() 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li></ol><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>                                      <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span>                                      <span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// InvocationHandler 为空则抛出异常</span>    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复制一份 interfaces</span>    <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> intfs <span class="token operator">=</span> interfaces<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">SecurityManager</span> sm <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkProxyAccess</span><span class="token punctuation">(</span><span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 从缓存中查找 class 类型的代理对象，会调用 ProxyClassFactory#apply 方法</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cl <span class="token operator">=</span> <span class="token function">getProxyClass0</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> intfs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//proxyClassCache = new WeakCache&lt;>(new KeyFactory(), new ProxyClassFactory())</span>     <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">checkNewProxyPermission</span><span class="token punctuation">(</span><span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 获取代理类的构造方法，根据参数 InvocationHandler 匹配获取某个构造器</span>        <span class="token keyword">final</span> <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cons <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>constructorParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">InvocationHandler</span> ih <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token comment">// 构造方法不是 pubic 的需要启用权限，暴力p</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 设置可访问的权限</span>                    cons<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>       <span class="token comment">// cons 是构造方法，并且内部持有 InvocationHandler，在 InvocationHandler 中持有 target 目标对象</span>        <span class="token keyword">return</span> cons<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>h<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span><span class="token operator">|</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Proxy 的静态内部类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClassFactory</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 代理类型的名称前缀</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> proxyClassNamePrefix <span class="token operator">=</span> <span class="token string">"$Proxy"</span><span class="token punctuation">;</span>    <span class="token comment">// 生成唯一数字使用，结合上面的代理类型名称前缀一起生成</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> nextUniqueNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数一：Proxy.newInstance 时传递的</span>    <span class="token comment">//参数二：Proxy.newInstance 时传递的接口集合</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">></span></span> interfaceSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdentityHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>interfaces<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历接口集合</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> intf <span class="token operator">:</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> interfaceClass <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 加载接口类到 JVM</span>                interfaceClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>intf<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaceClass <span class="token operator">!=</span> intf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                    intf <span class="token operator">+</span> <span class="token string">" is not visible from class loader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 如果 interfaceClass 不是接口 直接报错，保证集合内都是接口</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>interfaceClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                    interfaceClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" is not an interface"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 保证接口 interfaces 集合中没有重复的接口</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>interfaceSet<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>interfaceClass<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                    <span class="token string">"repeated interface: "</span> <span class="token operator">+</span> interfaceClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 生成的代理类的包名</span>        <span class="token class-name">String</span> proxyPkg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>           <span class="token comment">// 【生成的代理类访问修饰符 public final】 </span>        <span class="token keyword">int</span> accessFlags <span class="token operator">=</span> <span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token constant">PUBLIC</span> <span class="token operator">|</span> <span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token constant">FINAL</span><span class="token punctuation">;</span>        <span class="token comment">// 检查接口集合内的接口，看看有没有某个接口的访问修饰符不是 public 的  如果不是 public 的接口，</span>        <span class="token comment">// 生成的代理类 class 就必须和它在一个包下，否则访问出现问题</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> intf <span class="token operator">:</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 获取访问修饰符</span>            <span class="token keyword">int</span> flags <span class="token operator">=</span> intf<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                accessFlags <span class="token operator">=</span> <span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token constant">FINAL</span><span class="token punctuation">;</span>                <span class="token comment">// 获取当前接口的全限定名 包名.类名</span>                <span class="token class-name">String</span> name <span class="token operator">=</span> intf<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> n <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获取包名</span>                <span class="token class-name">String</span> pkg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>proxyPkg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    proxyPkg <span class="token operator">=</span> pkg<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pkg<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>proxyPkg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                        <span class="token string">"non-public interfaces from different packages"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>proxyPkg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// if no non-public proxy interfaces, use com.sun.proxy package</span>            proxyPkg <span class="token operator">=</span> <span class="token class-name">ReflectUtil</span><span class="token punctuation">.</span><span class="token constant">PROXY_PACKAGE</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 获取唯一的编号</span>        <span class="token keyword">long</span> num <span class="token operator">=</span> nextUniqueNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 包名+ $proxy + 数字，比如 $proxy1</span>        <span class="token class-name">String</span> proxyName <span class="token operator">=</span> proxyPkg <span class="token operator">+</span> proxyClassNamePrefix <span class="token operator">+</span> num<span class="token punctuation">;</span>        <span class="token comment">// 【生成二进制字节码，这个字节码写入到文件内】，就是编译好的 class 文件</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> proxyClassFile <span class="token operator">=</span> <span class="token class-name">ProxyGenerator</span><span class="token punctuation">.</span><span class="token function">generateProxyClass</span><span class="token punctuation">(</span>proxyName<span class="token punctuation">,</span> interfaces<span class="token punctuation">,</span> accessFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 【使用加载器加载二进制到 jvm】，并且返回 class</span>            <span class="token keyword">return</span> <span class="token function">defineClass0</span><span class="token punctuation">(</span>loader<span class="token punctuation">,</span> proxyName<span class="token punctuation">,</span> proxyClassFile<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> proxyClassFile<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassFormatError</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p><ul><li><p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>代理工厂类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">TrainStation</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrainStation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">TrainStation</span> <span class="token function">getProxyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span>        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置父类的字节码对象</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置回调函数</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理点收取一些服务费用(CGLIB动态代理方式)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//因为返回值为void</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建代理对象</span>        <span class="token class-name">TrainStation</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TrainStation</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>CGLIB 的优缺点</p><ul><li>优点：<ul><li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li><li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li><li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li></ul></li><li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li></ul><h4 id="方式对比"><a href="#方式对比" class="headerlink" title="方式对比"></a>方式对比</h4><p>三种方式对比：</p><ul><li><p>动态代理和静态代理：</p><ul><li><p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p></li><li><p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p></li><li><p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p></li></ul></li><li><p>JDK 代理和 CGLIB 代理：</p><p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p></li></ul><p>代理模式的优缺点：</p><ul><li><p>优点：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul></li><li><p>缺点：增加了系统的复杂度</p></li></ul><p>代理模式的使用场景：</p><ul><li><p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p></li><li><p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul><h3 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4.工厂模式"></a>4.工厂模式</h3><p>工厂模式的用意是定义一个创建产品对象的工厂接口，将实际创建性工作推迟到子类中。工厂模式可分为<strong>简单工厂</strong>、<strong>工厂方法</strong>和<strong>抽象工厂</strong>模式。注意，我们常说的23种经典设计模式，包含了工厂方法模式和抽象工厂模式，而并未包含简单工厂模式。另外，我们平时说的工厂模式，一般默认是指工厂方法模式。</p><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>简单工厂模式其实并不算是一种设计模式，更多的时候是一种编程习惯。简单工厂的实现思路是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。简单工厂的适用场景是：</p><ul><li>需要创建的对象较少。</li><li>客户端不关心对象的创建过程。</li></ul><p>简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><p>示例：</p><p>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图，不看代码先考虑一下如何通过该模式设计完成此功能。</p><p>由题可知圆形，正方形，三角形都属于一种图形，并且都具有draw方法，所以首先可以定义一个接口或者抽象类，作为这三个图像的公共父类，并在其中声明一个公共的draw方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面就是编写具体的图形，每种图形都实现Shape接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//  圆形</span><span class="token keyword">class</span> <span class="token class-name">CircleShape</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">CircleShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CircleShape: created"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"draw: CircleShape"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 正方形 </span><span class="token keyword">class</span> <span class="token class-name">RectShape</span> <span class="token keyword">implements</span> <span class="token class-name">Shape</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RectShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RectShape: created"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"draw: RectShape"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是工厂类的具体实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ShapeFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Shape</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Shape</span> shape <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"circle"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            shape <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CircleShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"rect"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            shape <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RectShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> shape<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为工厂类传入不同的type可以new不同的形状，返回结果为Shape 类型，这个就是简单工厂核心的地方了。</p><p><strong>缺点</strong>：增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p><p>工厂方法的实现思路是，定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><p>我们用工厂方法的设计模式改造上面的代码</p><p>定义一个抽象工厂接口ShapeFactory：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ShapeFactory</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Shape</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>里面有一个方法返回产品，下面是具体工厂</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Circle工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircleShapeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ShapeFactory</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Shape</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CircleShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 圆形工厂</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircleShapeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ShapeFactory</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Shape</span> <span class="token function">getShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CircleShape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和简单工厂对比一下，最根本的区别在于，简单工厂只有一个统一的工厂类，而工厂方法是针对每个要创建的对象都会提供一个工厂类，这些工厂类都实现了一个工厂基类。</p><p>下面总结一下工厂方法的适用场景：</p><ul><li>客户端不需要知道它所创建的对象的类。</li><li>客户端可以通过子类来指定创建对应的对象。</li></ul><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。</p><p>抽象工厂的实现思路是，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂和工厂方法一样可以划分为4大部分。</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><p>示例：</p><p>现在需要做一款跨平台的游戏，需要兼容Android，Ios，Wp三个移动操作系统，该游戏针对每个系统都设计了一套操作控制器（OperationController）和界面控制器（UIController），下面通过抽象工厂方式完成这款游戏的架构设计。</p><p>由题可知，游戏里边的各个平台的UIController和OperationController应该是我们最终生产的具体产品。所以新建两个抽象产品接口。</p><p>抽象操作控制器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">OperationController</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">control</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>抽象界面控制器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">UIController</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后完成各个系统平台的具体操作控制器和界面控制器。</p><p>Android：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AndroidOperationController</span> <span class="token keyword">implements</span> <span class="token class-name">OperationController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">control</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AndroidOperationController"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">AndroidUIController</span> <span class="token keyword">implements</span> <span class="token class-name">UIController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AndroidInterfaceController"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IOS：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">IosOperationController</span> <span class="token keyword">implements</span> <span class="token class-name">OperationController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">control</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"IosOperationController"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">IosUIController</span> <span class="token keyword">implements</span> <span class="token class-name">UIController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"IosInterfaceController"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WP：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">WpOperationController</span> <span class="token keyword">implements</span> <span class="token class-name">OperationController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">control</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"WpOperationController"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">WpUIController</span> <span class="token keyword">implements</span> <span class="token class-name">UIController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"WpInterfaceController"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面定义一个抽象工厂，该工厂需要可以创建OperationController和UIController。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SystemFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">OperationController</span> <span class="token function">createOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">UIController</span> <span class="token function">createInterfaceController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在各平台具体的工厂类中完成操作控制器和界面控制器的创建过程。</p><p>Android：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AndroidFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SystemFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">OperationController</span> <span class="token function">createOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AndroidOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">UIController</span> <span class="token function">createInterfaceController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AndroidUIController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IOS：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IosFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SystemFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">OperationController</span> <span class="token function">createOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IosOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">UIController</span> <span class="token function">createInterfaceController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IosUIController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WP：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WpFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SystemFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">OperationController</span> <span class="token function">createOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WpOperationController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">UIController</span> <span class="token function">createInterfaceController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WpUIController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis高频面试题</title>
      <link href="/2024/03/13/redis-gao-pin-mian-shi-ti/"/>
      <url>/2024/03/13/redis-gao-pin-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-说一说Redis的持久化机制"><a href="#1-说一说Redis的持久化机制" class="headerlink" title="1.说一说Redis的持久化机制"></a>1.说一说Redis的持久化机制</h3><p>Redis主要是RDB持久化、AOF持久化这两种持久化方式。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB(Redis Database)是Redis默认采用的持久化方式，它以快照的形式将内存数据持久化到硬盘中。RDB会创建一个经过压缩的二进制文件，文件以“.rdb”结尾。RDB持久化的触发方式有两种：</p><ul><li>手动触发：通过SAVE或BGSAVE命令触发RDB持久化操作，创建“.rdb”文件；</li><li>自动触发：通过修改redis.conf配置文件，让服务器在满足指定条件时自动执行BGSAVE命令。</li></ul><p>其中，SAVE命令执行期间，Redis服务器将阻塞，直到“.rdb”文件创建完毕为止，线上环境不建议使用。</p><p>而BGSAVE命令是异步版本的SAVE命令，它会fork出子进程来创建创建“.rdb”文件，在创建rdb文件期间父进程可以继续响应客户端发来的命令。</p><p>工作原理：</p><img src="/2024/03/13/redis-gao-pin-mian-shi-ti/Redis-bgsave%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" style="zoom:67%;"><p>流程：客户端发出 BGSAVE 指令，若父进程发现有正在执行的子进程就直接返回；没有的话使用 fork 函数创建一个子进程，fork操作时父进程进入阻塞状态；fork操作完成后父进程继续响应其他命令；子进程会创建rdb文件，将父进程内存中的数据写入rdb文件中；创建完成后，父进程得到通知，将新文件替换旧的rdb文件。</p><p>子进程在读取数据的时候，父进程还可以修改数据，怎么解决这种并发问题呢？</p><p>主要用到的是写时复制(Copy On Write)技术，在Linux中，fork函数创建的子进程和父进程共享内存空间，内存中的数据都是一页一页的，当父进程需要修改内存中的数据时会将对应的page进行复制，然后对副本进行修改。</p><img src="/2024/03/13/redis-gao-pin-mian-shi-ti/Snipaste_2024-03-13_21-44-22.png" style="zoom:60%;"><blockquote><p>BGSAVE 命令是针对 SAVE 阻塞问题做的优化，Redis 内部所有涉及到 RDB 操作都采用 BGSAVE 的方式，SAVE 命令放弃使用</p></blockquote><p>RDB持久化的优缺点如下：</p><ul><li><p>优点：RDB生成紧凑压缩的二进制文件，体积小，使用该文件恢复数据的速度非常快；</p></li><li><p>缺点：BGSAVE每次运行都要执行fork操作创建子进程，属于重量级操作，不宜频繁执行，</p><p>所以RDB持久化没办法做到实时的持久化。</p></li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF（Append Only File），解决了数据持久化的实时性，以日志的形式，每执行一条写命令，就把该命令追加写入到一个文件里；重启时再重新执行AOF文件中的命令来恢复数据。AOF的工作流程包括：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。</p><img src="/2024/03/13/redis-gao-pin-mian-shi-ti/Snipaste_2024-03-13_21-50-37.png" style="zoom:67%;"><p>AOF默认不开启，需要修改配置项来启用它：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly <span class="token function">yes</span>         <span class="token comment"># 启用AOF appendfilename "appendonly.aof"  # 设置文件名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>AOF以文本协议格式写入命令，如：</p><pre class="line-numbers language-none"><code class="language-none">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>AOF持久化的文件同步机制：</p><p>为了提高程序的写入性能，现代操作系统会把针对硬盘的多次写操作优化为一次写操作。</p><ol><li>当程序调用write对文件写入时，系统不会直接把书记写入硬盘，而是先将数据写入内存的缓冲区中；</li><li>当达到特定的时间周期或缓冲区写满时，系统才会执行flush操作，将缓冲区中的数据刷到磁盘中；</li></ol><p>这种优化机制虽然提高了性能，但也给程序的写入操作带来了不确定性。</p><ol><li>对于AOF这样的持久化功能来说，冲洗机制将直接影响AOF持久化的安全性；</li><li>为了消除上述机制的不确定性，Redis向用户提供了appendfsync选项，来控制系统冲洗AOF的频率；</li><li>Linux的glibc提供了fsync函数，可以将指定文件强制从缓冲区刷到硬盘，上述选项正是基于此函数。</li></ol><p>appendfsync选项的取值和含义如下：</p><table><thead><tr><th align="center">取值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">每执行一个写入命令，，就缓冲区的数据刷入到磁盘中，这种情况下服务器突然宕机最多丢失一个命令，但是这样redis服务器性能很差，不如直接使用mysql这种基于磁盘的数据库。</td></tr><tr><td align="center">everysec</td><td align="center">每隔1秒就将缓冲区中的数据刷入磁盘中，这种情况下服务器最多丢失1秒之内的命令</td></tr><tr><td align="center">no</td><td align="center">Redis不 控制写回磁盘的时机，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</td></tr></tbody></table><p>AOF持久化的优缺点如下：</p><ul><li>优点：与RDB持久化可能丢失大量的数据相比，AOF持久化的安全性要高很多。通过使用everysec选项，用户可以将数据丢失的时间窗口限制在1秒之内。</li><li>缺点：AOF文件存储的是协议文本，它的体积要比二进制格式的”.rdb”文件大很多。AOF需要通过执行AOF文件中的命令来恢复数据库，其恢复速度比RDB慢很多。AOF在进行重写时也需要创建子进程，在数据库体积较大时将占用大量资源，会导致服务器的短暂阻塞。</li></ul><h3 id="2-说一说Redis的缓存淘汰策略"><a href="#2-说一说Redis的缓存淘汰策略" class="headerlink" title="2.说一说Redis的缓存淘汰策略"></a>2.说一说Redis的缓存淘汰策略</h3><p>当写入数据将导致超出maxmemory限制时，Redis有以下8种淘汰策略：</p><table><thead><tr><th align="center">策略</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">noevication</td><td align="center">直接返回错误；</td></tr><tr><td align="center">volatile-ttl</td><td align="center">从设置了过期时间的键中，选择过期时间最小的键，进行淘汰；</td></tr><tr><td align="center">volatile-random</td><td align="center">从设置了过期时间的键中，随机选择键，进行淘汰；</td></tr><tr><td align="center">volatile-lru</td><td align="center">从设置了过期时间的键中，使用LRU算法选择键，进行淘汰；</td></tr><tr><td align="center">volatile-lfu</td><td align="center">从设置了过期时间的键中，使用LFU算法选择键，进行淘汰；</td></tr><tr><td align="center">allleys-random</td><td align="center">从所有的键中，随机选择键，进行淘汰；</td></tr><tr><td align="center">allkeys-lru</td><td align="center">从所有的键中，使用LRU算法选择键，进行淘汰；</td></tr><tr><td align="center">allkeys-lfu</td><td align="center">从所有的键中，使用LFU算法选择键，进行淘汰；</td></tr></tbody></table><blockquote><p>记两类就可以了，其中，volatile前缀代表从设置了过期时间的键中淘汰数据，allkeys前缀代表从所有的键中淘汰数据。</p></blockquote><p>LRU（Least Recently Used）是按照最近最少使用原则来筛选数据，即最不常用的数据会被筛选出来！</p><ul><li>标准LRU：把所有的数据组成一个链表，表头和表尾分别表示MRU和LRU端，即最常使用端和最少使用端。刚被访问的数据会被移动到MRU端，而新增的数据也是刚被访问的数据，也会被移动到MRU端。当链表的空间被占满时，它会删除LRU端的数据。</li><li>近似LRU：Redis会记录每个数据的最近一次访问的时间戳（LRU）。Redis执行写入操作时，若发现内存超出maxmemory，就会执行一次近似LRU淘汰算法。近似LRU会随机采样N个key，然后淘汰掉最旧的key，若淘汰后内存依然超出限制，则继续采样淘汰。可以通过maxmemory_samples配置项，设置近似LRU每次采样的数据个数，该配置项的默认值为5。</li></ul><p>LRU算法的不足之处在于，若一个key很少被访问，只是刚刚偶尔被访问了一次，则它就被认为是热点数据，短时间内不会被淘汰。</p><p>LFU算法正式用于解决上述问题，LFU（Least Frequently Used）是Redis4新增的淘汰策略，它根据key的最近访问频率进行淘汰。LFU在LRU的基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用LFU策略淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同，LFU再比较这两个数据的访问时间，把访问时间更早的数据淘汰出内存。</p><h3 id="3-请介绍一下Redis的过期策略"><a href="#3-请介绍一下Redis的过期策略" class="headerlink" title="3.请介绍一下Redis的过期策略"></a>3.请介绍一下Redis的过期策略</h3><p>redis支持如下两种过期策略：</p><ul><li>惰性删除：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。</li><li>定期删除：Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描</li></ul><p>过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：</p><ol><li>从过期字典中随机选择20个key；</li><li>删除这20个key中已过期的key；</li><li>如果已过期key的比例超过25%，则重复步骤1。</li></ol><h3 id="4-Redis是单线程还是多线程的？"><a href="#4-Redis是单线程还是多线程的？" class="headerlink" title="4.Redis是单线程还是多线程的？"></a>4.Redis是单线程还是多线程的？</h3><p>Redis 单线程指的是对读写命令是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会启动后台线程。例如，有执行AOF刷盘的后台线程，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作，Redis 在 6.0 版本之后，采用了多个 I&#x2F;O 线程来处理网络请求<strong>，</strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上。但是对于命令的执行，Redis 仍然使用单线程来处理。</p><h3 id="5-Redis的单线程模型了解吗？"><a href="#5-Redis的单线程模型了解吗？" class="headerlink" title="5.Redis的单线程模型了解吗？"></a>5.Redis的单线程模型了解吗？</h3><p><strong>Redis 基于 Reactor 模式开发了一套高效的事件处理模型</strong>，这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个socket，并根据socket目前执行的任务来为socket关联不同的事件处理器。</li><li>当被监听的socket准备执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><img src="/2024/03/13/redis-gao-pin-mian-shi-ti/e48fcc94f30e32b248c611c5c6b441c.png" style="zoom:60%;"><blockquote><p>既然是单线程，那怎么监听大量的客户端连接呢？</p></blockquote><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显：<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><h3 id="6-Redis大key会有什么问题？怎么解决？"><a href="#6-Redis大key会有什么问题？怎么解决？" class="headerlink" title="6.Redis大key会有什么问题？怎么解决？"></a>6.Redis大key会有什么问题？怎么解决？</h3><p>大 key 会带来以下四种影响：</p><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较小。</li></ul><p>解决方式：</p><ul><li>拆分成多个小key。这是最容易想到的办法，降低单key的大小，读取可以用mget批量读取。</li><li>设置合理的过期时间。为每个key设置过期时间，并设置合理的过期时间，以便在数据失效后自动清理，避免长时间累积的大Key问题。</li><li>启用内存淘汰策略。启用Redis的内存淘汰策略，例如LRU（Least Recently Used，最近最少使用），以便在内存不足时自动淘汰最近最少使用的数据，防止大Key长时间占用内存。</li><li>数据分片。例如使用Redis Cluster将数据分散到多个Redis实例，以减轻单个实例的负担，降低大Key问题的风险。</li><li>删除大key。使用UNLINK命令删除大key，UNLINK命令是DEL命令的异步版本，它可以在后台删除Key，避免阻塞Redis实例。</li></ul><h3 id="7-Redis热key会有什么问题？怎么解决？"><a href="#7-Redis热key会有什么问题？怎么解决？" class="headerlink" title="7.Redis热key会有什么问题？怎么解决？"></a>7.Redis热key会有什么问题？怎么解决？</h3><p>热key会带来的问题：</p><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p><p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p><p>如何解决热key?</p><ul><li>读写分离。主节点处理写请求，从节点处理读请求。</li><li>使用Redis Cluster。将热点数据分散存储在多个Redis节点上</li><li>二级缓存。热key采用二级缓存的方式进行处理，将热key存放一份到JVM本地内存中。</li></ul><h3 id="8-讲讲Redis的事务机制"><a href="#8-讲讲Redis的事务机制" class="headerlink" title="8.讲讲Redis的事务机制"></a>8.讲讲Redis的事务机制</h3><p>Redis提供简单的事务，它不支持回滚，且通常不支持ACID中的D。</p><ul><li>Redis 事务<strong>没有隔离级别</strong>的概念，队列中的命令在事务没有提交之前都不会实际被执行</li><li>Redis 单条命令式保存原子性的，但是事务<strong>不保证原子性</strong>，事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><p>事务执行流程有这么几个命令</p><ol><li>multi：使客户端进入事务模式，此时客户端的所有命令都会按顺序放入一个事务队列中</li><li>exec：执行当前事务，即将事务队列中的命令批量发给客户端</li><li>discard：清空事务队列中已有的命令，并让客户端退出事务模式</li><li>watch：加乐观锁，要求服务器对多个key进行监视，若在执行事务前这些key发生变化，则解决执行本次事务</li></ol><blockquote><p>watch监视机制的实现原理</p></blockquote><p>每个 Redis 数据库都保存着一个 watched_keys 字典，键是某个被 WATCH 监视的数据库键，值则是一个链表，记录了所有监视相应数据库键的客户端：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">&#123;</span><span class="token comment">// 正在被 WATCH 命令监视的键</span>    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所有对数据库进行修改的命令，在执行后都会调用 <code>multi.c/touchWatchKey</code> 函数对 watched_keys 字典进行检查，是否有客户端正在监视刚被命令修改过的数据库键，如果有的话函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标识打开，表示该客户端的事务安全性已经被破坏</p><p>服务器接收到个客户端 EXEC 命令时，会根据这个客户端是否打开了 REDIS_DIRTY_CAS 标识，如果打开了说明客户端提交事务不安全，服务器会拒绝执行。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
            <tag> 线程模型 </tag>
            
            <tag> 淘汰策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码上理解CAS操作</title>
      <link href="/2024/03/04/cong-yuan-ma-shang-li-jie-cas-cao-zuo/"/>
      <url>/2024/03/04/cong-yuan-ma-shang-li-jie-cas-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="1背景"><a href="#1背景" class="headerlink" title="1背景"></a>1背景</h3><p>在高并发的业务场景下，线程安全问题是必须考虑的，在JDK5之前，可以通过synchronized或Lock来保证同步，从而达到线程安全的目的。但synchronized或Lock方案属于互斥锁的方案，比较重量级，加锁、释放锁都会引起性能损耗问题。</p><p>而在某些场景下，我们是可以通过JUC提供的CAS机制实现无锁的解决方案，或者说是它基于类似于乐观锁的方案，来达到非阻塞同步的方式保证线程安全。</p><h3 id="2什么是CAS？"><a href="#2什么是CAS？" class="headerlink" title="2什么是CAS？"></a>2什么是CAS？</h3><p><code>CAS</code>是<code>Compare and Swap</code>的缩写，直译就是<strong>比较并交换</strong>。CAS是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令，这个指令会对内存中的共享数据做原子的读写操作。其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新。</p><p>本质上来讲CAS是一种无锁的解决方案，也是一种基于乐观锁的操作，可以保证在多线程并发中保障共享资源的原子性操作，相对于synchronized或Lock来说，是一种轻量级的实现方案。</p><p>Java中大量使用了CAS机制来实现多线程下数据更新的原子化操作，比如AtomicInteger、CurrentHashMap当中都有CAS的应用。但Java中并没有直接实现CAS，CAS相关的实现是借助<code>C/C++</code>调用CPU指令来实现的，效率很高，但Java代码需通过JNI才能调用。比如，Unsafe类提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p><h3 id="3CAS的基本流程"><a href="#3CAS的基本流程" class="headerlink" title="3CAS的基本流程"></a>3CAS的基本流程</h3><p>下面我们用一张图来了解一下CAS操作的基本流程。</p><p><img src="/2024/03/04/cong-yuan-ma-shang-li-jie-cas-cao-zuo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240426163416.jpg"></p><p>在上图中涉及到三个值的比较和操作：修改之前获取的（待修改）值A，业务逻辑计算的新值B，以及待修改值对应的内存位置的C。</p><p>整个处理流程中，假设内存中存在一个变量i，它在内存中对应的值是A（第一次读取），此时经过业务处理之后，要把它更新成B，那么在更新之前会再读取一下i现在的值C，如果在业务处理的过程中i的值并没有发生变化，也就是A和C相同，才会把i更新（交换）为新值B。如果A和C不相同，那说明在业务计算时，i的值发生了变化，则不更新（交换）成B。最后，CPU会将旧的数值返回。而上述的一系列操作由CPU指令来保证是原子的。</p><p>在《Java并发编程实践》中对CAS进行了更加通俗的描述：我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少。</p><p>在上述路程中，我们可以很清晰的看到乐观锁的思路，而且这期间并没有使用到锁。因此，相对于synchronized等悲观锁的实现，效率要高非常多。</p><h3 id="4基于CAS的AtomicInteger使用"><a href="#4基于CAS的AtomicInteger使用" class="headerlink" title="4基于CAS的AtomicInteger使用"></a>4基于CAS的AtomicInteger使用</h3><p>关于CAS的实现，最经典最常用的当属AtomicInteger了，我们马上就来看一下AtomicInteger是如何利用CAS实现原子性操作的。为了形成更新鲜明的对比，先来看一下如果不使用CAS机制，想实现线程安全我们通常如何处理。</p><p>在没有使用CAS机制时，为了保证线程安全，基于synchronized的实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadSafeTest</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至于上面的实例具体实现，这里不再展开，很多相关的文章专门进行讲解，我们只需要知道为了保证i++的原子操作，在increase方法上使用了重量级的锁synchronized，这会导致该方法的性能低下，所有调用该方法的操作都需要同步等待处理。</p><p>那么，如果采用基于CAS实现的AtomicInteger类，上述方法的实现便变得简单且轻量级了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadSafeTest</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> counter<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之所以可以如此安全、便捷地来实现安全操作，便是由于AtomicInteger类采用了CAS机制。下面，我们就来了解一下AtomicInteger的功能及源码实现。</p><h3 id="5CAS的AtomicInteger类的原理"><a href="#5CAS的AtomicInteger类的原理" class="headerlink" title="5CAS的AtomicInteger类的原理"></a>5CAS的AtomicInteger类的原理</h3><p><code>AtomicInteger</code>是java.util.concurrent.atomic 包下的一个原子类，该包下还有<code>AtomicBoolean</code>, <code>AtomicLong</code>,<code>AtomicLongArray</code>, <code>AtomicReference</code>等原子类，主要用于在高并发环境下，保证线程安全。</p><h4 id="5-1AtomicInteger常用API"><a href="#5-1AtomicInteger常用API" class="headerlink" title="5.1AtomicInteger常用API"></a>5.1AtomicInteger常用API</h4><p>AtomicInteger类提供了如下常见的API功能：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前的值，并设置新的值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前的值，并自增</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前的值，并自减</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前的值，并加上预期的值</span><span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述方法中，getAndXXX格式的方法都实现了原子操作。具体的使用方法参考上面的addAndGet案例即可。</p><h4 id="5-2AtomicInteger核心源码"><a href="#5-2AtomicInteger核心源码" class="headerlink" title="5.2AtomicInteger核心源码"></a>5.2AtomicInteger核心源码</h4><p>下面看一下AtomicInteger代码中的核心实现代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 用于获取value字段相对当前对象的“起始地址”的偏移量</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token comment">//返回当前值</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//递增加detla</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1、this：当前的实例 </span>        <span class="token comment">// 2、valueOffset：value实例变量的偏移量 </span>        <span class="token comment">// 3、delta：当前value要加上的数(value+delta)。</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//递增加1</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码以AtomicInteger#incrementAndGet方法为例展示了AtomicInteger的基本实现。其中，在static静态代码块中，基于Unsafe类获取value字段相对当前对象的“起始地址”的偏移量，用于后续Unsafe类的处理。</p><p>在处理自增的原子操作时，使用的是Unsafe类中的getAndAddInt方法，CAS的实现便是由Unsafe类的该方法提供，从而保证自增操作的原子性。</p><p>同时，在AtomicInteger类中，可以看到value值通过volatile进行修饰，保证了该属性值的线程可见性。在多并发的情况下，一个线程的修改，可以保证到其他线程立马看到修改后的值。</p><p>通过源码可以看出， <code>AtomicInteger</code> 底层是通过<strong>volatile</strong>变量和CAS两者相结合来保证更新数据的原子性。其中关于Unsafe类对CAS的实现，我们下面详细介绍。</p><h3 id="6CAS的工作原理"><a href="#6CAS的工作原理" class="headerlink" title="6CAS的工作原理"></a>6CAS的工作原理</h3><p>CAS的实现原理简单来说就是由<strong>Unsafe类</strong>和其中的<strong>自旋锁</strong>来完成的，下面针对源代码来看一下这两块的内容。</p><h4 id="6-1UnSafe类"><a href="#6-1UnSafe类" class="headerlink" title="6.1UnSafe类"></a>6.1UnSafe类</h4><p>在AtomicInteger核心源码中，已经看到CAS的实现是通过Unsafe类来完成的，先来了解一下Unsafe类的作用。</p><p>sun.misc.Unsafe是JDK内部用的工具类。它通过暴露一些Java意义上说“不安全”的功能给Java层代码，来让JDK能够更多的使用Java代码来实现一些原本是平台相关的、需要使用native语言（例如C或C++）才可以实现的功能。该类不应该在JDK核心类库之外使用，这也是命名为Unsafe（不安全）的原因。</p><p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。</p><p>Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java对象的某个字段。在AtomicInteger的static代码块中便使用了objectFieldOffset()方法。</p><p>Unsafe类的功能主要分为内存操作、CAS、Class相关、对象操作、数组相关、内存屏障、系统相关、线程调度等功能。这里我们只需要知道其功能即可，方便理解CAS的实现，注意不建议在日常开发中使用。</p><h4 id="6-2UnSafe与CAS"><a href="#6-2UnSafe与CAS" class="headerlink" title="6.2UnSafe与CAS"></a>6.2UnSafe与CAS</h4><p>AtomicInteger调用了Unsafe#getAndAddInt方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述代码等于是AtomicInteger调用UnSafe类的CAS方法，JVM帮我们实现出汇编指令，从而实现原子操作。</p><p>在Unsafe中getAndAddInt方法实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> var5<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getAndAddInt方法有三个参数：</p><ul><li>第一个参数表示当前对象，也就是new的那个AtomicInteger对象；</li><li>第二个表示内存地址；</li><li>第三个表示自增步伐，在AtomicInteger#incrementAndGet中默认的自增步伐是1。</li></ul><p>getAndAddInt方法中，首先把当前对象主内存中的值赋给val5，然后进入while循环。判断当前对象此刻主内存中的值是否等于val5，如果是，就自增（交换值），否则继续循环，重新获取val5的值。</p><p>在上述逻辑中核心方法是compareAndSwapInt方法，它是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。</p><p>在getAndAddInt方法中还涉及到一个实现<strong>自旋锁</strong>。所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。</p><p>这里我们可以看到CAS实现的一个缺点：内部使用<strong>自旋</strong>的方式进行<strong>CAS</strong>更新（while循环进行CAS更新，如果更新失败，则循环再次重试）。如果长时间都不成功的话，就会造成CPU极大的开销。</p><h3 id="7CAS的缺点"><a href="#7CAS的缺点" class="headerlink" title="7CAS的缺点"></a>7CAS的缺点</h3><p><code>CAS</code>高效地实现了原子性操作，但在以下三方面还存在着一些缺点：</p><ul><li>循环时间长，开销大；</li><li>只能保证一个共享变量的原子操作；</li><li>ABA问题；</li></ul><p>下面就这个三个问题详细讨论一下。</p><h4 id="7-1循环时间长开销大"><a href="#7-1循环时间长开销大" class="headerlink" title="7.1循环时间长开销大"></a>7.1循环时间长开销大</h4><p>在分析Unsafe源代码的时候我们已经提到，在Unsafe的实现中使用了自旋锁的机制。在该环节如果<code>CAS</code>操作失败，就需要循环进行<code>CAS</code>操作(do while循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升。</p><h4 id="7-2只能保证一个共享变量的原子操作"><a href="#7-2只能保证一个共享变量的原子操作" class="headerlink" title="7.2只能保证一个共享变量的原子操作"></a>7.2只能保证一个共享变量的原子操作</h4><p>在最初的实例中，可以看出是针对一个共享变量使用了CAS机制，可以保证原子性操作。但如果存在多个共享变量，或一整个代码块的逻辑需要保证线程安全，CAS就无法保证原子性操作了，此时就需要考虑采用加锁方式（悲观锁）保证原子性，或者有一个取巧的办法，把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p><h4 id="7-3ABA问题"><a href="#7-3ABA问题" class="headerlink" title="7.3ABA问题"></a>7.3ABA问题</h4><p>虽然使用CAS可以实现非阻塞式的原子性操作，但是会产生ABA问题，ABA问题出现的基本流程：</p><ul><li>进程P1在共享变量中读到值为A；</li><li>P1被抢占了，进程P2执行；</li><li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占；</li><li>P1回来看到共享变量里的值没有被改变，于是继续执行；</li></ul><p>虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。ABA问题最容易发生在lock free的算法中的，CAS首当其冲，因为CAS判断的是指针的地址。如果这个地址被重用了呢，问题就很大了（地址被重用是很经常发生的，一个内存分配后释放了，再分配，很有可能还是原来的地址）。</p><p>ABA问题的解决思路就是使用版本号：在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</p><p>另外，从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>途游-后端实习生一面面经</title>
      <link href="/2024/02/28/tu-you-hou-duan-shi-xi-sheng-yi-mian-mian-jing/"/>
      <url>/2024/02/28/tu-you-hou-duan-shi-xi-sheng-yi-mian-mian-jing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1、谈一谈Java的集合</p></blockquote><p>主要有Collection 和Map两类，Collection接口的实现子类是单列集合，Map的是双列集合。Collection 接口下面有两个子接口，List和Set。List有两个实现类ArrayList和LinkedList。ArrayList的底层实现是动态数组，LinkedList的底层是双向链表。</p><blockquote><p>2、面试官继续问：这两个有什么特点，或者说异同点吗？</p></blockquote><p>ArrayList查找的效率高，因为数组根据下标查找时间复杂度是O(1)，但是插入删除效率低，因为插入时需要把插入位置之后的元素往后挪。LinkedList插入和删除的效率高，但是查找的效率不高，因为它是链表，需要顺着元素一个一个往下找。总结来说一个适合读多写少的场景，另一个适合写多读少的场景。</p><blockquote><p>3、HashMap也讲一下</p></blockquote><p>在JDK1.7中，HashMap的底层实现是数组+链表，以put操作为例说一下原理，首先根据key计算hash值，然后hash值对数组长度取余数，确定它要放的位置，假设是table[i]，如果table[i]是空的，那就直接新增，不为空就顺着链表往下找（table[i]相当于链表表头），如果发现key相同的就更新它，没有相同的就把key，value封装成一个node节点加入到链表后面。这有一个缺点就是在链表过长的时候效率变低，所以在jdk1.8的时候，底层实现是数组+链表+红黑树，当链表长度超过阈值的时候它就变为红黑树。然后HashMap也是线程不安全的，如果要保证线程安全可以使用ConcurrentHashMap。</p><blockquote><p>4、什么情况下会有线程安全问题</p></blockquote><blockquote><p>5、线程和进程有什么区别</p></blockquote><p>本质区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位。</p><p>在开销方面：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器</p><p>稳定性方面：进程中每个线程如果崩溃了，可能导致整个进程崩溃。而一个进程的崩溃不会影响其他进程。</p><p>包含关系来看：没有线程的进程可以看作单线程的，一个线程可以有多个线程。</p><blockquote><p>6、线程之间的通信方式，进程之间的通信方式</p></blockquote><p>线程之间通信：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p><p>进程间的通信比较复杂：</p><ul><li>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</li><li>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</li><li>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong><ul><li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</li><li>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</li></ul></li><li>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：<ul><li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li></ul></li></ul><p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p><ul><li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li></ul><blockquote><p>7、RabbitMQ使用的是哪种通信方式</p></blockquote><blockquote><p>8、堆内存和栈内存，数据结构中的堆和栈。</p></blockquote><blockquote><p>8、讲一下spring的aop</p></blockquote><blockquote><p>9、讲一下java的反射机制，你在项目中使用过反射吗，你看过框架中反射相关的源码吗？</p></blockquote><blockquote><p>10、有一个文件，里面存了1千万个整数，主机的内存只有1.5MB，磁盘没有限制，你要对这1千万个整数排序，你会怎么做？</p></blockquote><blockquote><p>11、讲一下jvm中的垃圾回收机制。</p></blockquote><blockquote><p>12、缓存穿透、缓存雪崩是什么问题，一般怎么解决。</p></blockquote><blockquote><p>13、讲一下MySQL中的索引。事务。你的项目中有使用到事务吗？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句优化的常用技巧</title>
      <link href="/2024/02/19/sql-yu-ju-you-hua-de-chang-yong-ji-qiao/"/>
      <url>/2024/02/19/sql-yu-ju-you-hua-de-chang-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-回顾MySQL的执行过程"><a href="#1-回顾MySQL的执行过程" class="headerlink" title="1.回顾MySQL的执行过程"></a>1.回顾MySQL的执行过程</h3><p>MySQL内部服务组件可以分为<code>server层</code>和<code>存储引擎层</code>，其中跨存储引擎的功能都在server实现，比如触发器、视图等，而存储引擎执行实际的IO操作，数据的存储和提取。</p><blockquote><p>数据库里面,长连接是指连接成功后,如果客户端持续有请求,那么就一直使用同一个连接,短连接则是指每次执行完很少的几次查询就断开连接,下次查询再建立一个</p></blockquote><p><img src="/2024/02/19/sql-yu-ju-you-hua-de-chang-yong-ji-qiao/p_20240317171627.png"></p><ol><li>在<code>mysql8.0</code>以前，执行查询的sql会先经过<code>缓存</code>，查询缓存是否命中,如果缓存命中,那么就会直接返回结果,否则就会走查询流程</li><li>查询流程会先经过<code>分析器</code>,分析器要完成两个事情,第一个事情是做<code>词法分析</code>,第二个事情叫做<code>语法分析</code>，解析器会对语法进行验证和解析，并生成一颗对应的抽象语法树，。例如，验证是否使用了错误的关键字，或者关键字的使用是否正确</li><li>预处理是根据一些MySQL规则检查语法树是否合理，比如检查表和列是否存在，还会解析名字和别名，然后预处理器会验证权限；</li><li>优化器生成执行计划，根据执行计划查询执行引擎，调用API接口调用存储引擎来查询数据；</li><li>最终将数据收集,返回给客户端程序。</li></ol><h3 id="2-SQL语句性能优化常用策略"><a href="#2-SQL语句性能优化常用策略" class="headerlink" title="2.SQL语句性能优化常用策略"></a>2.SQL语句性能优化常用策略</h3><h4 id="1-为-WHERE-及-ORDER-BY-涉及的列上建立索引"><a href="#1-为-WHERE-及-ORDER-BY-涉及的列上建立索引" class="headerlink" title="1.为 WHERE 及 ORDER BY 涉及的列上建立索引"></a>1.为 WHERE 及 ORDER BY 涉及的列上建立索引</h4><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 WHERE 及 ORDER BY 涉及的列上建立索引。</p><h4 id="2-where中使用默认值代替null"><a href="#2-where中使用默认值代替null" class="headerlink" title="2.where中使用默认值代替null"></a>2.where中使用默认值代替null</h4><p>应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，创建表时 NULL 是默认值，但大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。</p><p>原因：如果是用null或者is not null的话可能有时候让索引失效，成本比走索引更高的话就会全表扫描。而换成默认值就更可能走索引</p><h4 id="3-慎用-或-操作符"><a href="#3-慎用-或-操作符" class="headerlink" title="3.慎用 !&#x3D; 或 &lt;&gt; 操作符"></a>3.慎用 !&#x3D; 或 &lt;&gt; 操作符</h4><p>MySQL 只有对以下操作符才使用索引：&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN，以及某些时候的 LIKE。</p><p>所以：应尽量避免在 WHERE 子句中使用 !&#x3D; 或 &lt;&gt; 操作符， 会导致全表扫描。</p><h4 id="4-慎用-OR-来连接条件"><a href="#4-慎用-OR-来连接条件" class="headerlink" title="4.慎用 OR 来连接条件"></a>4.慎用 OR 来连接条件</h4><p>使用or可能会使索引失效，从而全表扫描；</p><p>应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，</p><p>可以使用 UNION 合并查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span><span class="token keyword">union</span> <span class="token keyword">all</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个关键的问题是否用到索引。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用 UNION all 执行的效率更高。多个 OR 的字句没有用到索引，改写成 UNION 的形式再试图与索引匹配。</p><h4 id="5-慎用-IN-和-NOT-IN"><a href="#5-慎用-IN-和-NOT-IN" class="headerlink" title="5.慎用 IN 和 NOT IN"></a>5.慎用 IN 和 NOT IN</h4><p>IN 和 NOT IN 要慎用，否则会导致全表扫描。对于连续的数值，能用 BETWEEN 就不要用 IN：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">3</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-慎用-左模糊like-‘-…’"><a href="#6-慎用-左模糊like-‘-…’" class="headerlink" title="6.慎用 左模糊like ‘%…’"></a>6.慎用 左模糊like ‘%…’</h4><p>模糊查询，程序员最喜欢的就是使用like，like很可能让索引失效。</p><p>比如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span>‘<span class="token operator">%</span>abc<span class="token operator">%</span>’ <span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span>‘<span class="token operator">%</span>abc’ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面两种情况都不会走索引，只有 like ‘abc%’ 才会走索引。</p><p>所以：</p><ul><li>首先尽量避免模糊查询，如果必须使用，不采用全模糊查询，也应尽量采用右模糊查询， 即like ‘…%’，是会使用索引的；</li><li>左模糊like ‘%…’无法直接使用索引，但可以利用reverse + function index的形式，变化成 like ‘…%’；</li><li>全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎，比如 ElasticSearch。</li><li>如果一定要用左模糊like ‘%…’检索， 一般建议 ElasticSearch+Hbase架构。</li></ul><h4 id="7-WHERE条件使用参数会导致全表扫描"><a href="#7-WHERE条件使用参数会导致全表扫描" class="headerlink" title="7.WHERE条件使用参数会导致全表扫描"></a>7.WHERE条件使用参数会导致全表扫描</h4><p>如下面语句将进行全表扫描：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">=</span> <span class="token variable">@num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；</p><p>它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。</p><p>所以， 可以改为强制查询使用索引：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">select id from t <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token function">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> where num<span class="token operator">=</span><span class="token annotation punctuation">@num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-用-EXISTS-代替-IN-是一个好的选择"><a href="#8-用-EXISTS-代替-IN-是一个好的选择" class="headerlink" title="8.用 EXISTS 代替 IN 是一个好的选择"></a>8.用 EXISTS 代替 IN 是一个好的选择</h4><p>很多时候用exists 代替in 是一个好的选择：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> b<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用下面的语句替换：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> num<span class="token operator">=</span>a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="9-索引并不是越多越好"><a href="#9-索引并不是越多越好" class="headerlink" title="9.索引并不是越多越好"></a>9.索引并不是越多越好</h4><p>索引固然可以提高相应的 SELECT 的效率，但同时也降低了 INSERT 及 UPDATE 的效率。因为 INSERT 或 UPDATE 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</p><p>一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><h4 id="10-尽量使用数字型字段"><a href="#10-尽量使用数字型字段" class="headerlink" title="10.尽量使用数字型字段"></a>10.尽量使用数字型字段</h4><ul><li>因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；</li><li>而对于数字型而言只需要比较一次就够了；</li><li>字符会降低查询和连接的性能，并会增加存储开销；</li></ul><p>所以：尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p><h4 id="11-尽可能地使用-varchar-nvarchar-代替-char-nchar"><a href="#11-尽可能地使用-varchar-nvarchar-代替-char-nchar" class="headerlink" title="11.尽可能地使用 varchar, nvarchar 代替 char, nchar"></a>11.尽可能地使用 varchar, nvarchar 代替 char, nchar</h4><ul><li>varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间；</li><li>char按声明大小存储，不足补空格；</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高；</li></ul><p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h4 id="12-查询SQL尽量不要使用select-，而是具体字段"><a href="#12-查询SQL尽量不要使用select-，而是具体字段" class="headerlink" title="12.查询SQL尽量不要使用select *，而是具体字段"></a>12.查询SQL尽量不要使用select *，而是具体字段</h4><p>最好不要使用返回所有：select * from t ，用具体的字段列表代替 “*”，不要返回用不到的任何字段。</p><p>select *的弊端：</p><ul><li>增加很多不必要的消耗，比如CPU、IO、内存、网络带宽；</li><li>增加了使用覆盖索引的可能性；</li><li>增加了回表的可能性；</li></ul><h4 id="13-将需要查询的结果预先计算好"><a href="#13-将需要查询的结果预先计算好" class="headerlink" title="13.将需要查询的结果预先计算好"></a>13.将需要查询的结果预先计算好</h4><p>将需要查询的结果预先计算好放在表中，查询的时候再select，而不是查询的时候进行计算。</p><h4 id="14-IN后出现最频繁的值放在最前面"><a href="#14-IN后出现最频繁的值放在最前面" class="headerlink" title="14.IN后出现最频繁的值放在最前面"></a>14.IN后出现最频繁的值放在最前面</h4><p>如果一定用IN，那么：</p><p>在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p><h4 id="15-尽量使用-EXISTS-代替-select-count-1-来判断是否存在记录"><a href="#15-尽量使用-EXISTS-代替-select-count-1-来判断是否存在记录" class="headerlink" title="15.尽量使用 EXISTS 代替 select count(1) 来判断是否存在记录"></a>15.尽量使用 EXISTS 代替 select count(1) 来判断是否存在记录</h4><p>count 函数只有在统计表中所有行数时使用，而且 count(1) 比 count(*) 更有效率。</p><h4 id="16-用批量插入或批量更新"><a href="#16-用批量插入或批量更新" class="headerlink" title="16.用批量插入或批量更新"></a>16.用批量插入或批量更新</h4><p>当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。</p><p>1.多条插入</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'xx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'yy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.批量提交</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'xx'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'yy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认新增SQL有事务控制，导致每条都需要事务开启和事务提交，而批量处理是一次事务开启和提交，效率提升明显，达到一定量级，效果显著，平时看不出来。</p><h4 id="17-将不需要的记录在-GROUP-BY-之前过滤掉"><a href="#17-将不需要的记录在-GROUP-BY-之前过滤掉" class="headerlink" title="17.将不需要的记录在 GROUP BY 之前过滤掉"></a>17.将不需要的记录在 GROUP BY 之前过滤掉</h4><p>提高 GROUP BY 语句的效率，可以通过将不需要的记录在 GROUP BY 之前过滤掉。</p><p>下面两个查询返回相同结果，但第二个明显就快了许多。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 低效</span><span class="token keyword">SELECT</span> JOB<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> JOB <span class="token keyword">HAVING</span> JOB <span class="token operator">=</span> <span class="token string">'PRESIDENT'</span> <span class="token operator">OR</span> JOB <span class="token operator">=</span> <span class="token string">'MANAGER'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#高效</span><span class="token keyword">SELECT</span> JOB<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> JOB <span class="token operator">=</span> <span class="token string">'PRESIDENT'</span> <span class="token operator">OR</span> JOB <span class="token operator">=</span> <span class="token string">'MANAGER'</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> JOB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="18-避免死锁"><a href="#18-避免死锁" class="headerlink" title="18.避免死锁"></a>18.避免死锁</h4><p>在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应尽可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p><h4 id="19-索引创建规则"><a href="#19-索引创建规则" class="headerlink" title="19.索引创建规则"></a>19.索引创建规则</h4><ol><li>数据量超过 300 的表应该有索引；</li><li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li><li>经常出现在 WHERE 子句中的字段，特别是大表的字段，应该建立索引；</li><li>索引应该建在选择性高的字段上；</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li><li>复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；</li><li>正确选择复合索引中的主列字段，一般是选择性较好的字段；</li><li>复合索引的几个字段是否经常同时以 AND 方式出现在 WHERE 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；</li><li>如果复合索引中包含的字段经常单独出现在 WHERE 子句中，则分解为多个单字段索引；</li><li>如果复合索引所包含的字段超过 3 个，那么仔细考虑其必要性，考虑减少复合的字段；</li><li>如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；</li><li>频繁进行数据操作的表，不要建立太多的索引；</li><li>删除无用的索引，避免对执行计划造成负面影响；</li><li>表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大；</li><li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li></ol><h4 id="20-在写-SQL-语句时，应尽量减少空格的使用"><a href="#20-在写-SQL-语句时，应尽量减少空格的使用" class="headerlink" title="20.在写 SQL 语句时，应尽量减少空格的使用"></a>20.在写 SQL 语句时，应尽量减少空格的使用</h4><p>查询缓冲并不自动处理空格，因此，在写 SQL 语句时，应尽量减少空格的使用，尤其是在 SQL 首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p><h4 id="21-每张表都设置一个-ID-做为其主键"><a href="#21-每张表都设置一个-ID-做为其主键" class="headerlink" title="21.每张表都设置一个 ID 做为其主键"></a>21.每张表都设置一个 ID 做为其主键</h4><p>我们应该为数据库里的每张表都设置一个 ID 作为其主键，而且最好的是一个 INT 型的（推荐使用 UNSIGNED），并设置上自动增加的 AUTO_INCREMENT 标志。</p><h4 id="22-使用explain分析你SQL执行计划"><a href="#22-使用explain分析你SQL执行计划" class="headerlink" title="22.使用explain分析你SQL执行计划"></a>22.使用explain分析你SQL执行计划</h4><table><thead><tr><th align="center">列名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">针对单表的访问方法</td></tr><tr><td align="center">possible_keys</td><td align="center">可能用到的索引</td></tr><tr><td align="center">key</td><td align="center">实际使用的索引</td></tr><tr><td align="center">key_len</td><td align="center">实际使用的索引长度</td></tr><tr><td align="center">ref</td><td align="center">当使用索引列等值查询时，与索引列等值匹配的对象信息</td></tr><tr><td align="center">rows</td><td align="center">预估的需要读取的记录条数</td></tr><tr><td align="center">filtered</td><td align="center">针对rows，经过搜索条件过滤后剩余记录条数百分百</td></tr><tr><td align="center">Extra</td><td align="center">一些额外信息</td></tr></tbody></table><p>（1）type常用值</p><ul><li><p>system：表仅有一条记录，基本用不到；</p></li><li><p>const：在根据主键或者唯一二级索引列进行等值匹配查询时会触发</p></li><li><p>eq_ref：执行连接查询时，被驱动的表是通过主键或者不允许存储NULL值的唯一二级索引序列等值匹配的方式进行访问的。这可能是最好的联接类型，除了const类型；</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> s1 <span class="token keyword">inner</span> <span class="token keyword">join</span> s2 <span class="token keyword">on</span> s1<span class="token punctuation">.</span>id <span class="token operator">=</span> s2<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>ref：当通过普通的二级索引列与常量进行等值匹配的方式来查询某个表时，对该表的访问方式就是ref。</p></li><li><p>range：如果使用索引获取某些单点扫描区间的记录，那么就可能使用到range访问方法，或者用于获取某个或者某些范围扫描区间的记录的查询，例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> s1 <span class="token keyword">where</span> key1 <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> s1 <span class="token keyword">where</span> key1 <span class="token operator">></span> <span class="token string">'a'</span> <span class="token operator">and</span> key1 <span class="token operator">&lt;</span> <span class="token string">'c'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>index：当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index。例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> key_part1 <span class="token keyword">from</span> s1 <span class="token keyword">where</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述查询中(key_part1,key_part2)是联合索引，查询的只有一个列，搜索的也只有一个列，但是只能扫描索引的全部记录</p></li><li><p>all：全表扫描</p></li></ul><p>性能排名：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。实际sql优化中，最后达到ref或range级别。</p><p>（2）Extra常用关键字</p><ul><li>Using index：只从索引树中获取信息，而不需要回表查询；</li><li>Using where：WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不Using where并且表联接类型为ALL或index，查询可能会有一些错误。需要回表查询；</li><li>Using temporary：mysql常建一个临时表来容纳结果，典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。</li></ul><h4 id="23-当只要一行数据时使用-LIMIT-1"><a href="#23-当只要一行数据时使用-LIMIT-1" class="headerlink" title="23.当只要一行数据时使用 LIMIT 1"></a>23.当只要一行数据时使用 LIMIT 1</h4><p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p><p>在这种情况下，加上 LIMIT 1 可以增加性能。</p><p>这样一来，MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据。</p><h4 id="24-将大的DELETE，UPDATE、INSERT-查询变成多个小查询"><a href="#24-将大的DELETE，UPDATE、INSERT-查询变成多个小查询" class="headerlink" title="24.将大的DELETE，UPDATE、INSERT 查询变成多个小查询"></a>24.将大的DELETE，UPDATE、INSERT 查询变成多个小查询</h4><p>能写一个几十行、几百行的SQL语句是不是显得逼格很高？然而，为了达到更好的性能以及更好的数据控制，你可以将他们变成多个小查询。</p><h4 id="25-合理分表，尽量控制单表数据量的大小，建议控制在500万以内"><a href="#25-合理分表，尽量控制单表数据量的大小，建议控制在500万以内" class="headerlink" title="25.合理分表，尽量控制单表数据量的大小，建议控制在500万以内"></a>25.合理分表，尽量控制单表数据量的大小，建议控制在500万以内</h4><p>500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。</p><h4 id="26-无条件删除表中数据时，用truncate代替delete"><a href="#26-无条件删除表中数据时，用truncate代替delete" class="headerlink" title="26.无条件删除表中数据时，用truncate代替delete"></a>26.无条件删除表中数据时，用truncate代替delete</h4><p>delete操作是将表中所有记录<strong>一条一条删除</strong>直到删除完；truncate操作则是保留了表的结构，<strong>重新创建</strong>了这个表。因此<strong>truncate操作的效率更高</strong></p><p>delete操作删除表中记录后，再次向表中添加新记录时，对于设置有自增约束字段的值会从删除前表中该字段的最大值加1开始自增；truncate操作则会重新从1开始自增。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解MySQL中的锁</title>
      <link href="/2024/02/17/shen-ru-li-jie-mysql-zhong-de-suo/"/>
      <url>/2024/02/17/shen-ru-li-jie-mysql-zhong-de-suo/</url>
      
        <content type="html"><![CDATA[<h3 id="1-在MySQL中有哪些锁？"><a href="#1-在MySQL中有哪些锁？" class="headerlink" title="1.在MySQL中有哪些锁？"></a>1.在MySQL中有哪些锁？</h3><p>按粒度分：</p><ul><li>表级锁</li><li>全局锁</li><li>行级锁</li></ul><p>按操作分：</p><ul><li>共享锁</li><li>排他锁</li></ul><p>按使用方式分类：</p><ul><li>乐观锁</li><li>悲观锁</li></ul><p>InnoDB中常用的行级锁有（下文默认的存储引擎为InnoDB）：</p><ul><li>Record Lock：又细分为<strong>共享锁</strong>（Shared Lock，简称S锁），在事务要读取一条记录时，首先需要获取该记录的S锁。<strong>独占锁</strong>（Exclusive Lock，简称X锁），在事务要改动一条记录时，首先需要获取该记录的X锁。总之，它的作用仅仅是把一条记录锁上。</li><li>Gap Lock：又称为<strong>间隙锁</strong>，锁定一个范围, 但是不包含记录本身。在RR的隔离级别下可能会出现幻读的现象。解决的方案有两种：使用MVCC方案解决；使用加锁方案解决。</li><li>Next-Key Lock：锁定一个范围包括记录本身。Record Lock + Gap Lock &#x3D; Next-Key Lock</li></ul><p>常用的表级锁有：</p><ul><li>意向共享锁（Intention Shared Lock)：简称IS锁，当事务准备在某条记录上加S锁时，需要先在表级别加IS锁</li><li>意向独占锁（Intention Exclusive Lock）：简称IX锁，当事务准备在某条记录上加X锁时，需要先在表级别加IX锁</li><li>AUTO-INC锁：为某个列添加AUTO_INCREMENT属性后，在插入记录时，就会添加一个AUTO-INC锁，其他事务的插入语句就会被阻塞。</li><li>元数据锁（Metadata Lock，MDL）</li></ul><p>IS锁，IX锁的提出仅仅是为了在之后加表级别的X锁和S锁时可以快速判断表中的记录是否被上锁，避免用遍历的方式来查看表中有没有上锁的记录。</p><blockquote><p>其实表级别的X锁和S锁相当的“鸡肋”，它们并不会提供什么额外保护，只是会降低并发能力而已，只会在一些特殊的情况用到（比如系统崩溃恢复时）。</p></blockquote><p>X锁与任何锁不兼容，IX锁与S&#x2F;X锁不兼容。</p><h3 id="2-什么时候要用全局锁，怎么用？"><a href="#2-什么时候要用全局锁，怎么用？" class="headerlink" title="2.什么时候要用全局锁，怎么用？"></a>2.什么时候要用全局锁，怎么用？</h3><p>锁的基本应用场景是在<code>多线程并发操作</code>下使用的，全局锁也是如此</p><p><code>Mysql</code>需要定期做一个数据库的备份，由于备份的过程涉及到大量的<code>I/O</code>，因此在这种情况下，如果不对用户的访问加以限制，那么就很有可能产生并发的错误</p><p>我们假设一个网购的例子，A从商店中购买了C商品，消耗了D元，那么这个过程可以分为对两张表的操作</p><ul><li>1.用户表中A的余额要减D</li><li>2.商店中C商品的库存要减去1</li></ul><p>假设现在数据库备份线程正在执行，假设没有加锁，允许用户线程并发执行。1在备份线程备份数据库之前执行了，2在备份线程数据库之后执行了。这样的话就产生了数据的不一致的问题，最终导致错误。当1和2的顺序调换的时候，会导致更加严重的问题，用户相当于买了一件商品而且余额没减!这是严重的生产事故。</p><p>要使用全局锁，那么可以使用内置的悲观锁，使用的指令如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完了之后，整个数据库的状态就处于只读的状态了，当执行以下几种指令的时候，就会导致阻塞</p><ul><li>对数据库表的结构的DDL语句:比如说<code>alter table</code>、<code>drop table</code>等语句</li><li>对数据库数据的CRUD的DML语句，比如说<code>insert</code>、<code>update</code>、<code>delete</code>等语句</li></ul><p>在加锁完成业务后，就可以执行解锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">unlock</span> <span class="token keyword">tables</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>当会话断开了，全局锁就会被自动释放</p></blockquote><h3 id="3-什么是锁定读，怎么使用锁定读？"><a href="#3-什么是锁定读，怎么使用锁定读？" class="headerlink" title="3.什么是锁定读，怎么使用锁定读？"></a>3.什么是锁定读，怎么使用锁定读？</h3><p>在<code>InnoDB</code>下，普通的<code>select</code>语句根据事务的隔离级别可能会读取到历史版本数据，读-写操作并不冲突，性能更高；如果采用加锁方式，读-写操作彼此需要并发执行，从而影响性能。一般情况下我们更愿意采用MVCC来解决读-写并发问题，但是在某些特殊业务场景中，我们必须采用加锁的方式读取最新数据，那也是没办法的事。</p><p>读取记录时加S锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>读取记录时加X锁：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4.锁的内存结构"></a>4.锁的内存结构</h3><p>对一条记录加锁的本质就是在内存中创建一个锁结构与之关联，隐式锁除外。</p><p>为了节约内存空间，在对不同记录加锁时，如果符合下面这些条件，这些记录的锁就可以放到一个锁结构中：</p><ul><li>在同一个事务事务中进行加锁操作；</li><li>被加锁的记录在同一个页面中；</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p>具体的锁结构为：</p><ul><li>事务信息：锁对应的事务信息，一个锁属于一个事务</li><li>索引信息：对于行级锁，需要记录加锁的记录属于哪个索引</li><li>表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特</li><li>type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分<ul><li>lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类</li><li>lock_type：代表表级锁还是行级锁</li><li>rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting &#x3D; true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程</li></ul></li></ul><h3 id="5-什么是隐式锁"><a href="#5-什么是隐式锁" class="headerlink" title="5.什么是隐式锁"></a>5.什么是隐式锁</h3><p>在内存总生成锁结构并维护它们并不是一件零成本的事，因此提出了隐式锁。比如一般情况执行INSERT语句是不需要在内存中生成锁结构的（当然，如果即将插入的间隙已经被其他事务加上了gap锁，那么本次INSERT操作会阻塞，并且当前事务会在该间隙上加上一个插入意向锁），单纯依靠隐式锁（其实就是记录的trx_id属性）保护插入的记录。</p><ul><li>聚簇索引：索引记录有 trx_id 隐藏列，表示最后改动该记录的事务 id，插入数据后事务 id 就是当前事务。其他事务想获取该记录的锁时会判断当前记录的事务 id 是否是活跃的，如果不是就可以正常加锁；如果是就创建一个 X 的锁结构，该锁的 is_waiting 是 false，为自己的事务创建一个锁结构，is_waiting 是 true（类似 Java 中的锁升级）</li><li>二级索引：获取数据页 Page Header 中的 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，如果小于当前活跃的最小事务 id，就证明插入该数据的事务已经提交，否则就需要获取到主键值进行回表操作</li></ul><p>隐式锁起到了延迟生成锁的效果，如果其他事务与隐式锁没有冲突，就可以避免锁结构的生成，节省了内存资源</p><p>INSERT 在两种情况下会生成锁结构：</p><ul><li><p>重复键：在插入主键或唯一二级索引时遇到重复的键值会报错，在报错前需要对对应的聚簇索引进行加锁</p><ul><li>隔离级别 &lt;&#x3D; Read Uncommitted，加 S 型 Record Lock</li><li>隔离级别 &gt;&#x3D; Repeatable Read，加 S 型 next_key 锁</li></ul></li><li><p>外键检查：如果待插入的记录在父表中可以找到，会对父表的记录加 S 型 Record Lock。如果待插入的记录在父表中找不到</p><ul><li>隔离级别 &lt;&#x3D; Read Committed，不加锁</li><li>隔离级别 &gt;&#x3D; Repeatable Read，加间隙锁</li></ul><h3 id="6-怎么优化锁？"><a href="#6-怎么优化锁？" class="headerlink" title="6.怎么优化锁？"></a>6.怎么优化锁？</h3><p>InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM</p><p>但是使用不当可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（需要业务层面满足需求）</li></ul><h3 id="7-什么是锁升级？"><a href="#7-什么是锁升级？" class="headerlink" title="7.什么是锁升级？"></a>7.什么是锁升级？</h3><p>索引失效造成<strong>行锁升级为表锁</strong>，不通过索引检索数据，全局扫描的过程中 InnoDB 会将对表中的所有记录加锁，实际效果和<strong>表锁</strong>一样，实际开发过程应避免出现索引失效的状况</p><ul><li><p>查看当前表的索引：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW INDEX FROM test_innodb_lock;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关闭自动提交功能：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SET AUTOCOMMIT&#x3D;0;-- C1、C2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行更新语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE test_innodb_lock SET sex&#x3D;&#39;2&#39; WHERE name&#x3D;10;-- C1UPDATE test_innodb_lock SET sex&#x3D;&#39;2&#39; WHERE id&#x3D;3;-- C2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2024/02/17/shen-ru-li-jie-mysql-zhong-de-suo/MySQL-InnoDB%20%E9%94%81%E5%8D%87%E7%BA%A7.png"></p><p>索引失效：执行更新时 name 字段为 varchar 类型，造成索引失效，最终行锁变为表锁 </p><h3 id="8-什么是死锁，如何避免？"><a href="#8-什么是死锁，如何避免？" class="headerlink" title="8.什么是死锁，如何避免？"></a>8.什么是死锁，如何避免？</h3><p>不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁。</p><p>例如：事务T1需要对记录A和B进行修改，事务T2也需要对记录A和B进行修改，当T1获取了记录A的X锁时，需要获取B的X锁，此时T2获取了B的X锁，准备去获取A的X锁。这个时候就发生了死锁。</p><p>解决策略：</p><ul><li><p>超时回滚。当一个事务等待时间超过设置的阈值时，就会进行回滚，另一个事务就能正常执行。，超时时间可以通过参数 innodb_lock_wait_timeout 来设置，默认 50 秒，但是时间的设置不好控制。如果一个事务没有死锁，就是因为业务执行比较慢，但是还没有执行就超时然后回滚了，所以一般不采取该方式。</p></li><li><p>死锁检测。采用等待图的方式来进行死锁检测，发现死锁后<strong>主动回滚死锁链条中较小的一个事务</strong>，让其他事务得以继续执行。这是一种更为主动的方式。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启该功能（事务较小的意思就是事务执行过程中插入、删除、更新的记录条数）</p><p>死锁检测并不是每个语句都要检测，只有在加锁访问的行上已经有锁时，当前事务被阻塞了才会检测，也是从当前事务开始进行检测</p></li></ul><p>通过执行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看最近发生的一次死循环，全局系统变量 <code>innodb_print_all_deadlocks</code> 设置为 on，就可以将每个死锁信息都记录在 MySQL 错误日志中</p><p>死锁一般是行级锁，当表锁发生死锁时，会在事务中访问其他表时<strong>直接报错</strong>，破坏了持有并等待的死锁条件</p><blockquote><p>等待图：图中出现回路，说明出现了死锁的情况。</p></blockquote><p><img src="/2024/02/17/shen-ru-li-jie-mysql-zhong-de-suo/20200215132718969.png"></p></li></ul></li></ul><h3 id="6-什么是乐观锁？"><a href="#6-什么是乐观锁？" class="headerlink" title="6.什么是乐观锁？"></a>6.什么是乐观锁？</h3><p>悲观锁：在整个数据处理过程中，将数据处于锁定状态，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据，修改删除数据时也加锁，其它事务同样无法读取这些数据</p><p>悲观锁和乐观锁使用前提：</p><ul><li>对于读的操作远多于写的操作的时候，一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量，最后需要释放锁，锁是需要一些开销的，这时候可以选择乐观锁</li><li>如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险，这时候可以选择悲观锁</li></ul><p>乐观锁的实现方式：就是 CAS，比较并交换</p><ul><li><p>版本号</p><ol><li><p>给数据表中添加一个 version 列，每次更新后都将这个列的值加 1</p></li><li><p>读取数据时，将版本号读取出来，在执行更新的时候，比较版本号</p></li><li><p>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</p></li><li><p>用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建city表</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> city<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span>，  <span class="token comment">-- 城市id</span>NAME <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>，                   <span class="token comment">-- 城市名称</span>VERSION <span class="token keyword">INT</span>                         <span class="token comment">-- 版本号</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 添加数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> city <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token boolean">NULL</span>，<span class="token string">'北京'</span>，<span class="token number">1</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token boolean">NULL</span>，<span class="token string">'上海'</span>，<span class="token number">1</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token boolean">NULL</span>，<span class="token string">'广州'</span>，<span class="token number">1</span><span class="token punctuation">)</span>，<span class="token punctuation">(</span><span class="token boolean">NULL</span>，<span class="token string">'深圳'</span>，<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 修改北京为北京市</span><span class="token comment">-- 1.查询北京的version</span><span class="token keyword">SELECT</span> VERSION <span class="token keyword">FROM</span> city <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token string">'北京'</span><span class="token punctuation">;</span><span class="token comment">-- 2.修改北京为北京市，版本号+1。并对比版本号</span><span class="token keyword">UPDATE</span> city <span class="token keyword">SET</span> NAME<span class="token operator">=</span><span class="token string">'北京市'</span>，VERSION<span class="token operator">=</span>VERSION<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token string">'北京'</span> <span class="token operator">AND</span> VERSION<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间戳</p><ul><li>和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是 <strong>timestamp</strong></li><li>每次更新后都将最新时间插入到此列</li><li>读取数据时，将时间读取出来，在执行更新的时候，比较时间</li><li>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</li></ul></li></ul><p>乐观锁的异常情况：如果 version 被其他事务抢先更新，则在当前事务中更新失败，trx_id 没有变成当前事务的 ID，当前事务再次查询还是旧值，就会出现<strong>值没变但是更新不了</strong>的现象（anomaly）</p><p>解决方案：每次 CAS 更新不管成功失败，就结束当前事务；如果失败则重新起一个事务进行查询更新</p></li></ol></li></ul><h3 id="7-AUTO-INC锁是什么？有什么用？"><a href="#7-AUTO-INC锁是什么？有什么用？" class="headerlink" title="7.AUTO-INC锁是什么？有什么用？"></a>7.AUTO-INC锁是什么？有什么用？</h3><p>通常来说，我们会将表的主键设置为自增的，而自增主键的id分配的这个过程并不是原子性的，因此可能会导致多个线程同时插入数据的时候，导致自增主键相同的问题。</p><p>那么在这样的情况下，就需要给分配自增主键的过程的加一个锁，让每个线程都能分配到唯一的ID</p><p>目前来说，自增主键分配过程的上锁策略有三种，可以通过调整<code>innodb_autoinc_lock_mode</code>这个变量进行实现</p><p>第一种，在<code>innodb_autoinc_lock_mode = 0 </code>的时候，采取的是最安全的方式，也就是只有当语句执行完毕的时候，才会释放这个锁，然后其他想要<code>insert</code>的线程才能够获取到自增的id，会造成线程的阻塞</p><p>第二种，在<code>innodb_autoinc_lock_mode = 1</code>的时候，采取了一种折中的方案，当能够提前知道需要多少个ID的时候，就会使用一种轻量级锁的机制，这种机制的工作原理就是对字段进行上锁，当有人在申请ID的时候，其他事务不能够插队，但是当不知道当前需要多少个ID的时候，就需要加这个表级锁了</p><p>第三种，在<code>innodb_autoinc_lock_mode = 2</code>的时候，一律采取轻量级锁的机制，也就是只对字段加锁，而不对整个表进行加锁，在这种情况会产生并发问题，这也就是为什么<code>=1</code>时在是不知道插入语句条数的时候要采用表锁的原因</p><p>考虑一个主从复制的场景</p><p><img src="/2024/02/17/shen-ru-li-jie-mysql-zhong-de-suo/%E4%B8%8B%E8%BD%BD%20(6).png"></p><p>在这个情况下，有两个线程并发执行，具体的操作可以描述如下:</p><ul><li>sessionB先插入了两条记录，内容是<code>(1，1，1)、(2，2，2)</code></li><li>并发执行，A插入了<code>(3，5，5)</code></li><li>然后sessionB插入了<code>(4，3，3)，(5，4，4)</code></li></ul><p>于是在这种情况下，<code>sessionB</code>的插入的id是不连续的，然而在<code>lock_mode = 1</code>的时候是会是连续的。</p><p>讨论主从复制的情况:当主库发生了这种情况，<code>bin log</code>面对<code>t2</code>表的更新只会记录这两个<code>session</code>的<code>insert</code>的语句的原始逻辑，也就是主键全部为null，而在这样的情况下，我们首先要明白，记录日志的时候实际上是按照<code>session</code>的整体进行记录的，要么先记录 <code>sessionA</code>要么就先记录<code>sessionB</code>，于是并发执行的情况就被抹除掉了，最终导致了从库数据和主库的数据不一致</p><blockquote><p>怎么解决呢?</p></blockquote><p>要解决这个问题，<code>binlog</code>的日志格式应该要设置为<code>binlog_foramt = row</code>，这样设置能够使得<code>bin log</code>里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是啥，从库的就会是啥</p><h3 id="8-行锁的使用注意事项"><a href="#8-行锁的使用注意事项" class="headerlink" title="8.行锁的使用注意事项"></a>8.行锁的使用注意事项</h3><p><strong>间隙锁唯一目的是防止其他事务向间隙中插入数据。</strong></p><blockquote><p>重点：间隙锁可以共存。一个事务获取的间隙锁并不会阻止另一个事务在同一个间隙上获取间隙锁。共享间隙锁和排他间隙锁之间没有区别。它们彼此之间不冲突，执行相同的功能。允许冲突的间隙锁的原因是，如果一个记录从索引中删除，不同事务持有的该记录上的间隙锁必须被合并。</p></blockquote><p>临键锁是一种将记录锁和间隙锁结合在一起的锁定方式。当在数据库中搜索或扫描索引时，临键锁会在遇到的索引记录上设置锁定，并且还会对该索引记录之前的间隙进行锁定。这样可以防止其他会话在已被锁定的索引记录之前的间隙中插入新的记录。</p><p><strong>临键锁的作用是确保数据的一致性和避免幻读现象。</strong></p><p><code>next-key lock</code> 是前开后闭区间<code>(a, b]</code></p><p>如果上<code>X锁</code>的<code>row</code>是唯一索引的话, 就不会加上<code>Next-Key Lock</code>, 而是会退化为<code>Record Lock</code>，其他情况默认上的是<code>Next-Key Lock</code></p><p><strong>插入意向锁</strong>是用于管理并发插入操作。<strong>当多个事务尝试在同一个索引间隙（两个索引记录之间的空白区域）进行插入时，插入意向锁可以确保它们不会互相冲突。</strong></p><p><strong>但是，临键锁和间隙锁会排斥插入意向锁。</strong></p><p><strong>插入意向锁仅仅是一种指示，它并不阻止其他事务对同一个间隙进行插入操作</strong>。实际上，事务B也可以在插入意向锁存在的情况下执行插入操作。然而，如果两个事务试图在同一个位置插入数据（即发生冲突），则它们必须等待对方完成操作。</p><p><strong>意向锁的作用</strong>：在没有意向锁之前, 我们执行DDL操作时(修改表的字段或者表名之类), 需要事先判断表中是否有其他锁的存在,这个判断的过程是一行一行的扫描过去, 效率极慢。现在出现意向锁之后, 在执行DDL操作前, 可以直接判断表中是否有意向锁的存在, 而不再需要去扫描整个表的行。所以意向锁通常被设计为表锁, 而非行锁, 而且意向锁通常都是相互兼容的, 这就是设计的原因。</p><p>在使用update操作时，如果根据where条件子句的查到到的索引不存在，那么就会加上间隙锁，如果存在那么就会加上record lock只锁这一行记录。</p><p>总结：<strong>修改时添加间隙锁或record lock，插入时获取插入意向锁</strong></p><p>另外要注意：<strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL，锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式基础（二）：BASE理论</title>
      <link href="/2024/02/08/fen-bu-shi-ji-chu-er-base-li-lun/"/>
      <url>/2024/02/08/fen-bu-shi-ji-chu-er-base-li-lun/</url>
      
        <content type="html"><![CDATA[<p>在上一篇 <a href="https://www.tpvlog.com/article/63">CAP理论</a> 中，我提到分布式系统理论上只能取CP或AP，如果要实现强一致性必然会影响可用性。但是，大多数系统实际上不需要那么强的一致性，而是更关注可用性。比如一个3节点的集群，假设每个节点的可用性为 99.9％，那么整个集群的可用性为 99.7％，也就是说，每个月约宕机 129.6 分钟，这对于很多系统是非常严重的问题，所以生产环境，大多数系统都会采用可用性优先的 AP 模型。</p><hr><p>在对大规模分布式系统的实践过程中，eBay 的架构师 Dan Pritchett 提出了BASE理论，其核心思想就是：</p><blockquote><p>即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但分布式系统可以采用适合的方式达到最终一致性（Eventual Consitency）。</p></blockquote><p>Base 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。BASE 是 <strong>基本可用（Basically Available）</strong> 、<strong>软状态（Soft-state）</strong> 和 <strong>最终一致（Eventually Consistent）</strong> 三个短语的缩写：</p><img src="/2024/02/08/fen-bu-shi-ji-chu-er-base-li-lun/base.png" style="zoom: 67%;"><h3 id="1-基本可用"><a href="#1-基本可用" class="headerlink" title="1.基本可用"></a>1.基本可用</h3><p>在BASE理论中，基本可用是说，当分布式系统在出现不可预知的故障时，允许损失部分功能的可用性，保障核心功能的可用性。</p><p>具体来说，你可以把基本可用理解成，当系统节点出现大规模故障的时候，比如专线的光纤被挖断、突发流量导致系统过载，这个时候可以通过服务降级，牺牲部分功能的可用性，保障系统的核心功能可用。</p><h4 id="1-1实现方式"><a href="#1-1实现方式" class="headerlink" title="1.1实现方式"></a>1.1实现方式</h4><p>实现分布式系统基本可用的手段有很多，常见的有：</p><ul><li>流量削峰</li><li>请求排队</li><li>服务降级</li><li>服务熔断</li></ul><p>所以，<strong>基本可用在本质上是一种妥协，也就是在出现节点故障或系统过载的时候，通过牺牲非核心功能的可用性，保障核心功能的稳定运行</strong>。</p><hr><h3 id="2-最终一致"><a href="#2-最终一致" class="headerlink" title="2.最终一致"></a>2.最终一致</h3><p>最终一致性是指，分布式系统即使无法做到强一致性，但应当根据自身业务特点，采用适当的方式在一定时限后使各个节点的数据最终能够达到一致的状态。这个时限取决于网络延时，系统负载，数据复制方案设计等等因素。</p><p>几乎所有的互联网系统采用的都是最终一致性，只有在实在无法使用最终一致性，才使用强一致性或事务，比如，对于决定系统运行的敏感元数据，需要考虑采用强一致性，对于涉账类的支付系统或清算系统的数据，需要考虑采用事务。</p><p>我们可以将CAP理论中的“强一致性”理解为最终一致性的特例，也就是说，你可以把强一致性看作是不存在延迟的一致性。在实践中，你也可以这样思考： 如果业务功能无法容忍一致性的延迟（比如分布式锁对应的数据），就实现强一致性；如果能容忍短暂的一致性延迟（比如 QQ 状态数据），则可以考虑最终一致性。</p><h4 id="2-1实现方式"><a href="#2-1实现方式" class="headerlink" title="2.1实现方式"></a>2.1实现方式</h4><p>那么如何实现最终一致性呢？你首先要知道它以什么为准，因为这是实现最终一致性的关键。一般来说，在实际工程实践中有这样几种方式：</p><ul><li><strong>读时修复：</strong>在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，就是向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据；</li><li><strong>写时修复：</strong>在写入数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Hinted Handoff 实现，具体来说，就是Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。</li><li><strong>异步修复：</strong>这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul><p>注意，因为写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，所以许多开源框架都是用这种方式实现最终一致性的。而读时修复和异步修复因为需要做数据的一致性对比，性能消耗比较多，所以需要尽量优化一致性对比的算法，降低性能消耗，避免对系统运行造成影响。</p><blockquote><p>在实现最终一致性的时候，一般要实现自定义写一致性级别（All、Quorum、One、Any）， 比如<a href="https://www.tpvlog.com/article/153">Elasticsearch</a>在进行索引数据同步时，就支持各种写一致性级别。</p></blockquote><hr><h3 id="3-软状态"><a href="#3-软状态" class="headerlink" title="3.软状态"></a>3.软状态</h3><p>软状态，描述的是实现服务可用性的时候系统数据的一种过渡状态，也就是说不同节点间，数据副本存在短暂的不一致。</p><p>比如，分布式存储中一般一份数据至少会有N个副本，允许系统在不同节点的数据副本之间进行数据同步的过程中存在延时。mysql replication的异步复制也是一种体现。</p><p>这里，我们只需要知道软状态是一种过渡状态就可以了，BASE理论的重点是基本可用以及最终一致性。</p><hr><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它来源于对大规模互联网分布式系统实践的总结，是基于 CAP 定理逐步演化而来的。它的核心思想是：<strong>如果不是必须的话，不推荐实现事务或强一致性，鼓励可用性和性能优先，根据业务的特点，来实现非常弹性的基本可用，以及数据的最终一致性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式基础（一）：CAP理论</title>
      <link href="/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/"/>
      <url>/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/</url>
      
        <content type="html"><![CDATA[<p>集中式应用进行服务化拆分后，必然会出现一个问题：<em><strong>如何保证各个节点（Node）之间的数据一致性？</strong></em></p><p>比如以下场景：<br>用户首先发起一次更新操作，映射到节点A；然后，用户又做了一次查询操作，操作映射到了节点B，此时A和B的数据如果不一致，对用户来说就会造成困扰。</p><p>分布式系统为了提高可用性，必然会引入<strong>冗余机制（副本）</strong>，而冗余便带来了上面描述的一致性问题。为了解决这类问题，加州大学伯克利分校的<a href="https://en.wikipedia.org/wiki/Eric_Brewer_(scientist)">Eric Brewer</a> 教授提出了 CAP 猜想。2年后， Seth Gilbert 和 Nancy Lynch 从理论上<a href="https://dl.acm.org/citation.cfm?id=564601">证明了猜想</a>的可能性。从此，CAP 理论正式在学术上成为了分布式计算领域的公认定理。</p><h3 id="1-CAP三指标"><a href="#1-CAP三指标" class="headerlink" title="1.CAP三指标"></a>1.CAP三指标</h3><p>CAP 理论是一个很好的思考框架，它对分布式系统的特性做了高度抽象，抽象成了<strong>一致性</strong>、<strong>可用性</strong>和<strong>分区容错性</strong>，并对特性间的冲突做了总结。一旦掌握它，我们自然而然就能根据业务场景的特点进行权衡，设计出适合的系统模型。</p><img src="/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/cap.png" style="zoom:67%;"><p>我们先来看看CAP理论中三个指标的含义。</p><h4 id="1-1一致性（Consistence）"><a href="#1-1一致性（Consistence）" class="headerlink" title="1.1一致性（Consistence）"></a>1.1一致性（Consistence）</h4><p>一致性，指的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新数据，要么读取失败。</p><p>注意，一致性是站在客户端的视角出发的，并不是说在某个时间点分布式系统的所有节点的数据是一致的。事实上，在一个事务执行过程中，系统就是处于一种不一致状态，但是客户端是无法读取事务未提交的数据的，此时客户端会直接读取失败。</p><p>CAP理论中的一致性是<em><strong>强一致性</strong></em>，举个例子来理解下：</p><p>初始时，节点1和节点2的数据是一致的，然后客户端向节点1写入了新数据“X &#x3D; 2”：</p><img src="/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/yzx.png" style="zoom:67%;"><p>节点1在本地更新数据后，通过节点间的通讯，同步数据到节点2，确认节点2写入成功后，然后返回成功给客户端：</p><img src="/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/yzx2.png" style="zoom:67%;"><p>这样两个节点的数据就是一致的了，之后，不管客户端访问哪个节点，读取到的都是同一份最新数据。如果节点2在同步数据的过程中，有另外的客户端来访问任意节点，都会拒绝，这就是强一致性。</p><h4 id="1-2可用性-Availability"><a href="#1-2可用性-Availability" class="headerlink" title="1.2可用性(Availability)"></a>1.2可用性(Availability)</h4><p>可用性，指的是客户端的请求，不管访问哪个节点，都能得到响应数据，但不保证是同一份最新数据。你也可以把可用性看作是分布式系统对访问本系统的客户端的另外一种承诺：<strong>我尽力给你返回数据，不会不响应你，但是我不保证每个节点给你的数据都是最新的</strong>。</p><p>这个指标强调的是服务可用，但不保证数据的一致。</p><h4 id="1-3分区容错性-Network-partitioning"><a href="#1-3分区容错性-Network-partitioning" class="headerlink" title="1.3分区容错性(Network partitioning)"></a>1.3分区容错性(Network partitioning)</h4><p>分区容错性，指的是当节点间出现消息丢失、高延迟或者已经发生网络分区时，系统仍然可以继续提供服务。也就是说，分布式系统在告诉访问本系统的客户端：<strong>不管我的内部出现什么样的数据同步问题，我会一直运行，提供服务</strong>。</p><p>分区容错性，强调的是集群对分区故障的容错能力。 因为分布式系统与单机系统不同，它涉及到多节点间的通讯和交互，节点间的分区故障是必然发生的，所以在分布式系统中分区容错性是必须要考虑的。</p><p>既然分区容错是必须要考虑的，那么这时候系统该如何运行呢？是选择一致性（C）呢，还是选择可用性（P）呢？这就引出了著名的“CAP不可能三角”。</p><hr><h3 id="2-CA-CP-AP的选择"><a href="#2-CA-CP-AP的选择" class="headerlink" title="2.CA&#x2F;CP&#x2F;AP的选择"></a>2.CA&#x2F;CP&#x2F;AP的选择</h3><p>所谓“CAP不可能三角”，其实就是CAP理论中提到的： <strong>对于一个分布式系统而言，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）3 个指标不可兼得，只能在 3 个指标中选择 2 个</strong>。</p><p>上面说过了，因为只要有网络交互就一定会有延迟和数据丢失，而这种状况我们必须接受，同时还必须保证系统不能挂掉，所以节点间的分区故障是必然发生的。也就是说，分区容错性（P）是前提，是必须要保证的。</p><h4 id="2-1CP架构"><a href="#2-1CP架构" class="headerlink" title="2.1CP架构"></a>2.1CP架构</h4><p>当选择了一致性（C）的时候，如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的写请求时，因为无法保证所有节点都是最新信息，所以系统将返回写失败错误，也就是说集群拒绝新数据写入。</p><p>如下图，T1时刻，客户端往节点A写入<strong>Message 2</strong>，此时发生了网络分区，节点A的数据无法同步到节点B；T2时刻，如果客户端分别读取了节点A和节点B的数据，就会出现数据不一致。</p><img src="/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/cp.png"><p>此时，为了保证一致性（C），客户端从节点B读取数据时，节点B应当返回<strong>error</strong>，提示客户端”系统发生了错误”，这种方式相当于放弃了可用性（A），此时CAP三者只能满足CP。</p><h4 id="2-2AP架构"><a href="#2-2AP架构" class="headerlink" title="2.2AP架构"></a>2.2AP架构</h4><p>当选择了可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。</p><p>如下图，T1时刻，客户端往节点A写入<strong>Message 2</strong>，此时发生了网络分区，节点A的数据无法同步到节点B；T2时刻，客户端访问节点B时，节点B将自己当前拥有的数据<strong>Message 1</strong>返回给客户端，而实际上当前最新数据已经是<strong>Message2</strong>了，这就不满足一致性（C），此时CAP三者只能满足AP。</p><img src="/2024/02/05/fen-bu-shi-ji-chu-yi-cap-li-lun/ap.png"><blockquote><p>注意：这里节点B返回的<strong>Message 1</strong>虽然不是一个”正确“的结果，但是一个”合理“的结果，因为节点B只是返回的不是最新结果，并不是一个错乱的值。</p></blockquote><hr><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>本章，我对CAP理论进行了基本的讲解，总结一下：</p><ul><li>CA 模型：在分布式系统中不存在，因为舍弃 P，意味着舍弃分布式系统，就比如单机版关系型数据库 MySQL，如果 MySQL 要考虑主备或集群部署时，它必须考虑 P。</li><li>CP 模型：采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入，典型的应用是 ZooKeeper，Etcd 和 HBase。</li><li>AP 模型：采用 AP 模型的分布式系统，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误，但当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。典型应用就比如 Cassandra 和 DynamoDB。</li></ul><p>最后，关于CAP 理论有个误解：就是认为无论在什么情况下，分布式系统都只能在 C 和 A 中选择 1 个。 事实上，在不存在网络分区的情况下（也就是分布式系统正常运行时），C 和 A 能够同时保证。只有当发生分区故障的时候，也就是说需要 P 时，才会在 C 和 A 之间做出选择。</p><p>所以，我们在进行系统设计时，需要根据实际的业务场景， 在一致性和可用性之间做出权衡。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM之垃圾回收机制</title>
      <link href="/2024/02/02/jvm-zhi-la-ji-hui-shou-ji-zhi/"/>
      <url>/2024/02/02/jvm-zhi-la-ji-hui-shou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-到底谁是垃圾？"><a href="#1-到底谁是垃圾？" class="headerlink" title="1.到底谁是垃圾？"></a>1.到底谁是垃圾？</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>日常生活中，如果一个东西经常没被使用，那么这个对象可以说就是垃圾。在 Java 中也是如此，如果一个对象不可能再被引用，那么这个对象就是垃圾，应该被回收。</p><p>根据这个思想，我们很容易想到使用引用计数的方法来判断垃圾。在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过判断引用计数是否为零来判断一个对象是否为垃圾。</p><p>上面的这种方法虽然简单，但是其存在一个致命的问题，那就是<strong>循环引用</strong>。</p><p>A 引用了 B，B 引用了 C，C 引用了 A，它们各自的引用计数都为 1。但是它们三个对象却从未被其他对象引用，只有它们自身互相引用。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。</p><h4 id="GC-Root-Tracing-算法"><a href="#GC-Root-Tracing-算法" class="headerlink" title="GC Root Tracing 算法"></a>GC Root Tracing 算法</h4><p>其大概的过程是这样：从 GC Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。</p><p>可以看到这里最重要的就是 GC Root 这个集合了，其实 GC Root 就是一组活跃引用的集合。但是这个集合又与一般的对象集合不太一样，这些集合是经过特意筛选出来的，通常包括：</p><ul><li>所有当前被加载的 Java 类</li><li>Java 类的引用类型静态变量</li><li>Java类的运行时常量池里的引用类型常量</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用</li><li>等等</li></ul><p>简单地说，GC Root 就是经过精心挑选的一组活跃引用，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。</p><h3 id="2-如何进行垃圾回收？"><a href="#2-如何进行垃圾回收？" class="headerlink" title="2.如何进行垃圾回收？"></a>2.如何进行垃圾回收？</h3><p>到这里，我们了解了什么是垃圾以及 JVM 是如何判断垃圾对象的。那么识别出垃圾对象之后，JVM 是如何进行垃圾回收的呢？这就是我们下面要讲的内容：如何进行垃圾回收？</p><p>垃圾回收算法简单地说有三种算法：标记清除算法、复制算法、标记压缩算法。</p><ul><li><strong>标记清除算法</strong>：从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 出发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。</li><li><strong>复制算法</strong>：复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。</li><li><strong>标记压缩算法</strong>：标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。</li></ul><p>对比一下这三种算法，可以发现他们都有各自的优点和缺点。</p><p>标记清除算法虽然会产生内存碎片，但是不需要移动太多对象，比较适合在存活对象比较多的情况。而复制算法虽然需要将内存空间折半，并且需要移动存活对象，但是其清理后不会有空间碎片，比较适合存活对象比较少的情况。而标记压缩算法，则是标记清除算法的优化版，减少了空间碎片。</p><h3 id="3-分代思想"><a href="#3-分代思想" class="headerlink" title="3.分代思想"></a>3.分代思想</h3><p>试想一下，如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。其实 JVM 虚拟机的建造者们也是这么想的，因此在实际的垃圾回收算法中采用了<strong>分代算法</strong>。</p><p>所谓分代算法，就是根据 JVM 内存的不同内存区域，采用不同的垃圾回收算法。例如对于存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。</p><p>试想一下，如果没有采用分代算法，而在老年代中使用复制算法。在极端情况下，老年代对象的存活率可以达到100%，那么我们就需要复制这么多个对象到另外一个内存区域，这个工作量是非常庞大的。</p><p>在这里我们再深入地聊一聊新生代里采取的垃圾回收算法。如我们上面所说，新生代的特点是存活对象少，适合采用复制算法。而复制算法的一种最简单实现便是折半内存使用，另一半备用。但实际上我们知道，在实际的 JVM 新生代划分中，却不是采用等分为两块内存的形式。而是分为：Eden 区域、from 区域、to 区域 这三个区域。<strong>那么为什么 JVM 最终要采用这种形式，而不用 50% 等分为两个内存块的方式？</strong></p><p>要解答这个问题，我们就需要先深入了解新生代对象的特点。根据IBM公司的研究表明，在新生代中的对象 98% 是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间。所以在HotSpot虚拟机中，JVM 将内存划分为一块较大的Eden空间和两块较小的Survivor空间，其大小占比是8:1:1。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Eden空间。</p><p>通过这种方式，内存的空间利用率达到了90%，只有10%的空间是浪费掉了。而如果通过均分为两块内存，则其内存利用率只有 50%，两者利用率相差了将近一倍。</p><h3 id="4-分区思想"><a href="#4-分区思想" class="headerlink" title="4.分区思想"></a>4.分区思想</h3><p>分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p><img src="/2024/02/02/jvm-zhi-la-ji-hui-shou-ji-zhi/p_20240329095625.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之Java虚拟机内存结构</title>
      <link href="/2024/01/29/jvm-zhi-java-xu-ni-ji-nei-cun-jie-gou/"/>
      <url>/2024/01/29/jvm-zhi-java-xu-ni-ji-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java虚拟机内存结构，也叫<strong>运行时数据区</strong>，根据《Java 虚拟机规范》，Java 虚拟机的内存结构可以<strong>分为公有和私有两部分</strong>。公有指的是所有线程都共享的部分，指的是 <strong>Java 堆、方法区、常量池</strong>。私有指的是每个线程的私有数据，包括：<strong>PC寄存器、Java 虚拟机栈、本地方法栈</strong>。</p><h3 id="1-公有部分：Java堆、方法区、常量池"><a href="#1-公有部分：Java堆、方法区、常量池" class="headerlink" title="1.公有部分：Java堆、方法区、常量池"></a>1.公有部分：Java堆、方法区、常量池</h3><p>在 Java 虚拟机中，线程共享部分包括 Java 堆、方法区及常量池。</p><p>Java 堆指的是从 JVM 划分出来的一块区域，这块区域专门用于 Java 实例对象的内存分配，几乎所有实例对象都在会这里进行内存的分配。</p><p>方法区指的是存储 Java 类字节码数据的一块区域，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造方法等。可以看到常量池其实是存放在方法区中的，但《Java 虚拟机规范》将常量池和方法区放在同一个等级上，这点我们知晓即可。方法区在不同版本的虚拟机有不同的表现形式，例如在 1.7 版本的 HotSpot 虚拟机中，方法区被称为永久代（Permanent Space），而在 JDK 1.8 中则被称之为 MetaSpace。</p><p>说完这几个部分的大致作用之后，我们来深入说说 Java 堆。</p><p>Java 堆根据对象存活时间的不同，Java 堆还被分为年轻代、老年代两个区域，年轻代还被进一步划分为 Eden 区、From Survivor 0、To Survivor 1 区。如下图所示。</p><p><img src="/2024/01/29/jvm-zhi-java-xu-ni-ji-nei-cun-jie-gou/p_20240328185750.png"></p><p>当有对象需要分配时，一个对象永远优先被分配在年轻代的 Eden 区，等到 Eden 区域内存不够时，Java 虚拟机会启动垃圾回收。此时 Eden 区中没有被引用的对象的内存就会被回收，而一些存活时间较长的对象则会进入到老年代。在 JVM 中有一个名为 -XX:MaxTenuringThreshold 的参数专门用来设置晋升到老年代所需要经历的 GC 次数，即在年轻代的对象经过了指定次数的 GC 后，将在下次 GC 时进入老年代。</p><p>这里让我们思考一个问题：为什么 Java 堆要进行这样一个区域划分呢？</p><p>根据我们的经验，虚拟机中的对象必然有存活时间长的对象，也有存活时间短的对象，这是一个普遍存在的正态分布规律。如果我们将其混在一起，那么因为存活时间短的对象有很多，那么势必导致较为频繁的垃圾回收。而垃圾回收时不得不对所有内存都进行扫描，但其实有一部分对象，它们存活时间很长，对他们进行扫描完全是浪费时间。因此为了提高垃圾回收效率，分区就理所当然了。</p><p>另外一个值得我们思考的问题是：为什么默认的虚拟机配置，Eden：from ：to &#x3D; 8:1:1 呢？</p><p>其实这是 IBM 公司根据大量统计得出的结果。根据 IBM 公司对对象存活时间的统计，他们发现 80% 的对象存活时间都很短。于是他们将 Eden 区设置为年轻代的 80%，这样可以减少内存空间的浪费，提高内存空间利用率。</p><h3 id="2-私有部分"><a href="#2-私有部分" class="headerlink" title="2.私有部分"></a>2.私有部分</h3><p>PC 寄存器，顾名思义 Program Counter 寄存器，指的是保存线程当前正在执行的方法。如果这个方法不是 native 方法，那么 PC 寄存器就保存 Java 虚拟机正在执行的字节码指令地址。如果是 native 方法，那么 PC 寄存器保存的值是 undefined。任意时刻，一条 Java 虚拟机线程只会执行一个方法的代码，而这个被线程执行的方法称为该线程的当前方法，其地址被存在 PC 寄存器中。</p><p>Java 虚拟机栈，这个栈与线程同时创建，用来存储栈帧，即存储局部变量与一些过程结果的地方。栈帧存储的数据包括：局部变量表、操作数栈。</p><p>当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。如果 Java 虚拟机不支持 natvie 方法，并且自己也不依赖传统栈的话，可以无需支持本地方法栈。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>Java 虚拟机的内存结构是学习虚拟机所必须掌握的地方，其中以 Java 堆的内存模型最为重要，因为线上问题很多时候都是 Java 堆出现问题。因此掌握 Java 堆的划分以及常用参数的调整最为关键。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之volatile详解</title>
      <link href="/2024/01/24/juc-zhi-volatile-xiang-jie/"/>
      <url>/2024/01/24/juc-zhi-volatile-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>保证被 volatile 修饰的共享变量的 可见性 和 有序性，但不保证原子性</p><h3 id="1-内存模型概述"><a href="#1-内存模型概述" class="headerlink" title="1.内存模型概述"></a>1.内存模型概述</h3><p>每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了<strong>高速缓存</strong>。</p><p>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><p>以 <code>i = i + 1 ;</code>为例，当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>可能存在下面一种情况：初始时，两个线程分别读取 i 的值存入各自所在的CPU的高速缓存当中，然后线程A进行加1操作，然后把i的最新值 1 写入到内存。此时线程 B 的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p>最终结果i的值是1，而不是2。这就是著名的<strong>缓存一致性问题</strong>。通常称这种被多个线程访问的变量为<strong>共享变量</strong>。也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>为了解决这个问题</p><ul><li>通过在总线加LOCK#锁的方式</li><li>通过缓存一致性协议</li></ul><h3 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2.Java内存模型"></a>2.Java内存模型</h3><p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的<strong>工作内存（类似于前面的高速缓存）</strong>。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p><table><thead><tr><th>概念</th><th>定义</th><th align="center">备注</th></tr></thead><tbody><tr><td>原子性</td><td>一个操作&#x2F;一系列操作</td><td align="center">要么全部执行&#x2F;全部不执行</td></tr><tr><td>可见性</td><td>当一个线程修改了共享变量的值后，其他线程能够立刻看到共享变量值的修改</td><td align="center">JMM的内存空间分为：主存和工作内存（变量存于主存中；线程使用的是自身工作内存，更新后再同步到主存）。共享属性的修改过程：从主存中读取&amp;复制到工作内存中，在工作内存中修改完成后，再同步到主存、从而刷新主存中的值。若线程A在工作内存中修改完成但还未刷新主存中的值，线程B看到的值还是旧值。此时，可见性就无法保证</td></tr><tr><td>有序性</td><td>程序的运行顺序看起来 和 我们编写的逻辑的顺序一致，但计算机在实际执行中却不一定</td><td align="center">为了提高性能，编译器&amp;处理器都会对代码进行重新排序。但有个前提：重新排序的结果要和单线程执行程序顺序一致</td></tr></tbody></table><h3 id="3-保证可见性"><a href="#3-保证可见性" class="headerlink" title="3.保证可见性"></a>3.保证可见性</h3><p>volatile修饰的属性保证每次读取都能读到最新的值，<strong>但不会 并且 无法更新已经读了的值</strong></p><p>线程A在工作内存中修改的共享属性值会立即刷新到主存，<strong>线程B&#x2F;C&#x2F;D每次通过读写屏障</strong>来达到<strong>类似</strong>于直接从主存中读取属性值</p><ul><li>只是类似，网上有些说volatile修饰的变量读写直接在主存中操作，这种说法是不对的，只是表现出这种效果</li><li>读写屏障是一条CPU指令；插入一个读写屏障 &#x3D; 告诉CPU &amp; 编译器先于这个命令的必须先执行，后于这个命令的必须后执行（有序性）</li><li>读写屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，以此保证可见性</li></ul><h3 id="4-保证有序性"><a href="#4-保证有序性" class="headerlink" title="4.保证有序性"></a>4.保证有序性</h3><p>当对volatile修饰的变量进行读&#x2F;写操作时，其前面的代码必须已执行完成 &amp; 结果对后续的操作可见</p><p>原理：重排序时，以volatile修饰变量的读&#x2F;写操作代码行为分界线，读&#x2F;写操作前面的代码不许排序到后面，后面同理不许排序到前面。由此保证有序性</p><h3 id="5-不保证原子性"><a href="#5-不保证原子性" class="headerlink" title="5.不保证原子性"></a>5.不保证原子性</h3><p>volatile修饰的属性若在修改前已读取了值，那么修改后，无法改变已经复制到工作内存的值，即无法阻止并发的情况</p><h3 id="6-volatile关键字的两层语义"><a href="#6-volatile关键字的两层语义" class="headerlink" title="6.volatile关键字的两层语义"></a>6.volatile关键字的两层语义</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><h3 id="7-volatile的原理和实现机制"><a href="#7-volatile的原理和实现机制" class="headerlink" title="7.volatile的原理和实现机制"></a>7.volatile的原理和实现机制</h3><p>下面这段话摘自《深入理解Java虚拟机》：</p><blockquote><p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令</p></blockquote><p>lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：</p><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成</li><li>它会强制将对缓存的修改操作立即写入主存</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解MVCC机制</title>
      <link href="/2024/01/20/shen-ru-li-jie-mvcc-ji-zhi/"/>
      <url>/2024/01/20/shen-ru-li-jie-mvcc-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>我们先回顾一下事务并发执行过程中可能遇到的现象，按照一致性问题的严重性给他们排一下序：</p><p><strong>肮写&gt;脏读&gt;不可重复读&gt;幻读</strong></p><p>在SQL标准中设立了4个隔离级别，级别越低就约有可能发生严重的问题，从低到高为：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ UNCOMMITTED（读未提交）</td><td align="center">可能</td><td align="center">可能</td><td align="center">可能</td></tr><tr><td align="center">READ COMMITTED（读提交）</td><td align="center">不可能</td><td align="center">可能</td><td align="center">可能</td></tr><tr><td align="center">REPEATABLE READ（可重复读）</td><td align="center">不可能</td><td align="center">不可能</td><td align="center">可能</td></tr><tr><td align="center">SERIALIZABLE（串行化）</td><td align="center">不可能</td><td align="center">不可能</td><td align="center">不可能</td></tr></tbody></table><p>因为脏写这个现象对一致性的影响太严重，所以无论哪种隔离级别，都不允许脏写出现。在MySQL中一个为未提交事务在对一条记录写操作前会对这条记录加锁，其他事务就不能再进行写操作，当事务提交后才会释放锁，所以可以认为写-写操作是串行化执行的。</p><p>在MySQL中默认的隔离级别是可重复读。</p><p>回顾完前置知识，我们接下来讲解MVCC原理。</p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含下面两个必要的隐藏列（row_id并不是必要的；在创建的表中有主键时，或者有不允许为NULL的UNIQUE键时，都不会包含row_id）。</p><ul><li>trx_id：一个事务每次对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li><li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中。这个隐藏列就相当于一个指针，可以通过它找到修改前的信息。</li></ul><blockquote><p>实际上undo日志只在事务回滚时发生作用。当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收。虽然真正的undo日志占用的存储空间被回收了，但是roll_pointer的值并不会被清除。</p></blockquote><p>每对记录进行一次改动，都会记录一条undo日志。每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为INSERT前没有更早的操作），通过这个属性可以将undo日志串成一个链表。这就链表就称为<strong>版本链</strong>。版本链的头节点就是当前记录的最新值。我们可以用这个版本链来控制并发事务访问相同记录时的行为。我们把这种机制称之为<strong>多版本并发控制（Multi-Version Concurrency Control, MVCC）</strong>。</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用SERIALIZABLE隔离级别的事务来说，InnoDB规定使用加锁的方式来访问记录；对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已提交的事务修改过的记录。也就是说假如另一个事务已经修改了记录但是还未提交，则不能直接读取最新版本的记录。核心问题是：需要判断版本链中的哪一个版本是当前事务可见的。为此，InnoDB提出了ReadView（有点地方翻译成“一致性视图”）的概念。</p><p>这个ReadView中主要包含4个比较重要的内容。</p><ul><li>m_ids：在生成ReadView时，当前系统中活跃的读写事务的事务id列表。</li><li>min_trx_id：在生成ReadView时，当前系统中活跃的读写事务中最小的事务id；也就是m_ids中的最小值。</li><li>max_trx_id：在生成ReadView时，系统应该分配给下一个事务的事务id值。</li></ul><blockquote><p>注意max_trx_id并不是m_ids中的最大值。事务id是递增分配的。比如现在有事务id分别为1、2、3的这3个事务，之后id为3的事务提交了，那么一个新的事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4.</p></blockquote><ul><li>creator_trx_id：生成该ReadView的事务的事务id。</li></ul><blockquote><p>注意，只有在对表中的记录进行改动时（执行INSERT、DELETE、UPDATE）才会为事务分配唯一的事务id，否则一个事务的id默认值为0.</p></blockquote><p>有了这个ReadView后，在访问某条记录时，只需要按照下面的步骤来判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id小于ReadView中的min_trx_id，表明生成该版本的事务在当前事务生成ReadView前已经提交了，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id大于或大于ReadView中的max_trx_id，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id在ReadView的min_trx_id和max_trx_id之间，则需要判断trx_id是否在m_ids列表中。如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。如果不在，说明创建ReadView时生成该版本的事务已经提交了，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务是不可见，那就顺着版本版本链找到下一个版本的数据，并继续执行上面的步骤来判断记录的可见性；以此类推，直到版本链的最后一个版本。如果记录的最后一个版本也不可见，就意味着该条记录对当前事务完全不可见，查询结果就不包含该条记录。</p><p>在MySQL中，READ COMMITTED和REPEATABLE READ之间的一个非常大的区别就是它们生成ReadView的时机不同。</p><ul><li>READ COMMITTED：事务每次查询开始时都会生成一个独立的ReadView</li><li>REPEATABLE READ：事务只会在第一次执行查询语句时生成一个ReadView，之后的查询接着用这个ReadView</li></ul><h4 id="二级索引与MVCC"><a href="#二级索引与MVCC" class="headerlink" title="二级索引与MVCC"></a>二级索引与MVCC</h4><p>我们知道，只有在聚簇索引记录中才有trx_id和roll_pointer隐藏列。如果某个查询语句是使用二级索引来执行查询的，该如何判断可见性呢？比如下面这个事务：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> hero <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'刘备'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设查询优化器决定先到二级索引idx_name中定位name值为’刘备’的二级索引记录，那么怎么知道这条二级索引记录对这个查询事务是否可见呢？判断可见性的过程大致分为下面两步：</p><ol><li>二级索引页面的Page Header 部分有一个名为PAGE_MAX_TRX_ID的属性，每当对该页面中的记录执行增删改操作时，如果执行该操作的事务的事务id大于PAGE MAX_TRX_ID属性值，就会把PAGE_MAX_TRX_ID设置为执行该操作的事务的事务id。这也就意味着<strong>PAGE MAX_TRX_ID属性值代表着修改该二级索引页面的最大事务id是什么</strong>。当SELECT 语句访问某个二级索引记录时，首先会看一下对应的ReadView 的min_trx_id是否大于该页面的PAGE_MAX_TRX_ID属性值。如果是，说明该页面中的所有记录都对该ReadVicw可见；否则就得执行步骤2，在回表之后再判断可见性。</li><li>利用二级索引记录中的主键值进行回表操作，得到对应的聚簇索引记录后再按照前面讲过的方式找到对该ReadView可见的第一个版本，然后判断该版本中相应的二级索引列的值是否与利用该二级索引查询时的值相同。本例中就是判断找到的第一个可见版本的name 值是不是’刘备‘。如果是，就把这条记录发送给客户端（如果WHERE子句中还有其他搜索条件的话还需继续判断），否则就跳过该记录。</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从前文可以看出，所谓的MVCC 指的就是在使用READ COMMITTED、REPEATABLE READ这两种隔离级别的事务执行普通的SELECT操作时，访问记录的版本链的过程。这样可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTED、REPEATABLE READ这两个隔离级别有一个很大的不同，就是生成ReadView 的时机不同：READCOMMITTED在每一次进行普通SELECT 操作前都会生成一个ReadView；而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVCC </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务机制详解</title>
      <link href="/2024/01/14/shi-wu-ji-zhi-xiang-jie/"/>
      <url>/2024/01/14/shi-wu-ji-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQL 支持事务。</p><p>单元中的每条 SQL 语句都相互依赖，形成一个整体</p><ul><li><p>如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态</p></li><li><p>如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行</p></li></ul><p>事务的四大特征：ACID</p><ul><li>原子性 (atomicity)</li><li>一致性 (consistency)</li><li>隔离性 (isolaction)</li><li>持久性 (durability)</li></ul><p>事务的几种状态：</p><ul><li>活动的（active）：事务对应的数据库操作正在执行中</li><li>部分提交的（partially committed）：事务的最后一个操作执行完，但是内存还没刷新至磁盘</li><li>失败的（failed）：当事务处于活动状态或部分提交状态时，如果数据库遇到了错误或刷脏失败，或者用户主动停止当前的事务</li><li>中止的（aborted）：失败状态的事务回滚完成后的状态</li><li>提交的（committed）：当处于部分提交状态的事务刷脏成功，就处于提交状态</li></ul><hr><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>事务管理的三个步骤</p><ol><li><p>开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败</p></li><li><p>执行 SQL 语句：执行具体的一条或多条 SQL 语句</p></li><li><p>结束事务（提交|回滚）</p><ul><li>提交：没出现问题，数据进行更新</li><li>回滚：出现问题，数据恢复到开启事务时的状态</li></ul></li></ol><p>事务操作：</p><ul><li><p>显式开启事务</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">START TRANSACTION [READ ONLY|READ WRITE|WITH CONSISTENT SNAPSHOT]; #可以跟一个或多个状态，最后的是一致性读BEGIN [WORK];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>说明：不填状态默认是读写事务</p></li><li><p>回滚事务，用来手动中止事务</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ROLLBACK;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>提交事务，显示执行是手动提交，MySQL 默认为自动提交</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">COMMIT;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>保存点：在事务的执行过程中设置的还原点，调用 ROLLBACK 时可以指定回滚到哪个点</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SAVEPOINT point_name;#设置保存点RELEASE point_name#删除保存点ROLLBACK [WORK] TO [SAVEPOINT] point_name#回滚至某个保存点，不填默认回滚到事务执行之前的状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>操作演示</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 开启事务START TRANSACTION;-- 张三给李四转账500元-- 1.张三账户-500UPDATE account SET money&#x3D;money-500 WHERE NAME&#x3D;&#39;张三&#39;;-- 2.李四账户+500UPDATE account SET money&#x3D;money+500 WHERE NAME&#x3D;&#39;李四&#39;;-- 回滚事务(出现问题)ROLLBACK;-- 提交事务(没出现问题)COMMIT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h4><p>提交方式的相关语法：</p><ul><li><p>查看事务提交方式</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT @@AUTOCOMMIT;  -- 会话，1 代表自动提交    0 代表手动提交SELECT @@GLOBAL.AUTOCOMMIT;-- 系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改事务提交方式</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SET @@AUTOCOMMIT&#x3D;数字;-- 系统SET AUTOCOMMIT&#x3D;数字;-- 会话<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>系统变量的操作</strong>：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> 变量名 <span class="token operator">=</span> 值<span class="token punctuation">;</span><span class="token comment">-- 默认是会话</span><span class="token keyword">SET</span> @@<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">]</span>变量名 <span class="token operator">=</span> 值<span class="token punctuation">;</span><span class="token comment">-- 默认是系统</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> VARIABLES <span class="token punctuation">[</span><span class="token operator">LIKE</span> <span class="token string">'变量%'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">-- 默认查看会话内系统变量值</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>工作原理：</p><ul><li>自动提交：如果没有 START TRANSACTION 显式地开始一个事务，那么<strong>每条 SQL 语句都会被当做一个事务执行提交操作</strong>；显式开启事务后，会在本次事务结束（提交或回滚）前暂时关闭自动提交</li><li>手动提交：不需要显式的开启事务，所有的 SQL 语句都在一个事务中，直到执行了提交或回滚，然后进入下一个事务</li><li>隐式提交：存在一些特殊的命令，在事务中执行了这些命令会马上<strong>强制执行 COMMIT 提交事务</strong><ul><li><strong>DDL 语句</strong> (CREATE&#x2F;DROP&#x2F;ALTER)、LOCK TABLES 语句、LOAD DATA 导入数据语句、主从复制语句等</li><li>当一个事务还没提交或回滚，显式的开启一个事务会隐式的提交上一个事务</li></ul></li></ul><hr><h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>事务在执行过程中对某个表执行了<strong>增删改操作或者创建表</strong>，就会为当前事务分配一个独一无二的事务 ID（对临时表并不会分配 ID），如果当前事务没有被分配 ID，默认是 0</p><p>说明：只读事务不能对普通的表进行增删改操作，但是可以对临时表增删改，读写事务可以对数据表执行增删改查操作</p><p>事务 ID 本质上就是一个数字，服务器在内存中维护一个全局变量：</p><ul><li>每当需要为某个事务分配 ID，就会把全局变量的值赋值给事务 ID，然后变量自增 1</li><li>每当变量值为 256 的倍数时，就将该变量的值刷新到系统表空间的 Max Trx ID 属性中，该属性占 8 字节</li><li>系统再次启动后，会读取表空间的 Max Trx ID 属性到内存，加上 256 后赋值给全局变量，因为关机时的事务 ID 可能并不是 256 的倍数，会比 Max Trx ID 大，所以需要加上 256 保持事务 ID 是一个<strong>递增的数字</strong></li></ul><p><strong>聚簇索引</strong>的行记录除了完整的数据，还会自动添加 trx_id、roll_pointer 隐藏列，如果表中没有主键并且没有非空唯一索引，也会添加一个 row_id 的隐藏列作为聚簇索引</p><hr><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="四种级别"><a href="#四种级别" class="headerlink" title="四种级别"></a>四种级别</h4><p>事务的隔离级别：多个客户端操作时，各个客户端的事务之间应该是隔离的，<strong>不同的事务之间不该互相影响</strong>，而如果多个事务操作同一批数据时，则需要设置不同的隔离级别，否则就会产生问题。</p><p>隔离级别分类：</p><table><thead><tr><th>隔离级别</th><th>名称</th><th>会引发的问题</th><th>数据库默认隔离级别</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>读未提交</td><td>脏读、不可重复读、幻读</td><td></td></tr><tr><td>Read Committed</td><td>读已提交</td><td>不可重复读、幻读</td><td>Oracle &#x2F; SQL Server</td></tr><tr><td>Repeatable Read</td><td>可重复读</td><td>幻读</td><td>MySQL</td></tr><tr><td>Serializable</td><td>可串行化</td><td>无</td><td></td></tr></tbody></table><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差</p><ul><li><p>脏写 (Dirty Write)：当两个或多个事务选择同一行，最初的事务修改的值被后面事务修改的值覆盖，所有的隔离级别都可以避免脏写（又叫丢失更新），因为有行锁</p></li><li><p>脏读 (Dirty Reads)：在一个事务处理过程中读取了另一个<strong>未提交</strong>的事务中修改过的数据</p></li><li><p>不可重复读 (Non-Repeatable Reads)：在一个事务处理过程中读取了另一个事务中修改并<strong>已提交</strong>的数据</p><blockquote><p>可重复读的意思是不管读几次，结果都一样，可以重复的读，可以理解为快照读，要读的数据集不会发生变化</p></blockquote></li><li><p>幻读 (Phantom Reads)：在事务中按某个条件先后两次查询数据库，后一次查询查到了前一次查询没有查到的行，<strong>数据条目</strong>发生了变化。比如查询某数据不存在，准备插入此记录，但执行插入时发现此记录已存在，无法插入</p></li></ul><p>隔离级别操作语法：</p><ul><li><p>查询数据库隔离级别</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT @@TX_ISOLATION;-- 会话SELECT @@GLOBAL.TX_ISOLATION;-- 系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改数据库隔离级别</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>InnoDB 存储引擎支持事务，所以加锁分析是基于该存储引擎</p><ul><li><p>Read Uncommitted 级别，任何操作都不会加锁</p></li><li><p>Read Committed 级别，增删改操作会加写锁（行锁），读操作不加锁</p><p>在 Server 层过滤条件时发现不满足的记录会调用 unlock_row 方法释放该记录的行锁，保证最后只有满足条件的记录加锁，但是扫表过程中每条记录的<strong>加锁操作不能省略</strong>。所以对数据量很大的表做批量修改时，如果无法使用相应的索引（全表扫描），在 Server 过滤数据时就会特别慢，出现虽然没有修改某些行的数据，但是还是被锁住了的现象（锁表），这种情况同样适用于  RR</p></li><li><p>Repeatable Read 级别，增删改操作会加写锁，读操作不加锁。因为读写锁不兼容，<strong>加了读锁后其他事务就无法修改数据</strong>，影响了并发性能，为了保证隔离性和并发性，MySQL 通过 MVCC 解决了读写冲突。RR 级别下的锁有很多种，锁机制章节详解</p></li><li><p>Serializable 级别，读加共享锁，写加排他锁，读写互斥，使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差</p><ul><li>串行化：让所有事务按顺序单独执行，写操作会加写锁，读操作会加读锁</li><li>可串行化：让所有操作相同数据的事务顺序执行，通过加锁实现</li></ul></li></ul><p>参考文章：<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p><hr><h3 id="原子特性"><a href="#原子特性" class="headerlink" title="原子特性"></a>原子特性</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>原子性是指事务是一个不可分割的工作单位，事务的操作如果成功就必须要完全应用到数据库，失败则不能对数据库有任何影响。比如事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态</p><p>InnoDB 存储引擎提供了两种事务日志：redo log（重做日志）和 undo log（回滚日志）</p><ul><li>redo log 用于保证事务持久性</li><li>undo log 用于保证事务原子性和隔离性</li></ul><p>undo log 属于<strong>逻辑日志</strong>，根据每行操作进行记录，记录了 SQL 执行相关的信息，用来回滚行记录到某个版本</p><p>当事务对数据库进行修改时，InnoDB 会先记录对应的 undo log，如果事务执行失败或调用了 rollback 导致事务回滚，InnoDB 会根据 undo log 的内容<strong>做与之前相反的操作</strong>：</p><ul><li><p>对于每个 insert，回滚时会执行 delete</p></li><li><p>对于每个 delete，回滚时会执行 insert</p></li><li><p>对于每个 update，回滚时会执行一个相反的 update，把数据修改回去</p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p><hr><h4 id="DML-解析"><a href="#DML-解析" class="headerlink" title="DML 解析"></a>DML 解析</h4><h5 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h5><p>乐观插入：当前数据页的剩余空间充足，直接将数据进行插入</p><p>悲观插入：当前数据页的剩余空间不足，需要进行页分裂，申请一个新的页面来插入数据，会造成更多的 redo log，undo log 影响不大</p><p>当向某个表插入一条记录，实际上需要向聚簇索引和所有二级索引都插入一条记录，但是 undo log <strong>只针对聚簇索引记录</strong>，在回滚时会根据聚簇索引去所有的二级索引进行回滚操作</p><p>roll_pointer 是一个指针，<strong>指向记录对应的 undo log 日志</strong>，一条记录就是一个数据行，行格式中的 roll_pointer 就指向 undo log</p><hr><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>插入到页面中的记录会根据 next_record 属性组成一个单向链表，这个链表称为正常链表，被删除的记录也会通过 next_record 组成一个垃圾链表，该链表中所占用的存储空间可以被重新利用，并不会直接清除数据</p><p>在页面 Page Header 中，PAGE_FREE 属性指向垃圾链表的头节点，删除的工作过程：</p><ul><li><p>将要删除的记录的 delete_flag 位置为 1，其他不做修改，这个过程叫 <strong>delete mark</strong></p></li><li><p>在事务提交前，delete_flag &#x3D; 1 的记录一直都会处于中间状态</p></li><li><p>事务提交后，有专门的线程将 delete_flag &#x3D; 1 的记录从正常链表移除并加入垃圾链表，这个过程叫 <strong>purge</strong></p><p>purge 线程在执行删除操作时会创建一个 ReadView，根据事务的可见性移除数据（隔离特性部分详解）</p></li></ul><p>当有新插入的记录时，首先判断 PAGE_FREE 指向的头节点是否足够容纳新纪录：</p><ul><li>如果可以容纳新纪录，就会直接重用已删除的记录的存储空间，然后让 PAGE_FREE 指向垃圾链表的下一个节点</li><li>如果不能容纳新纪录，就直接向页面申请新的空间存储，并不会遍历垃圾链表</li></ul><p>重用已删除的记录空间，可能会造成空间碎片，当数据页容纳不了一条记录时，会判断将碎片空间加起来是否可以容纳，判断为真就会重新组织页内的记录：</p><ul><li>开辟一个临时页面，将页内记录一次插入到临时页面，此时临时页面时没有碎片的</li><li>把临时页面的内容复制到本页，这样就解放出了内存碎片，但是会耗费很大的性能资源</li></ul><hr><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>执行 UPDATE 语句，对于更新主键和不更新主键有两种不同的处理方式</p><p>不更新主键的情况：</p><ul><li><p>就地更新（in-place update），如果更新后的列和更新前的列占用的存储空间一样大，就可以直接在原记录上修改</p></li><li><p>先删除旧纪录，再插入新纪录，这里的删除不是 delete mark，而是直接将记录加入垃圾链表，并且修改页面的相应的控制信息，执行删除的线程不是 purge，是执行更新的用户线程，插入新记录时可能造成页空间不足，从而导致页分裂</p></li></ul><p>更新主键的情况：</p><ul><li>将旧纪录进行 delete mark，在更新语句提交后由 purge 线程移入垃圾链表</li><li>根据更新的各列的值创建一条新纪录，插入到聚簇索引中</li></ul><p>在对一条记录修改前会<strong>将记录的隐藏列 trx_id 和 roll_pointer 的旧值记录到当前 undo log 对应的属性中</strong>，这样当前记录的 roll_pointer 指向当前 undo log 记录，当前 undo log 记录的 roll_pointer 指向旧的 undo log 记录，<strong>形成一个版本链</strong></p><p>UPDATE、DELETE 操作产生的 undo 日志会用于其他事务的 MVCC 操作，所以不能立即删除，INSERT 可以删除的原因是 MVCC 是对现有数据的快照</p><hr><h4 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h4><p>undo log 是采用段的方式来记录，Rollback Segement 称为回滚段，本质上就是一个类型是 Rollback Segement Header 的页面</p><p>每个回滚段中有 1024 个 undo slot，每个 slot 存放 undo 链表页面的头节点页号，每个链表对应一个叫 undo log segment 的段</p><ul><li>在以前老版本，只支持 1 个 Rollback Segement，只能记录 1024 个 undo log segment</li><li>MySQL5.5 开始支持 128 个 Rollback Segement，支持 128*1024 个 undo 操作</li></ul><p>工作流程：</p><ul><li><p>事务执行前需要到系统表空间第 5 号页面中分配一个回滚段（页），获取一个 Rollback Segement Header 页面的地址</p></li><li><p>回滚段页面有 1024 个 undo slot，首先去回滚段的两个 cached 链表获取缓存的 slot，缓存中没有就在回滚段页面中找一个可用的 undo slot 分配给当前事务</p></li><li><p>如果是缓存中获取的 slot，则该 slot 对应的 undo log segment 已经分配了，需要重新分配，然后从 undo log segment 中申请一个页面作为日志链表的头节点，并填入对应的 slot 中</p></li><li><p>每个事务 undo 日志在记录的时候<strong>占用两个 undo 页面的组成链表</strong>，分别为 insert undo 链表和 update undo 链表，链表的头节点页面为 first undo page 会包含一些管理信息，其他页面为 normal undo page</p><p>说明：事务执行过程的临时表也需要两个 undo 链表，不和普通表共用，这些链表并不是事务开始就分配，而是按需分配</p></li></ul><hr><h3 id="隔离特性"><a href="#隔离特性" class="headerlink" title="隔离特性"></a>隔离特性</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>隔离性是指，事务内部的操作与其他事务是隔离的，多个并发事务之间要相互隔离，不能互相干扰</p><ul><li><p>严格的隔离性，对应了事务隔离级别中的 serializable，实际应用中对性能考虑很少使用可串行化</p></li><li><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是<strong>不同事务</strong>之间的相互影响</p></li></ul><p>隔离性让并发情形下的事务之间互不干扰：</p><ul><li>一个事务的写操作对另一个事务的写操作（写写）：锁机制保证隔离性</li><li>一个事务的写操作对另一个事务的读操作（读写）：MVCC 保证隔离性</li></ul><p>锁机制：事务在修改数据之前，需要先获得相应的锁，获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁（详解见锁机制）</p><hr><h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>MVCC 全称 Multi-Version Concurrency Control，即多版本并发控制，用来<strong>解决读写冲突的无锁并发控制</strong>，可以在发生读写请求冲突时不用加锁解决，这个读是指的快照读（也叫一致性读或一致性无锁读），而不是当前读：</p><ul><li>快照读：实现基于 MVCC，因为是多版本并发，所以快照读读到的数据不一定是当前最新的数据，有可能是历史版本的数据</li><li>当前读：又叫加锁读，读取数据库记录是当前<strong>最新的版本</strong>（产生幻读、不可重复读），可以对读取的数据进行加锁，防止其他事务修改数据，是悲观锁的一种操作，读写操作加共享锁或者排他锁和串行化事务的隔离级别都是当前读</li></ul><p>数据库并发场景：</p><ul><li><p>读-读：不存在任何问题，也不需要并发控制</p></li><li><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p></li><li><p>写-写：有线程安全问题，可能会存在脏写（丢失更新）问题</p></li></ul><p>MVCC 的优点：</p><ul><li>在并发读写数据库时，做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了并发读写的性能</li><li>可以解决脏读，不可重复读等事务隔离问题（加锁也能解决），但不能解决更新丢失问题（写锁会解决）</li></ul><p>提高读写和写写的并发性能：</p><ul><li>MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突</li></ul><p>参考文章：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p><hr><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>实现原理主要是隐藏字段，undo日志，Read View 来实现的</p><p>InnoDB 存储引擎，数据库中的<strong>聚簇索引</strong>每行数据，除了自定义的字段，还有数据库隐式定义的字段：</p><ul><li>DB_TRX_ID：最近修改事务 ID，记录创建该数据或最后一次修改该数据的事务 ID</li><li>DB_ROLL_PTR：回滚指针，<strong>指向记录对应的 undo log 日志</strong>，undo log 中又指向上一个旧版本的 undo log</li><li>DB_ROW_ID：隐含的自增 ID（<strong>隐藏主键</strong>），如果数据表没有主键，InnoDB 会自动以 DB_ROW_ID 作为聚簇索引</li></ul><p><img src="/2024/01/14/shi-wu-ji-zhi-xiang-jie/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png"></p><hr><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>undo log 是逻辑日志，记录的是每个事务对数据执行的操作，而不是记录的全部数据，要<strong>根据 undo log 逆推出以往事务的数据</strong></p><p>undo log 的作用：</p><ul><li>保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复</li><li>用于 MVCC 快照读，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据</li></ul><p>undo log 主要分为两种：</p><ul><li><p>insert undo log：事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p></li><li><p>update undo log：事务在进行 update 或 delete 时产生的 undo log，在事务回滚时需要，在快照读时也需要。不能随意删除，只有在当前读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</p></li></ul><p>每次对数据库记录进行改动，都会产生的新版本的 undo log，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前的最新的 undo log，链尾就是最早的旧 undo log</p><p>说明：因为 DELETE 删除记录，都是移动到垃圾链表中，不是真正的删除，所以才可以通过版本链访问原始数据</p><img src="/2024/01/14/shi-wu-ji-zhi-xiang-jie/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE.png" style="zoom: 80%;"><p>注意：undo 是逻辑日志，这里只是直观的展示出来</p><p>工作流程：</p><ul><li>有个事务插入 persion 表一条新记录，name 为 Jerry，age 为 24</li><li>事务 1 修改该行数据时，数据库会先对该行加排他锁，然后先记录 undo log，然后修改该行 name 为 Tom，并且修改隐藏字段的事务 ID 为当前事务 1 的 ID（默认为 1 之后递增），回滚指针指向拷贝到 undo log 的副本记录，事务提交后，释放锁</li><li>以此类推</li></ul><hr><h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a>读视图</h5><p>Read View 是事务进行读数据操作时产生的读视图，该事务执行快照读的那一刻会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，用来做可见性判断，根据视图判断当前事务能够看到哪个版本的数据</p><p>注意：这里的快照并不是把所有的数据拷贝一份副本，而是由 undo log 记录的逻辑日志，根据库中的数据进行计算出历史数据</p><p>工作流程：将版本链的头节点的事务 ID（最新数据事务 ID，大概率不是当前线程）DB_TRX_ID 取出来，与系统当前活跃事务的 ID 对比进行可见性分析，不可见就通过 DB_ROLL_PTR 回滚指针去取出 undo log 中的下一个 DB_TRX_ID 比较，直到找到最近的满足可见性的 DB_TRX_ID，该事务 ID 所在的旧记录就是当前事务能看见的最新的记录</p><p>Read View 几个属性：</p><ul><li>m_ids：生成 Read View 时当前系统中活跃的事务 id 列表（未提交的事务集合，当前事务也在其中）</li><li>min_trx_id：生成 Read View 时当前系统中活跃的最小的事务 id，也就是 m_ids 中的最小值（已提交的事务集合）</li><li>max_trx_id：生成 Read View 时当前系统应该分配给下一个事务的 id 值，m_ids 中的最大值加 1（未开始事务）</li><li>creator_trx_id：生成该 Read View 的事务的事务 id，就是判断该 id 的事务能读到什么数据</li></ul><p>creator 创建一个 Read View，进行可见性算法分析：（解决了读未提交）</p><ul><li><p>db_trx_id &#x3D;&#x3D; creator_trx_id：表示这个数据就是当前事务自己生成的，自己生成的数据自己肯定能看见，所以此数据对 creator 是可见的</p></li><li><p>db_trx_id &lt;  min_trx_id：该版本对应的事务 ID 小于 Read view 中的最小活跃事务 ID，则这个事务在当前事务之前就已经被提交了，对 creator 可见（因为比已提交的最大事务 ID 小的并不一定已经提交，所以应该判断是否在活跃事务列表）</p></li><li><p>db_trx_id &gt;&#x3D; max_trx_id：该版本对应的事务 ID 大于 Read view 中当前系统的最大事务 ID，则说明该数据是在当前 Read view 创建之后才产生的，对 creator 不可见</p></li><li><p>min_trx_id&lt;&#x3D; db_trx_id &lt; max_trx_id：判断 db_trx_id 是否在活跃事务列表 m_ids 中</p><ul><li>在列表中，说明该版本对应的事务正在运行，数据不能显示（<strong>不能读到未提交的数据</strong>）</li><li>不在列表中，说明该版本对应的事务已经被提交，数据可以显示（<strong>可以读到已经提交的数据</strong>）</li></ul></li></ul><hr><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>表 user 数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">id</span>nameage<span class="token number">1</span>张三   <span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Transaction 20：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">START TRANSACTION;-- 开启事务UPDATE user SET name &#x3D; &#39;李四&#39; WHERE id &#x3D; 1;UPDATE user SET name &#x3D; &#39;王五&#39; WHERE id &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Transaction 60：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">START TRANSACTION;-- 开启事务-- 操作表的其他数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2024/01/14/shi-wu-ji-zhi-xiang-jie/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p><p>ID 为 0 的事务创建 Read View：</p><ul><li>m_ids：20、60</li><li>min_trx_id：20</li><li>max_trx_id：61</li><li>creator_trx_id：0</li></ul><p><img src="/2024/01/14/shi-wu-ji-zhi-xiang-jie/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p><p>只有红框部分才复合条件，所以只有张三对应的版本的数据可以被看到</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1t5411u7Fg">https://www.bilibili.com/video/BV1t5411u7Fg</a></p><hr><h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p>只有在聚簇索引中才有 trx_id 和 roll_pointer 的隐藏列，对于二级索引判断可见性的方式：</p><ul><li>二级索引页面的 Page Header 中有一个 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，SELECT 语句访问某个二级索引时会判断 ReadView 的 min_trx_id 是否大于该属性，大于说明该页面的所有属性对 ReadView 可见</li><li>如果属性判断不可见，就需要利用二级索引获取主键值进行<strong>回表操作</strong>，得到聚簇索引后按照聚簇索引的可见性判断的方法操作</li></ul><hr><h4 id="RC-RR"><a href="#RC-RR" class="headerlink" title="RC RR"></a>RC RR</h4><p>Read View 用于支持 RC（Read Committed，读已提交）和 RR（Repeatable Read，可重复读）隔离级别的实现，所以 <strong>SELECT 在 RC 和 RR 隔离级别使用 MVCC 读取记录</strong></p><p>RR、RC 生成时机：</p><ul><li>RC 隔离级别下，每次读取数据前都会生成最新的 Read View（当前读）</li><li>RR 隔离级别下，在第一次数据读取时才会创建 Read View（快照读）</li></ul><p>RC、RR 级别下的 InnoDB 快照读区别</p><ul><li><p>RC 级别下，事务中每次快照读都会新生成一个 Read View，这就是在 RC 级别下的事务中可以看到别的事务提交的更新的原因</p></li><li><p>RR 级别下，某个事务的对某条记录的<strong>第一次快照读</strong>会创建一个 Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，使用的是同一个 Read View，所以一个事务的查询结果每次都是相同的</p><p>RR 级别下，通过 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 开启事务，会在执行该语句后立刻生成一个 Read View，不是在执行第一条 SELECT 语句时生成（所以说 <code>START TRANSACTION</code> 并不是事务的起点，执行第一条语句才算起点）</p></li></ul><p>解决幻读问题：</p><ul><li><p>快照读：通过 MVCC 来进行控制的，在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，但是<strong>并不能完全避免幻读</strong></p><p>场景：RR 级别，T1 事务开启，创建 Read View，此时 T2 去 INSERT 新的一行然后提交，然后 T1 去 UPDATE 该行会发现更新成功，并且把这条新记录的 trx_id 变为当前的事务 id，所以对当前事务就是可见的。因为 <strong>Read View 并不能阻止事务去更新数据，更新数据都是先读后写并且是当前读</strong>，读取到的是最新版本的数据</p></li><li><p>当前读：通过 next-key 锁（行锁 + 间隙锁）来解决问题</p></li></ul><hr><h3 id="持久特性"><a href="#持久特性" class="headerlink" title="持久特性"></a>持久特性</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><p>持久性是指一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p><p>Buffer Pool 的使用提高了读写数据的效率，但是如果 MySQL 宕机，此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证，所以引入了 redo log 日志：</p><ul><li>redo log <strong>记录数据页的物理修改</strong>，而不是某一行或某几行的修改，用来恢复提交后的数据页，只能<strong>恢复到最后一次提交</strong>的位置</li><li>redo log 采用的是 WAL（Write-ahead logging，<strong>预写式日志</strong>），所有修改要先写入日志，再更新到磁盘，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求</li><li>简单的 redo log 是纯粹的物理日志，复杂的 redo log 会存在物理日志和逻辑日志</li></ul><p>工作过程：MySQL 发生了宕机，InnoDB 会判断一个数据页在崩溃恢复时丢失了更新，就会将它读到内存，然后根据 redo log 内容更新内存，更新完成后，内存页变成脏页，然后进行刷脏</p><p>缓冲池的<strong>刷脏策略</strong>：</p><ul><li>redo log 文件是固定大小的，如果写满了就要擦除以前的记录，在擦除之前需要把对应的更新持久化到磁盘中</li><li>Buffer Pool 内存不足，需要淘汰部分数据页（LRU 链表尾部），如果淘汰的是脏页，就要先将脏页写到磁盘（要避免大事务）</li><li>系统空闲时，后台线程会自动进行刷脏（Flush 链表部分已经详解）</li><li>MySQL 正常关闭时，会把内存的脏页都刷新到磁盘上</li></ul><hr><h4 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h4><h5 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h5><p>服务器启动时会向操作系统申请一片连续内存空间作为 redo log buffer（重做日志缓冲区），可以通过 <code>innodb_log_buffer_size</code> 系统变量指定 redo log buffer 的大小，默认是 16MB</p><p>log buffer 被划分为若干 redo log block（块，类似数据页的概念），每个默认大小 512 字节，每个 block 由 12 字节的 log block head、496 字节的 log block body、4 字节的 log block trailer 组成</p><ul><li>当数据修改时，先修改 Change Buffer 中的数据，然后在 redo log buffer 记录这次操作，写入 log buffer 的过程是<strong>顺序写入</strong>的（先写入前面的 block，写满后继续写下一个）</li><li>log buffer 中有一个指针 buf_free，来标识该位置之前都是填满的 block，该位置之后都是空闲区域</li></ul><p>MySQL 规定对底层页面的一次原子访问称为一个 Mini-Transaction（MTR），比如在 B+ 树上插入一条数据就算一个 MTR</p><ul><li><p>一个事务包含若干个 MTR，一个 MTR 对应一组若干条 redo log，一组 redo log 是不可分割的，在进行数据恢复时也把一组 redo log 当作一个不可分割的整体处理</p></li><li><p>不是每生成一条 redo 日志就将其插入到 log buffer 中，而是一个 MTR 结束后<strong>将一组 redo 日志写入</strong></p></li></ul><p>InnoDB 的 redo log 是<strong>固定大小</strong>的，redo 日志在磁盘中以文件组的形式存储，同一组中的每个文件大小一样格式一样</p><ul><li><code>innodb_log_group_home_dir</code> 代表磁盘存储 redo log 的文件目录，默认是当前数据目录</li><li><code>innodb_log_file_size</code> 代表文件大小，默认 48M，<code>innodb_log_files_in_group</code> 代表文件个数，默认 2 最大 100，所以日志的文件大小为 <code>innodb_log_file_size * innodb_log_files_in_group</code></li></ul><p>redo 日志文件也是由若干个 512 字节的 block 组成，日志文件的前 2048 个字节（前 4 个 block）用来存储一些管理信息，以后的用来存储 log buffer 中的 block 镜像</p><p>注意：block 并不代表一组 redo log，一组日志可能占用不到一个 block 或者几个 block，依赖于 MTR 的大小</p><hr><h5 id="日志刷盘"><a href="#日志刷盘" class="headerlink" title="日志刷盘"></a>日志刷盘</h5><p>redo log 需要在事务提交时将日志写入磁盘，但是比 Buffer Pool 修改的数据写入磁盘的速度快，原因：</p><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机；redo log 和 binlog 都是<strong>顺序写</strong>，磁盘的顺序 IO 比随机 IO 速度要快</li><li>刷脏是以数据页（Page）为单位的，一个页上的一个小修改都要整页写入；redo log 中只包含真正需要写入的部分，好几页的数据修改可能只记录在一个 redo log 页中，减少无效 IO</li><li><strong>组提交机制</strong>，可以大幅度降低磁盘的 IO 消耗</li></ul><p>InnoDB 引擎会在适当的时候，把内存中 redo log buffer 持久化（fsync）到磁盘，具体的<strong>刷盘策略</strong>：</p><ul><li>在事务提交时需要进行刷盘，通过修改参数 <code>innodb_flush_log_at_trx_commit</code> 设置：<ul><li>0：表示当提交事务时，并不将缓冲区的 redo 日志写入磁盘，而是等待<strong>后台线程每秒刷新一次</strong></li><li>1：在事务提交时将缓冲区的 redo 日志<strong>同步写入</strong>到磁盘，保证一定会写入成功（默认值）</li><li>2：在事务提交时将缓冲区的 redo 日志异步写入到磁盘，不能保证提交时肯定会写入，只是有这个动作。日志已经在操作系统的缓存，如果操作系统没有宕机而 MySQL 宕机，也是可以恢复数据的</li></ul></li><li>写入 redo log buffer 的日志超过了总容量的一半，就会将日志刷入到磁盘文件，这会影响执行效率，所以开发中应<strong>避免大事务</strong></li><li>服务器关闭时</li><li>并行的事务提交（组提交）时，会将将其他事务的 redo log 持久化到磁盘。假设事务 A 已经写入 redo log  buffer 中，这时另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么事务 B 要把 redo log buffer 里的日志全部持久化到磁盘，<strong>因为多个事务共用一个 redo log buffer</strong>，所以一次 fsync 可以刷盘多个事务的 redo log，提升了并发量</li></ul><p>服务器启动后 redo 磁盘空间不变，所以 redo 磁盘中的日志文件是被<strong>循环使用</strong>的，采用循环写数据的方式，写完尾部重新写头部，所以要确保头部 log 对应的修改已经持久化到磁盘</p><hr><h5 id="日志序号"><a href="#日志序号" class="headerlink" title="日志序号"></a>日志序号</h5><p>lsn (log sequence number) 代表已经写入的 redo 日志量、flushed_to_disk_lsn 指刷新到磁盘中的 redo 日志量，两者都是<strong>全局变量</strong>，如果两者的值相同，说明 log buffer 中所有的 redo 日志都已经持久化到磁盘</p><p>工作过程：写入 log buffer 数据时，buf_free 会进行偏移，偏移量就会加到 lsn 上</p><p>MTR 的执行过程中修改过的页对应的控制块会加到 Buffer Pool 的 flush 链表中，链表中脏页是按照第一次修改的时间进行排序的（头插），控制块中有两个指针用来记录脏页被修改的时间：</p><ul><li>oldest_modification：第一次修改 Buffer Pool 中某个缓冲页时，将修改该页的 MTR <strong>开始时</strong>对应的 lsn 值写入这个属性</li><li>newest_modification：每次修改页面，都将 MTR 结束时全局的 lsn 值写入这个属性，所以该值是该页面最后一次修改后的 lsn 值</li></ul><p>全局变量 checkpoint_lsn 表示<strong>当前系统可以被覆盖的 redo 日志总量</strong>，当 redo 日志对应的脏页已经被刷新到磁盘后，该文件空间就可以被覆盖重用，此时执行一次 checkpoint 来更新 checkpoint_lsn 的值存入管理信息（刷脏和执行一次 checkpoint 并不是同一个线程），该值的增量就代表磁盘文件中当前位置向后可以被覆盖的文件的量，所以该值是一直增大的</p><p><strong>checkpoint</strong>：从 flush 链表尾部中找出还未刷脏的页面，该页面是当前系统中最早被修改的脏页，该页面之前产生的脏页都已经刷脏，然后将该页 oldest_modification 值赋值给 checkpoint_lsn，因为 lsn 小于该值时产生的 redo 日志都可以被覆盖了</p><p>但是在系统忙碌时，后台线程的刷脏操作不能将脏页快速刷出，导致系统无法及时执行 checkpoint ，这时需要用户线程从 flush 链表中把最早修改的脏页刷新到磁盘中，然后执行 checkpoint</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">write pos <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> checkpoint_lsn <span class="token comment">// 两值之间的部分表示可以写入的日志量，当 pos 追赶上 lsn 时必须执行 checkpoint</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用命令可以查看当前 InnoDB 存储引擎各种 lsn 的值：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW ENGINE INNODB STATUS\G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h5 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h5><p>恢复的起点：在从 redo 日志文件组的管理信息中获取最近发生 checkpoint 的信息，<strong>从 checkpoint_lsn 对应的日志文件开始恢复</strong></p><p>恢复的终点：扫描日志文件的 block，block 的头部记录着当前 block 使用了多少字节，填满的 block 总是 512 字节， 如果某个 block 不是 512 字节，说明该 block 就是需要恢复的最后一个 block</p><p>恢复的过程：按照 redo log 依次执行恢复数据，优化方式</p><ul><li>使用哈希表：根据 redo log 的 space id 和 page number 属性计算出哈希值，将对同一页面的修改放入同一个槽里，可以一次性完成对某页的恢复，<strong>避免了随机 IO</strong></li><li>跳过已经刷新到磁盘中的页面：数据页的 File Header 中的 FILE_PAGE_LSN 属性（类似 newest_modification）表示最近一次修改页面时的 lsn 值，数据页被刷新到磁盘中，那么该页 lsn 属性肯定大于 checkpoint_lsn</li></ul><p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p><hr><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="日志对比"><a href="#日志对比" class="headerlink" title="日志对比"></a>日志对比</h5><p>MySQL 中还存在 binlog（二进制日志）也可以记录写操作并用于数据的恢复，<strong>保证数据不丢失</strong>，二者的区别是：</p><ul><li>作用不同：redo log 是用于 crash recovery （故障恢复），保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制</li><li>层次不同：redo log 是 InnoDB 存储引擎实现的，而 binlog 是MySQL的 Server 层实现的，同时支持 InnoDB 和其他存储引擎</li><li>内容不同：redo log 是物理日志，内容基于磁盘的 Page；binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于SQL 语句、基于数据本身或者二者的混合（日志部分详解）</li><li>写入时机不同：binlog 在事务提交时一次写入；redo log 的写入时机相对多元</li></ul><p>binlog 为什么不支持崩溃恢复？</p><ul><li>binlog 记录的是语句，并不记录数据页级的数据（哪个页改了哪些地方），所以没有能力恢复数据页</li><li>binlog 是追加写，保存全量的日志，没有标志确定从哪个点开始的数据是已经刷盘了，而 redo log 只要在 checkpoint_lsn 后面的就是没有刷盘的</li></ul><hr><h5 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h5><p>更新一条记录的过程：写之前一定先读</p><ul><li><p>在 B+ 树中定位到该记录，如果该记录所在的页面不在 Buffer Pool 里，先将其加载进内存</p></li><li><p>首先更新该记录对应的聚簇索引，更新聚簇索引记录时：</p><ul><li><p>更新记录前向 undo 页面写 undo 日志，由于这是更改页面，所以需要记录一下相应的 redo 日志</p><p>注意：修改 undo 页面也是在<strong>修改页面</strong>，事务只要修改页面就需要先记录相应的 redo 日志</p></li><li><p>然后<strong>记录对应的 redo 日志</strong>（等待 MTR 提交后写入 redo log buffer），<strong>最后进行真正的更新记录</strong></p></li></ul></li><li><p>更新其他的二级索引记录，不会再记录 undo log，只记录 redo log 到 buffer 中</p></li><li><p>在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就会开始记录该语句对应的 binlog 日志，此时记录的 binlog 并没有刷新到硬盘上，还在内存中，在事务提交时才会统一将该事务运行过程中的所有 binlog 日志刷新到硬盘</p></li></ul><p>假设表中有字段 id 和 a，存在一条 <code>id = 1, a = 2</code> 的记录，此时执行更新语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">table</span> <span class="token keyword">set</span> a<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>InnoDB 会真正的去执行把值修改成 (1,2) 这个操作，先加行锁，在去更新，并不会提前判断相同就不修改了</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA">https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA</a></p><hr><h5 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h5><p>当客户端执行 COMMIT 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> T <span class="token keyword">set</span> c<span class="token operator">=</span>c<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2024/01/14/shi-wu-ji-zhi-xiang-jie/MySQL-update%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" style="zoom: 33%;"><p>流程说明：执行引擎将这行新数据读入到内存中（Buffer Pool）后，先将此次更新操作记录到 redo log buffer 里，然后更新记录。最后将 redo log 刷盘后事务处于 prepare 状态，执行器会生成这个操作的 binlog，并<strong>把 binlog 写入磁盘</strong>，完成提交</p><p>两阶段：</p><ul><li>Prepare 阶段：存储引擎将该事务的 <strong>redo 日志刷盘</strong>，并且将本事务的状态设置为 PREPARE，代表执行完成随时可以提交事务</li><li>Commit 阶段：先将事务执行过程中产生的 binlog 刷新到硬盘，再执行存储引擎的提交工作，引擎把 redo log 改成提交状态</li></ul><p>存储引擎层的 redo log 和 server 层的 binlog 可以认为是一个分布式事务， 都可以用于表示事务的提交状态，而<strong>两阶段提交就是让这两个状态保持逻辑上的一致</strong>，也有利于主从复制，更好的保持主从数据的一致性</p><hr><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>系统崩溃前没有提交的事务的 redo log 可能已经刷盘（定时线程或者 checkpoint），怎么处理崩溃恢复？</p><p>工作流程：获取 undo 链表首节点页面的 undo segement header 中的 TRX_UNDO_STATE 属性，表示当前链表的事务属性，<strong>事务状态是活跃（未提交）的就全部回滚</strong>，如果是 PREPARE 状态，就需要根据 binlog 的状态进行判断：</p><ul><li>如果在时刻 A 发生了崩溃（crash），由于此时 binlog 还没完成，所以需要进行回滚</li><li>如果在时刻 B 发生了崩溃，redo log 和 binlog 有一个共<strong>同的数据字段叫 XID</strong>，崩溃恢复的时候，会按顺序扫描 redo log：<ul><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，说明 binlog 也已经记录完整，直接从 redo log 恢复数据</li><li>如果 redo log 里面的事务只有 prepare，就根据 XID 去 binlog 中判断对应的事务是否存在并完整，如果完整可以恢复数据</li></ul></li></ul><p>判断一个事务的 binlog 是否完整的方法：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT</li><li>row 格式的 binlog，最后会有一个 XID event</li><li>MySQL 5.6.2 版本以后，引入了 binlog-checksum 参数用来验证 binlog 内容的正确性（可能日志中间出错）</li></ul><p>参考文章：<a href="https://time.geekbang.org/column/article/73161">https://time.geekbang.org/column/article/73161</a></p><hr><h4 id="刷脏优化"><a href="#刷脏优化" class="headerlink" title="刷脏优化"></a>刷脏优化</h4><p>系统在进行刷脏时会占用一部分系统资源，会影响系统的性能，<strong>产生系统抖动</strong></p><ul><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li></ul><p>InnoDB 刷脏页的控制策略：</p><ul><li><code>innodb_io_capacity</code> 参数代表磁盘的读写能力，建议设置成磁盘的 IOPS（每秒的 IO 次数）</li><li>刷脏速度参考两个因素：脏页比例和 redo log 写盘速度<ul><li>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%，InnoDB 会根据当前的脏页比例，算出一个范围在 0 到 100 之间的数字</li><li>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，InnoDB 根据差值算出一个范围在 0 到 100 之间的数字</li><li>两者较大的值记为 R，执行引擎按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度</li></ul></li><li><code>innodb_flush_neighbors</code> 参数置为 1 代表控制刷脏时检查相邻的数据页，如果也是脏页就一起刷脏，并检查邻居的邻居，这个行为会一直蔓延直到不是脏页，在 MySQL 8.0 中该值的默认值是 0，不建议开启此功能</li></ul><hr><h3 id="一致特性"><a href="#一致特性" class="headerlink" title="一致特性"></a>一致特性</h3><p>一致性是指事务执行前后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）</p><p>实现一致性的措施：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql底层索引为什么是b+树？</title>
      <link href="/2024/01/11/mysql-di-ceng-suo-yin-wei-shi-me-shi-b-shu/"/>
      <url>/2024/01/11/mysql-di-ceng-suo-yin-wei-shi-me-shi-b-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1.什么是索引?"></a>1.什么是索引?</h3><ul><li>索引是帮助mysql高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></li><li>索引是存储在文件里的</li></ul><p>如果没有索引的话，就得循环一条一条的找，找一次就是一次IO，这样速度就会很慢。并且数据库的数据都是存在磁盘中的，我们从磁盘中取数据，每取一次就是一次IO，IO是非常耗时的。</p><p>如果没有索引，当我们查找第7条数据时，就会循环7次，如果有百万级别的数据，那么就会查找百万次，显然这样是不行的，就需要数据结构算法来优化。</p><h3 id="2-为什么不用二叉搜索树-BST-？"><a href="#2-为什么不用二叉搜索树-BST-？" class="headerlink" title="2.为什么不用二叉搜索树(BST)？"></a>2.为什么不用二叉搜索树(BST)？</h3><p>二叉树节点保存的都是单个索引，高度会随着数据增大而增高，但是比一条一条的循环会快。</p><img src="/2024/01/11/mysql-di-ceng-suo-yin-wei-shi-me-shi-b-shu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240429104938.jpg" style="zoom:80%;"><img src="/2024/01/11/mysql-di-ceng-suo-yin-wei-shi-me-shi-b-shu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240429105015.jpg" style="zoom:80%;"><p>不用二叉树是因为极端情况下会出现单边增长，退化成了链表，这样在数量大的情况下，和一条一条查找没有区别。</p><h3 id="3-为什么不用红黑树"><a href="#3-为什么不用红黑树" class="headerlink" title="3.为什么不用红黑树?"></a>3.为什么不用红黑树?</h3><p><strong>红黑树有自平衡性质</strong>，不会出现单边增长，它会动态自旋转，在性能上比二叉树又高一点，但是mysql也没有用这种数据结构，因为数据量超大的情况下，数据高度也会一直增大，在最终这个树高度也非常大，解决不了根本问题。</p><p><img src="/2024/01/11/mysql-di-ceng-suo-yin-wei-shi-me-shi-b-shu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240429105409.jpg"></p><h3 id="4-为什么不用HASH表？"><a href="#4-为什么不用HASH表？" class="headerlink" title="4.为什么不用HASH表？"></a>4.为什么不用HASH表？</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。hash算法一次就会定位到文件指针，速度快，但是还是没有用，如果范围查找的话就没有办法了。</p><p>如果只是内存中的话，他的时间复杂度是O(1),速度会会很快，但是索引文件也是保存在磁盘上，而且hash是不连续的放在磁盘上的，这样查询起来也很慢，这才是不用hash的最根本原因。</p><h3 id="5-为什么不用B树，而是使用了B-树"><a href="#5-为什么不用B树，而是使用了B-树" class="headerlink" title="5.为什么不用B树，而是使用了B+树"></a>5.为什么不用B树，而是使用了B+树</h3><p>相比上面的数据结构，b树增加了横向大小（度Degree），那么在高度上就减小了，查找次数就少了。</p><p>b树，也称为b-树，全称<strong>多路平衡查找树</strong>，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B树或其变种 B+树作为索引结构。</p><p><strong>B树和B+树有何异同？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的；B+树的叶子节点按照key大小顺序排列，有一条指针指相邻的叶子节点，形成了一个链表</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>mysql取一次数据一般是<strong>16K</strong>，所以节点一般设置为<strong>16K</strong>。一个节点设置成16K并且保存了索引和data的话，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-树的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率，所以引才使用了B+树。而且B+树在进行范围查找时效率也更高。</p><p><strong>总结：</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-树的深度较大，增大查询时的磁盘 I&#x2F;O 次数</li><li>B 树的叶子节点都是独立的；B+树的叶子节点按照key大小顺序排列，有一条指针指相邻的叶子节点，形成了一个链表。在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。因此B+树在进行范围查找时效率更高。</li></ul><h3 id="6-MyISAM和InnoDB实现B-树的比较"><a href="#6-MyISAM和InnoDB实现B-树的比较" class="headerlink" title="6.MyISAM和InnoDB实现B+树的比较"></a>6.MyISAM和InnoDB实现B+树的比较</h3><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。</p><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据文件的地址，<strong>索引文件和数据文件是分离的</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址。在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。所以建议选用数据小的主键字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。自增主键的插入数据模式，可以让主键索引尽量地保持递增顺序插入，不涉及到挪动其他记录，<strong>避免了页分裂</strong>，页分裂的目的就是保证后一个数据页中的所有行主键值比前一个数据页中主键值大</p><h3 id="7-联合索引要满足最左原则"><a href="#7-联合索引要满足最左原则" class="headerlink" title="7.联合索引要满足最左原则"></a>7.联合索引要满足最左原则</h3><p>联合索引(col1, col2, col3)也是一棵B+树，其非叶子节点存储的是第一个关键字的索引，而叶子节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1-col2-col3的顺序进行排序。</p><img src="/2024/01/11/mysql-di-ceng-suo-yin-wei-shi-me-shi-b-shu/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240429153558.jpg" style="zoom:80%;"><p>例如：</p><p>如果执行: SELECT * FROM T WHERE B&#x3D;‘赵六’ AND C&#x3D;123;</p><p>那么无法使用索引，因为索引是用A字段先排序的，如果没有先确定A，直接查找B和C，那么将会是全表查询。</p><p>如果执行: SELECT * FROM T WHERE A&#x3D;‘30’ ;</p><p>那么，会先找到A字段，再在A等于30的数据中（比如有很多条），找B等于DE的数据。这样是可以用到索引的</p><p>如果执行: SELECT * FROM T WHERE A&#x3D;‘18’ AND C&#x3D;345;</p><p>那么，A字段可以索引，而C不能索引。所以可以部分索引，也比全表查询快</p><p>如果执行 : SELECT * FROM T WHERE B&#x3D;DE AND C&#x3D;1234 and A&#x3D;‘2’</p><p>是用到索引的，在and的情况下如果把第一个放到最后位置也是能用到索引的</p><p>现在我想大家应该了解了什么为什么是最左原则。因为，B+树是按照最左边的字段以此构建的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解HTTPS协议</title>
      <link href="/2023/12/26/shen-ru-li-jie-https-xie-yi/"/>
      <url>/2023/12/26/shen-ru-li-jie-https-xie-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是安全？"><a href="#1-什么是安全？" class="headerlink" title="1.什么是安全？"></a>1.什么是安全？</h3><p>在通信过程中，具备以下特性则认为安全：<strong>机密性、完整性、不可否认、身份认证</strong></p><ul><li>机密性：数据必须保密，只能有信任的人读取，其他人是不可见的秘密。通俗的说：就是不能让不相关的人看到不该看的东西。</li><li>也叫作一致性，也就是数据在传输过程中没有被非法篡改，内容不能多也不能少，一五一十的保持原状。</li><li>不可否认：也叫做不可抵赖，不能否认已经发生过的事情</li><li>身份验证：也就是确认对方的真实身份，“证明你是真的是你”，保证消息发送到可信的人</li></ul><p>同时具备了机密性、完整性、身份认证、不可够人四个特性，通信双方的安全才有保证，才是真正的安全。</p><hr><h3 id="2-什么是HTTPS"><a href="#2-什么是HTTPS" class="headerlink" title="2.什么是HTTPS"></a>2.什么是HTTPS</h3><p>https就是为http增加了上面所说的4大安全特性。</p><p>https的请求 - 应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用 HTTP，没有任何新的东西。唯一的差别就是端口号不同（https端口号为43）、去掉明文传输。</p><h4 id="那么https是如何保证通信安全的呢？或者说是如何给http协议增加了4大安全特性。"><a href="#那么https是如何保证通信安全的呢？或者说是如何给http协议增加了4大安全特性。" class="headerlink" title="那么https是如何保证通信安全的呢？或者说是如何给http协议增加了4大安全特性。"></a>那么https是如何保证通信安全的呢？或者说是如何给http协议增加了4大安全特性。</h4><p>他在 TCP&#x2F;IP 与 HTTP 之间加上了 SSL&#x2F;TLS ，从原来的 <strong>HTTP over TCP&#x2F;IP</strong> 变成了 <strong>HTTP over SSL&#x2F;TLS</strong>，让 HTTP 运行在 安全的 SSL&#x2F;TLS 协议上。</p><p><img src="/2023/12/26/shen-ru-li-jie-https-xie-yi/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240419161729.png"></p><p>所以重点就是去掌握 SSL&#x2F;TLS 到底是什么</p><hr><h3 id="3-什么是SSL-TLS？"><a href="#3-什么是SSL-TLS？" class="headerlink" title="3.什么是SSL&#x2F;TLS？"></a>3.什么是SSL&#x2F;TLS？</h3><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，SSL发展到v3版本时已经证明了它是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。</p><hr><h3 id="4-怎么保证机密性的？"><a href="#4-怎么保证机密性的？" class="headerlink" title="4.怎么保证机密性的？"></a>4.怎么保证机密性的？</h3><h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><p>前面提到四个实现安全的必要条件，先说 <strong>机密性</strong>，也就是消息只能给想给的人看到并且看得懂。实现机密性的手段就是 <strong>加密（encrypt）</strong></p><p>加密算法通常有两大类：对称加密和非对称加密。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>加密和解密使用的密钥都是同一个，是 “对称的”。双方只要保证不会有泄露其他人知道这个密钥，通信就具有机密性。</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>对称加密的最大问题就是如何安全的把密钥传递对方，专业术语 “<strong>密钥交换</strong>”。所以非对称加密诞生了。由两个密钥组成，分别是 <strong>公钥（public key）</strong> 和 “<strong>私钥（private key）</strong>”，两个密钥是不一样的，这也就是不对称的由来，公钥可以任何人使用，私钥则自己保密。</p><blockquote><p>这里需要注意的是：公钥和私钥都可以用来加密解密，公钥加密的密文只能用私钥解密，反之亦然。</p></blockquote><p>服务端保存私钥，在互联网上分发公钥，当访问服务器网站的时候使用授予的公钥加密明文即可，服务端则使用对应的私钥来解密。</p><h4 id="是否可以直接使用非对称加密来实现机密性呢？"><a href="#是否可以直接使用非对称加密来实现机密性呢？" class="headerlink" title="是否可以直接使用非对称加密来实现机密性呢？"></a>是否可以直接使用非对称加密来实现机密性呢？</h4><p>答案是否定的。因为非对称加密运算速度比较慢。所以需要两者结合，混合模式实现机密性问题，同时又有很好的性能。</p><p>加密流程如下所示：</p><ol><li>先创建一个随机数的对称加密密钥，<strong>会话密钥（session key）</strong>；</li><li>接着再使用非对称加密的公钥对<strong>会话密钥</strong>加密，因为会话密钥很短，通常只有 16 字节或 32 字节，所以加密也不会太慢。<strong>这里主要就是解决了非对称加密的性能问题，实现了会话密钥的机密交换。</strong></li><li>另一方接收到密文后使用非对称加密的<strong>私钥</strong>解密出上一步加密的 <strong>会话密钥</strong>，此时就只有通信双方有会话秘钥，接着后面的会话都使用这个对称秘钥来加密解密，这样就保证了通信的性能。</li></ol><p><strong>总结一下就是使用非对称加密算法来加密会话密钥，使用对称加密算法来加密消息明文，接收方则使用非对称加密算法的私钥解密出会话密钥，再利用会话密钥解密消息密文。</strong></p><p>这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。</p><hr><h3 id="5-怎么保证完整性的？"><a href="#5-怎么保证完整性的？" class="headerlink" title="5.怎么保证完整性的？"></a>5.怎么保证完整性的？</h3><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>摘要算法的主要目的就是实现完整性。我们可以简单理解成它是一种特殊的压缩算法，将任意长度的明文数据处理成固定长度、又是独一无二的“<strong>摘要</strong>”字符串，就是该数据的指纹。</p><p><strong>同时摘要算法是单向加密算法，没有密钥，加密后的数据也无法解密，也就是不能从“摘要”推导出明文。</strong></p><p>比如我们听过或者用过的 <code>MD5（Message-Digest 5）</code>、<code>SHA-1（Secure Hash Algorithm 1）</code>，它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。</p><h4 id="完整性的实现"><a href="#完整性的实现" class="headerlink" title="完整性的实现"></a>完整性的实现</h4><p>有了摘要算法生成的数字摘要，那么我们只需要在明文数据附上对应的摘要，就能保证数据的完整性。</p><p>但是由于摘要算法不具有机密性，不能明文传输，否则黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。</p><p>所以完整性还是要建立在机密性上，我们结合之前提到的混合加密使用 ”会话密钥“ 加密明文消息 + 摘要，这样的话黑客也就无法得到明文，无法做修改了。这里有个专业术语叫“哈希消息认证码（HMAC）”。</p><p><img src="/2023/12/26/shen-ru-li-jie-https-xie-yi/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240419165007.png"></p><p>比如诸葛亮使用上面提到的混合加密过程给关二爷发消息：“明天攻城” + “SHA-2 摘要”，关二爷收到后使用密钥将解密出来的会话密钥解密出明文消息，同时对明文消息使用解密出来的摘要算法进行摘要计算，接着比对两份“摘要”字符串是否一致，如果一致就说明消息完整可信，没有被敌军修改过。</p><p>总结下就是通过摘要比对防止篡改，同时利用混合加密实现密文与摘要的安全传输。</p><hr><h3 id="6-怎么实现身份认证和不可否认"><a href="#6-怎么实现身份认证和不可否认" class="headerlink" title="6.怎么实现身份认证和不可否认"></a>6.怎么实现身份认证和不可否认</h3><p>主要是通过“<strong>数字签名</strong>”，同时实现“身份认证”和“不可否认”。</p><p>就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。</p><p><strong>重点就是使用非对称加密的“私钥”加密原文的摘要，对方则使用非对称加密的公钥解密出摘要，再比对解密出的原文通过摘要算法计算摘要与解密出的摘要比对是否一致</strong>。这样就能像签署文件一样证明消息确实是你发送的。</p><p><img src="/2023/12/26/shen-ru-li-jie-https-xie-yi/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240419170223.png"></p><p>只要你和网站互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。</p><h4 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h4><p>到这里似乎已经大功告成，可惜还不是。</p><p>综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，是不是已经完美了呢？</p><p>不是的，这里还有一个“<strong>公钥的信任</strong>”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段。</p><p>这个“第三方”就是我们常说的<strong>CA</strong>（Certificate Authority，证书认证机构）。它就像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。</p><p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“<strong>数字证书</strong>”（Certificate）。</p><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>从什么是安全我们延展出 HTTPS，解释了什么是 HTTPS，以及与 HTTP 的区别。HTTPS 主要就是通过 SSL&#x2F;TLS 实现安全，而安全我们又接触了什么是对称加密与非对称加密，非对称加密性能较弱，所以我们使用非对称加密来加密对称加密的“会话密钥”，利用会话密钥加密明文解决了性能问题。</p><p>通过混合加密实现了机密性，利用摘要算法实现了完整性，通过数字签名使用非对称加密的“私钥”加密原文的摘要，对方则使用非对称加密的公钥解密出摘要，再比对解密出的原文通过摘要算法计算摘要与解密出的摘要比对是否一致实现了身份认证与不可否认。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析进程通信</title>
      <link href="/2023/12/23/qian-xi-jin-cheng-tong-xin/"/>
      <url>/2023/12/23/qian-xi-jin-cheng-tong-xin/</url>
      
        <content type="html"><![CDATA[<p>首先我们要知道，进程通信需要操作系统支持，因为各进程拥有的<strong>内存地址空间相互独立</strong>，为了保证安全，一个进程不能直接访问另一个进程的地址空间安全。</p><p>进程间通信的方式有三种：管道通信，共享存储，消息队列。</p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道又分为<strong>匿名管道</strong>和<strong>命名管道</strong>。</p><p>匿名管道本质上是内存中一片固定大小的缓冲区，当我们通过系统调用创建了匿名管道，会返回一个写入段描述符<code>fd[0]</code>和读取端描述符<code>fd[1]</code>。我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p>命名管道本质上是在文件系统创建了一个设备文件，不同的进程就可以通过这个文件实现相互通信。</p><p>管道是一种经典的BIO方式，是半双工的，某一时间段内只能单向传输。如果要实现双向同时传输，则需要设置两个管道。当<strong>管道写满时</strong>，写进程会阻塞，直到读进程将管道内的数据取走。当<strong>管道读空</strong>时，读进程会阻塞，直到写进程向管道中写入数据，即可唤醒写进程。</p><blockquote><p>这种方式效率很低，不适合进程间的频繁数据交换，好处就是简单</p></blockquote><hr><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是经典的消息传递的方式,其本质上是<code>生产者-消费者</code>的模型</p><p>在Linux中，消息队列是保存在内核中的消息链表，在发送数据的时候，会分成一个个的数据单元，消息的发送方和接收方要固定好消息体的格式,所以每个消息都是固定大小的数据块,而不像是无序的字节。所以消息队列不适合传输比较大的数据，比如在<code>Linux</code>中定义了<code>MSGMAX</code>和<code>MAGMNB</code>，他们分别定义了消息最大长度和消息队列的最大长度。</p><p>如果消息队列中的数据被读取了,那么内核就会把这个消息体给删除</p><p><strong>消息队列的生命周期是随内核的</strong>,当内核不释放消息队列时,那么直到系统关闭或者宕机的时候消息队列才会被释放。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><hr><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>由于消息队列存在用户态和内存态之间的数据拷贝开销，所以原生的消息队列的性能是比较差的。</p><p><code>共享内存技术</code>:简单来说,就是基于<code>虚拟内存</code>机制,将不同虚拟地址空间,映射到同一块物理内存,这样的话两个进程对自己的虚拟内存进行操作,实际上改变的是共享区域中的内存数据。</p><hr><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>注意到共享内存的读写,它实际上涉及到了一个<code>临界资源</code>的访问问题,所谓临界资源就是多个进程&#x2F;线程都能够读取到的一段共享数据,那么在并发的情况下,就会导致<code>并发下的数据安全问题</code></p><p>为了防止多进程竞争共享资源,一般有悲观锁和乐观锁的实现机制,乐观锁是基于一种机器原子指令<code>CAS</code>实现的,而悲观锁的实现方式通常有<code>信号量</code></p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p><strong>基于信号量实现的互斥，初始化为1</strong></p><p>在对资源进行访问前，进行加锁</p><ul><li>如果信号量为1，执行P操作后变为0，表示资源可用</li><li>如果执行P操作后信号量&lt;0，那么这个线程将被阻塞，并且被注册到监视这个信号量的监视器所对应的同步队列中</li></ul><p>当退出对资源的访问的时候,进行解锁</p><ul><li>如果执行V操作后信号量&lt;&#x3D;0，那么就唤醒同步队列阻塞中一个线程</li></ul><p><strong>基于信号量实现的同步，初始化为0</strong></p><p>同步,比如说要保证A进程在B进程之前执行，我们把P操作放在B进程，V操作放在A进程。</p><p>B要取数据，那么就会执行P操作，使信号量变为-1，那么B被阻塞,。只有当A生产数据后，执行V操作使信号量变为0，B就被唤醒。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ常见面试题</title>
      <link href="/2023/12/22/rocketmq-chang-jian-mian-shi-ti/"/>
      <url>/2023/12/22/rocketmq-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-如何保证顺序消费？"><a href="#1-如何保证顺序消费？" class="headerlink" title="1.如何保证顺序消费？"></a>1.如何保证顺序消费？</h3><p>在生产中经常会有一些类似报表系统这样的系统，需要做 MySQL 的 binlog 同步。比如订单系统要同步订单表的数据到大数据部门的 MySQL 库中用于报表统计分析，通常的做法是基于 Canal 这样的中间件去监听订单数据库的 binlog，然后把这些 binlog 发送到 MQ 中，再由消费者从 MQ 中获取 binlog 落地到大数据部门的 MySQL 中。</p><p>在这个过程中，可能会有对某个订单的增删改操作，比如有三条 binlog 执行顺序是增加、修改、删除。消费者愣是换了顺序给执行成删除、修改、增加，这样能行吗？肯定是不行的。</p><p>顺序消息分为<strong>全局顺序消息</strong>和<strong>部分顺序消息</strong>，全局顺序消息指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可，比如上面订单消息的例子，只要保证同一个订单ID的三个消息能按顺序消费即可。</p><h4 id="1-1全局顺序消息"><a href="#1-1全局顺序消息" class="headerlink" title="1.1全局顺序消息"></a>1.1全局顺序消息</h4><p>RocketMQ在默认情况下不保证顺序，比如创建一个Topic，默认八个写队列，八个读队列。这时候一条消息可能被写入任意一个队列里；在数据的读取过程中，可能有多个Consumer，每个Consumer也可能启动多个线程并行处理，所以消息被哪个Consumer消费，被消费的顺序和写入的顺序是否一致是不确定的。</p><p>要保证全局顺序消息，需要先把Topic的读写队列数设置为一，然后Producer和Consumer的并发设置也要是一。简单来说，为了保证整个Topic的全局消息有序，只能消除所有的并发处理，各部分都设置成单线程处理。这时高并发、高吞吐量的功能完全用不上了。</p><p>在实际应用中，更多的是像订单类消息那样，只需要部分有序即可。在这种情况下，我们经过合适的配置，依然可以利用RocketMQ高并发、高吞吐量的能力。</p><h4 id="1-2部分顺序消息"><a href="#1-2部分顺序消息" class="headerlink" title="1.2部分顺序消息"></a>1.2部分顺序消息</h4><p>要保证部分消息有序，需要发送端和消费端配合处理。在发送端，要做到把同一业务ID的消息发送到同一个Message Queue；在消费过程中，要做到从同一个Message Queue读取的消息不被并发处理，这样才能达到部分有序。</p><p>发送端使用MessageQueueSelector类来控制把消息发往哪个Message Queue。消费端通过使用MessageListenerOrderly类来解决单Message Queue的消息被并发处理的问题。</p><hr><h3 id="2-消息重复问题"><a href="#2-消息重复问题" class="headerlink" title="2.消息重复问题"></a>2.消息重复问题</h3><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，也就是所谓的“有且仅有一次”。在鱼和熊掌不可兼得的情况下，RocketMQ选择了确保一定投递，保证消息不丢失，但有可能造成消息重复。</p><p>消息重复一般情况下不会发生，但是如果消息量大，网络有波动，消息重复就是个大概率事件。比如Producer有个函数setRetryTimesWhenSendFailed，设置在同步方式下自动重试的次数，默认值是2，这样当第一次发送消息时，Broker端接收到了消息但是没有正确返回发送成功的状态，就造成了消息重复。</p><p>解决消息重复有两种方法：第一种方法是保证消费逻辑的幂等性（多次调用和一次调用效果相同）；另一种方法是维护一个已消费消息的记录，消费前查询这个消息是否被消费过。这两种方法都需要使用者自己实现。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引机制详解</title>
      <link href="/2023/12/16/suo-yin-ji-zhi-xiang-jie/"/>
      <url>/2023/12/16/suo-yin-ji-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的一种数据结构，<strong>本质是排好序的快速查找数据结构。</strong>在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p><p><strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p><p>索引使用：一张数据表，用于保存数据；一个索引配置文件，用于保存索引；每个索引都指向了某一个数据<br><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D.png"></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据的物理地址的指针，这样就可以运用二叉查找快速获取到相应数据</p><p>索引的优点：</p><ul><li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的 IO 成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li></ul><p>索引的缺点：</p><ul><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上</li><li>虽然索引大大提高了查询效率，同时却也降低更新表的速度。对表进行 INSERT、UPDATE、DELETE 操作，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，还会调整因为更新所带来的键值变化后的索引信息，<strong>但是更新数据也需要先从数据库中获取</strong>，索引加快了获取速度，所以可以相互抵消一下。</li><li>索引会影响到 WHERE 的查询条件和排序 ORDER BY 两大功能</li></ul><hr><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>索引一般的分类如下：</p><ul><li><p>功能分类 </p><ul><li>主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引</li><li>单列索引：一个索引只包含单个列，一个表可以有多个单列索引（普通索引）</li><li>联合索引：顾名思义，就是将单列索引进行组合</li><li>唯一索引：索引列的值必须唯一，<strong>允许有空值</strong>，如果是联合索引，则列值组合必须唯一<ul><li>NULL 值可以出现多次，因为两个 NULL 比较的结果既不相等，也不不等，结果仍然是未知</li><li>可以声明不允许存储 NULL 值的非空唯一索引</li></ul></li><li>外键索引：只有 InnoDB 引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作</li></ul></li><li><p>结构分类</p><ul><li>BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree</li><li>Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型</li><li>R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型</li><li>Full-text 索引（全文索引）：快速匹配全部文档的方式。MyISAM 支持， InnoDB 不支持 FULLTEXT 类型的索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，MEMORY 引擎不支持</li></ul><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>BTREE</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6 版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table></li></ul><p>联合索引图示：根据身高年龄建立的组合索引（height、age）</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E5%9B%BE.png"></p><hr><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引在创建表的时候可以同时创建， 也可以随时增加新的索引</p><ul><li><p>创建索引：如果一个表中有一列是主键，那么会<strong>默认为其创建主键索引</strong>（主键列不需要单独创建索引）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] ON 表名(列名...);-- 索引类型默认是 B+TREE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看索引</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW INDEX FROM 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加索引</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 单列索引ALTER TABLE 表名 ADD INDEX 索引名称(列名);-- 组合索引ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);-- 主键索引ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); -- 外键索引(添加外键约束，就是外键索引)ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);-- 唯一索引ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);-- 全文索引(mysql只支持文本类型)ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP INDEX 索引名称 ON 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案例练习</p><p>数据准备：student</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">idNAME agescore1张三23992李四24953王五25984赵六2697<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>索引操作：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 为student表中姓名列创建一个普通索引CREATE INDEX idx_name ON student(NAME);-- 为student表中年龄列创建一个唯一索引CREATE UNIQUE INDEX idx_age ON student(age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h4 id="索引对比"><a href="#索引对比" class="headerlink" title="索引对比"></a>索引对比</h4><p>聚簇索引是一种数据存储方式，并不是一种单独的索引类型</p><ul><li><p>聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</p></li><li><p>非聚簇索引的叶子节点存放的是主键值或指向数据行的指针（由存储引擎决定）</p></li></ul><p>在 Innodb 下主键索引是聚簇索引，在 MyISAM 下主键索引是非聚簇索引</p><hr><h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><h5 id="聚簇索引-1"><a href="#聚簇索引-1" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>在 Innodb 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引、clustered index）和辅助索引（也称非聚簇索引或二级索引、secondary index、non-clustered index）</p><p>InnoDB 中，聚簇索引是按照每张表的主键构造一颗 B+ 树，叶子节点中存放的就是整张表的数据，将聚簇索引的叶子节点称为数据页</p><ul><li>这个特性决定了<strong>数据也是索引的一部分</strong>，所以一张表只能有一个聚簇索引</li><li>辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</li></ul><p>聚簇索引的优点：</p><ul><li>数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p>聚簇索引的缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键</p></li><li><p>更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</p></li></ul><hr><h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引等</p><p>辅助索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询</p><p><strong>检索过程</strong>：辅助索引找到主键值，再通过聚簇索引（二分）找到数据页，最后通过数据页中的 Page Directory（二分）找到对应的数据分组，遍历组内所所有的数据找到数据行</p><p>补充：无索引走全表查询，查到数据页后和上述步骤一致</p><hr><h5 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h5><p>InnoDB 使用 B+Tree 作为索引结构，并且 InnoDB 一定有索引</p><p>主键索引：</p><ul><li><p>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这个索引的 key 是数据表的主键，叶子节点 data 域保存了完整的数据记录</p></li><li><p>InnoDB 的表数据文件<strong>通过主键聚集数据</strong>，如果没有定义主键，会选择非空唯一索引代替，如果也没有这样的列，MySQL 会自动为 InnoDB 表生成一个<strong>隐含字段 row_id</strong> 作为主键，这个字段长度为 6 个字节，类型为长整形</p></li></ul><p>辅助索引：</p><ul><li><p>InnoDB 的所有辅助索引（二级索引）都引用主键作为 data 域</p></li><li><p>InnoDB 表是基于聚簇索引建立的，因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过辅助索引也会包含主键列，所以不建议使用过长的字段作为主键，<strong>过长的主索引会令辅助索引变得过大</strong></p></li></ul><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-InnoDB%E8%81%9A%E7%B0%87%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="非聚簇"><a href="#非聚簇" class="headerlink" title="非聚簇"></a>非聚簇</h5><p>MyISAM 的主键索引使用的是非聚簇索引，索引文件和数据文件是分离的，<strong>索引文件仅保存数据的地址</strong></p><ul><li>主键索引 B+ 树的节点存储了主键，辅助键索引 B+ 树存储了辅助键，表数据存储在独立的地方，这两颗 B+ 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别</li><li>由于索引树是独立的，通过辅助索引检索<strong>无需回表查询</strong>访问主键的索引树</li></ul><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%A3%80%E9%94%81%E6%95%B0%E6%8D%AE%E5%9B%BE.jpg"></p><hr><h5 id="索引实现-1"><a href="#索引实现-1" class="headerlink" title="索引实现"></a>索引实现</h5><p>MyISAM 的索引方式也叫做非聚集的，之所以这么称呼是为了与 InnoDB 的聚集索引区分</p><p>主键索引：MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</p><p>辅助索引：MyISAM 中主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-MyISAM%E4%B8%BB%E9%94%AE%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p><p>参考文章：<a href="https://blog.csdn.net/lm1060891265/article/details/81482136">https://blog.csdn.net/lm1060891265/article/details/81482136</a></p><hr><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><h4 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h4><p>文件系统的最小单元是块（block），一个块的大小是 4K，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</p><p>InnoDB 存储引擎中有页（Page）的概念，页是 MySQL 磁盘管理的最小单位</p><ul><li><strong>InnoDB 存储引擎中默认每个页的大小为 16KB，索引中一个节点就是一个数据页</strong>，所以会一次性读取 16KB 的数据到内存</li><li>InnoDB 引擎将若干个地址连接磁盘块，以此来达到页的大小 16KB</li><li>在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I&#x2F;O 次数，提高查询效率</li></ul><p>超过 16KB 的一条记录，主键索引页只会存储部分数据和指向<strong>溢出页</strong>的指针，剩余数据都会分散存储在溢出页中</p><p>数据页物理结构，从上到下：</p><ul><li>File Header：上一页和下一页的指针、该页的类型（索引页、数据页、日志页等）、<strong>校验和</strong>、LSN（最近一次修改当前页面时的系统 lsn 值，事务持久性部分详解）等信息</li><li>Page Header：记录状态信息</li><li>Infimum + Supremum：当前页的最小记录和最大记录（头尾指针），Infimum 所在分组只有一条记录，Supremum 所在分组可以有 1 ~ 8 条记录，剩余的分组可以有 4 ~ 8 条记录</li><li>User Records：存储数据的记录</li><li>Free Space：尚未使用的存储空间</li><li>Page Directory：分组的目录，可以通过目录快速定位（二分法）数据的分组</li><li>File Trailer：检验和字段，在刷脏过程中，页首和页尾的校验和一致才能说明页面刷新成功，二者不同说明刷新期间发生了错误；LSN 字段，也是用来校验页面的完整性</li></ul><p>数据页中包含数据行，数据的存储是基于数据行的，数据行有 next_record 属性指向下一个行数据，所以是可以遍历的，但是一组数据至多 8 个行，通过 Page Directory 先定位到组，然后遍历获取所需的数据行即可</p><p>数据行中有三个隐藏字段：trx_id、roll_pointer、row_id（在事务章节会详细介绍它们的作用）</p><hr><h4 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h4><p>BTree 的索引类型是基于 B+Tree 树型数据结构的，B+Tree 又是 BTree 数据结构的变种，用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序</p><p>BTree 又叫多路平衡搜索树，一颗 m 叉的 BTree 特性如下：</p><ul><li>树中每个节点最多包含 m 个孩子</li><li>除根节点与叶子节点外，每个节点至少有 [ceil(m&#x2F;2)] 个孩子</li><li>若根节点不是叶子节点，则至少有两个孩子</li><li>所有的叶子节点都在同一层</li><li>每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li></ul><p>5 叉，key 的数量 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1 为 2 &lt;&#x3D; n &lt;&#x3D;4 ，当 n&gt;4 时中间节点分裂到父节点，两边节点分裂</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据的工作流程：</p><ul><li><p>插入前 4 个字母 C N G A </p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p></li><li><p>插入 H，n&gt;4，中间元素 G 字母向上分裂到新的节点</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p></li><li><p>插入 E、K、Q 不需要分裂</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B3.png"></p></li><li><p>插入 M，中间元素 M 字母向上分裂到父节点 G</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B4.png"></p></li><li><p>插入 F，W，L，T 不需要分裂</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B5.png"></p></li><li><p>插入 Z，中间元素 T 向上分裂到父节点中</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B6.png"></p></li><li><p>插入 D，中间元素 D 向上分裂到父节点中，然后插入 P，R，X，Y 不需要分裂</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B7.png"></p></li><li><p>最后插入 S，NPQR 节点 n&gt;5，中间节点 Q 向上分裂，但分裂后父节点 DGMT 的 n&gt;5，中间节点 M 向上分裂</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B8.png"></p></li></ul><p>BTree 树就已经构建完成了，BTree 树和二叉树相比， 查询数据的效率更高， 因为对于相同的数据量来说，<strong>BTree 的层级结构比二叉树少</strong>，所以搜索速度快</p><p>BTree 结构的数据可以让系统高效的找到数据所在的磁盘块，定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同，BTree 中的每个节点根据实际情况可以包含大量的关键字信息和分支<br><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%861.png"></p><p>缺点：当进行范围查找时会出现回旋查找</p><hr><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>BTree 数据结构中每个节点中不仅包含数据的 key 值，还有 data 值。磁盘中每一页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率，所以引入 B+Tree</p><p>B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：</p><ul><li>n 叉 B+Tree 最多含有 n 个 key（哈希值），而 BTree 最多含有 n-1 个 key</li></ul><ul><li>所有<strong>非叶子节点只存储键值 key</strong> 信息，只进行数据索引，使每个非叶子节点所能保存的关键字大大增加</li><li>所有<strong>数据都存储在叶子节点</strong>，所以每次数据查询的次数都一样</li><li><strong>叶子节点按照 key 大小顺序排列，左边结尾数据都会保存右边节点开始数据的指针，形成一个链表</strong></li><li>所有节点中的 key 在叶子节点中也存在（比如 5)，<strong>key 允许重复</strong>，B 树不同节点不存在重复的 key</li></ul><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-B%E5%8A%A0Tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" style="zoom:67%;"><p>B* 树：是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针</p><hr><h5 id="优化结构"><a href="#优化结构" class="headerlink" title="优化结构"></a>优化结构</h5><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，<strong>提高区间访问的性能，防止回旋查找</strong></p><p>区间访问的意思是访问索引为 5 - 15 的数据，可以直接根据相邻节点的指针遍历</p><p>B+ 树的<strong>叶子节点是数据页</strong>（page），一个页里面可以存多个数据行</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%862.png"></p><p>通常在 B+Tree 上有两个头指针，<strong>一个指向根节点，另一个指向关键字最小的叶子节点</strong>，而且所有叶子节点（即数据节点）之间是一种链式环结构。可以对 B+Tree 进行两种查找运算：</p><ul><li>有范围：对于主键的范围查找和分页查找</li><li>有顺序：从根节点开始，进行随机查找，顺序查找</li></ul><p>InnoDB 中每个数据页的大小默认是 16KB，</p><ul><li>索引行：一般表的主键类型为 INT（4 字节）或 BIGINT（8 字节），指针大小在 InnoDB 中设置为 6 字节节，也就是说一个页大概存储 16KB&#x2F;(8B+6B)&#x3D;1K 个键值（估值）。则一个深度为 3 的 B+Tree 索引可以维护 <code>10^3 * 10^3 * 10^3 = 10亿</code> 条记录</li><li>数据行：一行数据的大小可能是 1k，一个数据页可以存储 16 行</li></ul><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是<strong>将根节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I&#x2F;O 操作</p><p>B+Tree 优点：提高查询速度，减少磁盘的 IO 次数，树形结构较小</p><hr><h5 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h5><p>B+ 树为了保持索引的有序性，在插入新值的时候需要做相应的维护</p><p>每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：</p><ul><li>如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为<strong>页分裂</strong>，原本放在一个页的数据现在分到两个页中，降低了空间利用率</li><li>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做<strong>页合并</strong>，合并的过程可以认为是分裂过程的逆过程</li><li>这两个情况都是由 B+ 树的结构决定的</li></ul><p>一般选用数据小的字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p><p>自增主键的插入数据模式，可以让主键索引尽量地保持递增顺序插入，不涉及到挪动其他记录，<strong>避免了页分裂</strong>，页分裂的目的就是保证后一个数据页中的所有行主键值比前一个数据页中主键值大</p><p>参考文章：<a href="https://developer.aliyun.com/article/919861">https://developer.aliyun.com/article/919861</a></p><hr><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率</p><p>创建索引时的原则：</p><ul><li>对查询频次较高，且数据量比较大的表建立索引</li><li>使用唯一索引，区分度越高，使用索引的效率越高</li><li>索引字段的选择，最佳候选列应当从 where 子句的条件中提取，使用覆盖索引</li><li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的 I&#x2F;O 效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升 MySQL 访问索引的 I&#x2F;O 效率</li><li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价越高。对于插入、更新、删除等 DML 操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低 DML 操作的效率，增加相应操作的时间消耗；另外索引过多的话，MySQL 也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但提高了选择的代价</li></ul><ul><li><p>MySQL 建立联合索引时会遵守<strong>最左前缀匹配原则</strong>，即最左优先，在检索数据时从联合索引的最左边开始匹配</p><p>N 个列组合而成的组合索引，相当于创建了 N 个索引，如果查询时 where 句中使用了组成该索引的<strong>前</strong>几个字段，那么这条查询 SQL 可以利用组合索引来提升查询效率</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 对name、address、phone列建一个联合索引ALTER TABLE user ADD INDEX index_three(name,address,phone);-- 查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引进行数据匹配。(name,address,phone)(name,address)(name,phone)-- 只有name字段走了索引(name)-- 索引的字段可以是任意顺序的，优化器会帮助我们调整顺序，下面的SQL语句可以命中索引SELECT * FROM user WHERE address &#x3D; &#39;北京&#39; AND phone &#x3D; &#39;12345&#39; AND name &#x3D; &#39;张三&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 如果联合索引中最左边的列不包含在条件查询中，SQL语句就不会命中索引，比如：SELECT * FROM user WHERE address &#x3D; &#39;北京&#39; AND phone &#x3D; &#39;12345&#39;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>哪些情况不要建立索引：</p><ul><li>记录太少的表</li><li>经常增删改的表</li><li>频繁更新的字段不适合创建索引</li><li>where 条件里用不到的字段不创建索引</li></ul><hr><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引：包含所有满足查询需要的数据的索引（SELECT 后面的字段刚好是索引字段），可以利用该索引返回 SELECT 列表的字段，而不必根据索引去聚簇索引上读取数据文件</p><p>回表查询：要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据</p><p>使用覆盖索引，防止回表查询：</p><ul><li><p>表 user 主键为 id，普通索引为 age，查询语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM user WHERE age &#x3D; 30;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询过程：先通过普通索引 age&#x3D;30 定位到主键值 id&#x3D;1，再通过聚集索引 id&#x3D;1 定位到行记录数据，需要两次扫描 B+ 树</p></li><li><p>使用覆盖索引：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP INDEX idx_age ON user;CREATE INDEX idx_age_name ON user(age,name);SELECT id,age FROM user WHERE age &#x3D; 30;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在一棵索引树上就能获取查询所需的数据，无需回表速度更快</p></li></ul><p>使用覆盖索引，要注意 SELECT 列表中只取出需要的列，不可用 SELECT *，所有字段一起做索引会导致索引文件过大，查询性能下降</p><hr><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引条件下推优化（Index Condition Pushdown，ICP）是 MySQL5.6 添加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><p>索引下推充分利用了索引中的数据，在查询出整行数据之前过滤掉无效的数据，再去主键索引树上查找</p><ul><li><p>不使用索引下推优化时存储引擎通过索引检索到数据，然后回表查询记录返回给 Server 层，<strong>服务器判断数据是否符合条件</strong></p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p></li><li><p>使用索引下推优化时，如果<strong>存在某些被索引的列的判断条件</strong>时，由存储引擎在索引遍历的过程中判断数据是否符合传递的条件，将符合条件的数据进行回表，检索出来返回给服务器，由此减少 IO 次数</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p></li></ul><p><strong>适用条件</strong>：</p><ul><li>需要存储引擎将索引中的数据与条件进行判断（所以<strong>条件列必须都在同一个索引中</strong>），所以优化是基于存储引擎的，只有特定引擎可以使用，适用于 InnoDB 和 MyISAM</li><li>存储引擎没有调用跨存储引擎的能力，跨存储引擎的功能有存储过程、触发器、视图，所以调用这些功能的不可以进行索引下推优化</li><li>对于 InnoDB 引擎只适用于二级索引，InnoDB 的聚簇索引会将整行数据读到缓冲区，不再需要去回表查询了</li></ul><p>工作过程：用户表 user，(name, age) 是联合索引</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM user WHERE name LIKE &#39;张%&#39; AND　age &#x3D; 10;-- 头部模糊匹配会造成索引失效<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>优化前：在非主键索引树上找到满足第一个条件的行，然后通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比 AND 后的条件是否符合，符合返回数据，需要 4 次回表</p><p><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%961.png"></p></li><li><p>优化后：检查索引中存储的列信息是否符合索引条件，然后交由存储引擎用剩余的判断条件判断此行数据是否符合要求，<strong>不满足条件的不去读取表中的数据</strong>，满足下推条件的就根据主键值进行回表查询，2 次回表<br><img src="/2023/12/16/suo-yin-ji-zhi-xiang-jie/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%962.png"></p></li></ul><p>当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition</p><p>参考文章：<a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p><p>参考文章：<a href="https://time.geekbang.org/column/article/69636">https://time.geekbang.org/column/article/69636</a></p><hr><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当要索引的列字符很多时，索引会变大变慢，可以只索引列开始的部分字符串，节约索引空间，提高索引效率</p><p>注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了</p><p>优化原则：<strong>降低重复的索引值</strong></p><p>比如地区表：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">areagdpcodechinaShanghai100aaachinaDalian200bbbusaNewYork300cccchinaFuxin400dddchinaBeijing500eee<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现 area 字段很多都是以 china 开头的，那么如果以前 1-5 位字符做前缀索引就会出现大量索引值重复的情况，索引值重复性越低，查询效率也就越高，所以需要建立前 6 位字符的索引：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE INDEX idx_area ON table_name(area(7));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>场景：存储身份证</p><ul><li>直接创建完整索引，这样可能比较占用空间</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li></ul><hr><h4 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h4><p>使用多个索引来完成一次查询的执行方法叫做索引合并 index merge</p><ul><li><p>Intersection 索引合并：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_test <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">AND</span> key3 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span> <span class="token comment"># key1 和 key3 列都是单列索引、二级索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从不同索引中扫描到的记录的 id 值取<strong>交集</strong>（相同 id），然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p></li><li><p>Union 索引合并：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_test <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">OR</span> key3 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从不同索引中扫描到的记录的 id 值取<strong>并集</strong>，然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p></li><li><p>Sort-Union 索引合并</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_test <span class="token keyword">WHERE</span> key1 <span class="token operator">&lt;</span> <span class="token string">'a'</span> <span class="token operator">OR</span> key3 <span class="token operator">></span> <span class="token string">'b'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先将从不同索引中扫描到的记录的主键值进行排序，再按照 Union 索引合并的方式进行查询</p></li></ul><p>索引合并算法的效率并不好，通过将其中的一个索引改成联合索引会优化效率</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的对象系统</title>
      <link href="/2023/12/12/redis-de-dui-xiang-xi-tong/"/>
      <url>/2023/12/12/redis-de-dui-xiang-xi-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>Redis的对象系统包括string、hash、list、set、zset这五种类型的对象，每种对象都用到了至少一种我们前面介绍的数据结构。</p><p>使用对象的好处：</p><ol><li>Redis可以在执行命令前，可以根据对象的类型来判断一个对象是否可以执行给定的命令</li><li>可以针对不同的使用场景，为对象设置不同的数据结构实现，从而优化对象在不同使用场景下的使用效率</li></ol><p>除此之外，对象系统还实现了基于<code>引用计数技术</code>的<code>内存回收机制</code>，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了<code>对象共享机制</code>，这一机制可以在适当条件下，通过让多个数据库键共享同一个对象来节约内存。</p><p>最后，Redis的对象记录了访问时间信息，在服务器启用了maxmemory功能的情况下，根据访问时间计算出空转时长较大的那些键可能会优先被服务器删除。</p><p>本文接下来将逐一介绍以上提到的Redis对象系统的各个特性。</p><h3 id="2-对象类型与编码"><a href="#2-对象类型与编码" class="headerlink" title="2.对象类型与编码"></a>2.对象类型与编码</h3><p>Redis 使用对象来表示数据库中的键和值，当在 Redis 数据库中<strong>新创建一个键值对时至少会创建两个对象</strong>，一个对象用作键值对的键（<strong>键对象</strong>），另一个对象用作键值对的值（<strong>值对象</strong>）</p><p>Redis 中对象由一个 redisObject 结构表示，该结构中和保存数据有关的三个属性分别是 type、 encoding、ptr：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObiect</span> <span class="token punctuation">&#123;</span><span class="token comment">// 类型</span><span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 编码</span><span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// 指向底层数据结构的指针</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>        <span class="token comment">// ....</span><span class="token punctuation">&#125;</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1类型"><a href="#2-1类型" class="headerlink" title="2.1类型"></a>2.1类型</h4><p>对象的type属性记录了对象的类型，这个属性的值可以是下表中的一个：</p><table><thead><tr><th align="center">类型常量</th><th align="center">对象的名称</th></tr></thead><tbody><tr><td align="center">REDIS_STRING</td><td align="center">字符串对象</td></tr><tr><td align="center">REDIS_LIST</td><td align="center">列表对象</td></tr><tr><td align="center">REDIS_HASH</td><td align="center">哈希对象</td></tr><tr><td align="center">REDIS_SET</td><td align="center">集合对象</td></tr><tr><td align="center">REDIS_ZSET</td><td align="center">有序集合对象</td></tr></tbody></table><p>对于redis数据库保存的键值对来说，<strong>键总是一个字符串对象，值可以是五种数据类型中的一种</strong>。</p><h4 id="2-2编码和底层实现"><a href="#2-2编码和底层实现" class="headerlink" title="2.2编码和底层实现"></a>2.2编码和底层实现</h4><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p><p>encoding属性记录了对象所使用的编码，也就是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量中的一个。</p><table><thead><tr><th>编码常量</th><th>编码所对应的底层数据结构</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td>long类型的整数</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td>embstr</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>REDIS_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表和字典</td></tr></tbody></table><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为对象设置不同的编码，从而优化对象在某一场景下的效率。</p><p>举个例子，在列表对象包含的元素比较少时，redis使用压缩列表作为列表的底层实现：</p><ul><li>因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表可以更快的被载入内存</li><li>随着列表对象包含的元素越来越多，使用压缩列表保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上</li></ul><h3 id="3-string对象"><a href="#3-string对象" class="headerlink" title="3.string对象"></a>3.string对象</h3><h4 id="3-1简介"><a href="#3-1简介" class="headerlink" title="3.1简介"></a>3.1简介</h4><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型，实质上是存一个字符串，string 类型是二进制安全的，可以包含任何数据，比如图片或者序列化的对象</p><p>存储数据的格式：一个存储空间保存一个数据，每一个空间中只能保存一个字符串信息</p><p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-string%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:50%;"><p>Redis 所有操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>机制，命令是单个顺序执行，无需考虑并发带来影响，原子性就是有一个失败则都失败</p><p>字符串对象可以是 int、raw、embstr 三种实现方式</p><hr><h4 id="3-2操作"><a href="#3-2操作" class="headerlink" title="3.2操作"></a>3.2操作</h4><p>指令操作：</p><ul><li><p>数据操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> key value<span class="token comment">#添加/修改数据添加/修改数据</span>del key<span class="token comment">#删除数据</span>setnx key value<span class="token comment">#判定性添加数据，键值为空则设添加</span>mset k1 v1 k2 v2<span class="token punctuation">..</span>.<span class="token comment">#添加/修改多个数据，m：Multiple</span>append key value<span class="token comment">#追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">get key<span class="token comment">#获取数据，如果不存在，返回空（nil）</span>mget key1 key2<span class="token punctuation">..</span>.<span class="token comment">#获取多个数据</span>strlen key<span class="token comment">#获取数据字符个数（字符串长度）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>设置数值数据增加&#x2F;减少指定范围的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">incr key<span class="token comment">#key++</span>incrby key increment<span class="token comment">#key+increment</span>incrbyfloat key increment<span class="token comment">#对小数操作</span>decr key<span class="token comment">#key--</span>decrby key increment<span class="token comment">#key-increment</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>设置数据具有指定的生命周期</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setex key seconds value  <span class="token comment">#设置key-value存活时间，seconds单位是秒</span>psetex key milliseconds value<span class="token comment">#毫秒级</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>注意事项：</p><ol><li><p>数据操作不成功的反馈与数据正常操作之间的差异</p><ul><li><p>表示运行结果是否成功</p><ul><li><p>(integer) 0  → false ，失败</p></li><li><p>(integer) 1  → true，成功</p></li></ul></li><li><p>表示运行结果值</p><ul><li><p>(integer) 3  → 3 个</p></li><li><p>(integer) 1  → 1 个</p></li></ul></li></ul></li><li><p>数据未获取到时，对应的数据为（nil），等同于null</p></li><li><p><strong>数据最大存储量</strong>：512MB</p></li><li><p>string 在 Redis 内部存储默认就是一个字符串，当遇到增减类操作 incr，decr 时<strong>会转成数值型</strong>进行计算</p></li><li><p>按数值进行操作的数据，如果原始数据不能转成数值，或超越了Redis 数值上限范围，将报错<br>9223372036854775807（java 中 Long 型数据最大值，Long.MAX_VALUE）</p></li><li><p>Redis 可用于控制数据库表主键 ID，为数据库表主键提供生成策略，保障数据库表的主键唯一性</p></li></ol><p>单数据和多数据的选择：</p><ul><li>单数据执行 3 条指令的过程：3 次发送 + 3 次处理 + 3 次返回</li><li>多数据执行 1 条指令的过程：1 次发送 + 3 次处理 + 1 次返回（发送和返回的事件略高于单数据）</li></ul><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/string%E5%8D%95%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C.png" style="zoom: 33%;"><hr><h4 id="3-3实现"><a href="#3-3实现" class="headerlink" title="3.3实现"></a>3.3实现</h4><p>字符串对象的编码可以是 int、raw、embstr 三种</p><ul><li><p>int：字符串对象保存的是<strong>整数值</strong>，并且整数值可以用 long 类型来表示，那么对象会将整数值保存在字符串对象结构的 ptr 属性面（将 void * 转换成 long)，并将字符串对象的编码设置为 int（浮点数用另外两种方式）</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1int%E7%BC%96%E7%A0%81.png" style="zoom:67%;"></li><li><p>raw：字符串对象保存的是一个字符串值，并且值的长度大于 39 字节，那么对象将使用简单动态字符串（SDS）来保存该值，并将对象的编码设置为 raw</p><p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1raw%E7%BC%96%E7%A0%81.png"></p></li><li><p>embstr：字符串对象保存的是一个字符串值，并且值的长度小于等于 39 字节，那么对象将使用 embstr 编码的方式来保存这个字符串值，并将对象的编码设置为 embstr</p><p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1embstr%E7%BC%96%E7%A0%81.png"></p><p>上图所示，embstr 与 raw 都使用了 redisObject 和 sdshdr 来表示字符串对象，但是 raw 需要调用两次内存分配函数分别创建两种结构，embstr 只需要一次内存分配来分配一块<strong>连续的空间</strong></p></li></ul><p>embstr 是用于保存短字符串的一种编码方式，对比 raw 的优点：</p><ul><li>内存分配次数从两次降低为一次，同样释放内存的次数也从两次变为一次</li><li>embstr 编码的字符串对象的数据都保存在同一块连续内存，所以比 raw 编码能够更好地利用缓存优势（局部性原理）</li></ul><p>int 和 embstr 编码的字符串对象在条件满足的情况下，会被转换为 raw 编码的字符串对象：</p><ul><li>int 编码的整数值，执行 APPEND 命令追加一个字符串值，先将整数值转为字符串然后追加，最后得到一个 raw 编码的对象</li><li>Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序，所以 embstr 对象实际上<strong>是只读的</strong>，执行修改命令会将对象的编码从 embstr 转换成 raw，操作完成后得到一个 raw 编码的对象</li></ul><p>某些情况下，程序会将字符串对象里面的字符串值转换回浮点数值，执行某些操作后再将浮点数值转换回字符串值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis<span class="token operator">></span> SET pi <span class="token number">3.14</span> OK redis<span class="token operator">></span> OBJECT ENCODING pi<span class="token string">"embstr"</span> redis<span class="token operator">></span> INCRBYFLOAT pi <span class="token number">2.0</span> <span class="token comment"># 转为浮点数执行增加的操作</span><span class="token string">"5. 14"</span> redis<span class="token operator">></span> OBJECT ENCODING pi <span class="token string">"embstr"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="3-4应用"><a href="#3-4应用" class="headerlink" title="3.4应用"></a>3.4应用</h4><p>主页高频访问信息显示控制，例如新浪微博大 V 主页显示粉丝数与微博数量</p><ul><li><p>在 Redis 中为大 V 用户设定用户信息，以用户主键和属性值作为 key，后台设定定时刷新策略</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> user:id:3506728370:fans <span class="token number">12210947</span><span class="token builtin class-name">set</span> user:id:3506728370:blogs <span class="token number">6164</span><span class="token builtin class-name">set</span> user:id:3506728370:focuses <span class="token number">83</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用 JSON 格式保存数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user:id:3506728370 → <span class="token punctuation">&#123;</span><span class="token string">"fans"</span>:12210947,<span class="token string">"blogs"</span>:6164,<span class="token string">"focuses"</span>:83<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>key的设置约定：表名 : 主键名 : 主键值 : 字段名</p><table><thead><tr><th>表名</th><th>主键名</th><th>主键值</th><th>字段名</th></tr></thead><tbody><tr><td>order</td><td>id</td><td>29437595</td><td>name</td></tr><tr><td>equip</td><td>id</td><td>390472345</td><td>type</td></tr><tr><td>news</td><td>id</td><td>202004150</td><td>title</td></tr></tbody></table></li></ul><hr><h3 id="4-hash"><a href="#4-hash" class="headerlink" title="4.hash"></a>4.hash</h3><h4 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h4><p>数据存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p><p>数据存储结构：一个存储空间保存多个键值对数据</p><p>hash 类型：底层使用<strong>哈希表</strong>结构实现数据存储</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/hash%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom: 33%;"><p>Redis 中的 hash 类似于 Java 中的  <code>Map&lt;String, Map&lt;Object,object&gt;&gt;</code>，左边是 key，右边是值，中间叫 field 字段，本质上 <strong>hash 存了一个 key-value 的存储空间</strong></p><p>hash 是指的一个数据类型，并不是一个数据</p><ul><li>如果 field 数量较少，存储结构优化为<strong>压缩列表结构</strong>（有序）</li><li>如果 field 数量较多，存储结构使用 HashMap 结构（无序）</li></ul><hr><h4 id="4-2操作"><a href="#4-2操作" class="headerlink" title="4.2操作"></a>4.2操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hset key field value<span class="token comment">#添加/修改数据</span>hdel key field1 <span class="token punctuation">[</span>field2<span class="token punctuation">]</span><span class="token comment">#删除数据，[]代表可选</span>hsetnx key field value<span class="token comment">#设置field的值，如果该field存在则不做任何操作</span>hmset key f1 v1 f2 v2<span class="token punctuation">..</span>.<span class="token comment">#添加/修改多个数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hget key field<span class="token comment">#获取指定field对应数据</span>hgetall key<span class="token comment">#获取指定key所有数据</span>hmget key field1 field2<span class="token punctuation">..</span>.<span class="token comment">#获取多个数据</span>hexists key field<span class="token comment">#获取哈希表中是否存在指定的字段</span>hlen key<span class="token comment">#获取哈希表中字段的数量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取哈希表中所有的字段名或字段值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hkeys key<span class="token comment">#获取所有的field</span>hvals key<span class="token comment">#获取所有的value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>设置指定字段的数值数据增加指定范围的值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hincrby key field increment<span class="token comment">#指定字段的数值数据增加指定的值，increment为负数则减少</span>hincrbyfloat key field increment<span class="token comment">#操作小数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>注意事项</p><ol><li>hash 类型中 value 只能存储字符串，不允许存储其他数据类型，不存在嵌套现象，如果数据未获取到，对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值对</li><li>hash 类型和对象的数据存储形式相似，并且可以灵活添加删除对象属性。但 hash 设计初衷不是为了存储大量对象而设计的，不可滥用，不可将 hash 作为对象列表使用</li><li>hgetall 操作可以获取全部属性，如果内部 field 过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ol><hr><h4 id="4-3实现"><a href="#4-3实现" class="headerlink" title="4.3实现"></a>4.3实现</h4><p>哈希对象的内部编码有两种：ziplist（压缩列表）、hashtable（哈希表、字典）</p><ul><li><p>压缩列表实现哈希对象：同一键值对的节点总是挨在一起，保存键的节点在前，保存值的节点在后</p><p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1ziplist.png"></p></li><li><p>字典实现哈希对象：字典的每一个键都是一个字符串对象，每个值也是</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1dict.png" style="zoom:67%;"></li></ul><p>当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型，具体需要满足两个条件：</p><ul><li>当键值对数量小于 hash-max-ziplist-entries 配置（默认 512 个）</li><li>所有键和值的长度都小于 hash-max-ziplist-value 配置（默认 64 字节）</li></ul><p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p><p>ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比 hashtable 更加优秀，当 ziplist 无法满足哈希类型时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为 O(1)</p><hr><h4 id="4-4应用"><a href="#4-4应用" class="headerlink" title="4.4应用"></a>4.4应用</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">user:id:3506728370 → <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"春晚"</span>,<span class="token string">"fans"</span>:12210862,<span class="token string">"blogs"</span>:83<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于以上数据，使用单条去存的话，存的条数会很多。但如果用 json 格式，存一条数据就够了。</p><p>假如现在粉丝数量发生了变化，要把整个值都改变，但是用单条存就不存在这个问题，只需要改其中一个就可以</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/hash%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom: 33%;"><p>可以实现购物车的功能，key 对应着每个用户，存储空间存储购物车的信息</p><hr><h3 id="5-list"><a href="#5-list" class="headerlink" title="5.list"></a>5.list</h3><h4 id="5-1简介"><a href="#5-1简介" class="headerlink" title="5.1简介"></a>5.1简介</h4><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p><p>数据存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序，允许重复元素</p><p>list 类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现，类似于 LinkedList</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/list%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:33%;"><p>如果两端都能存取数据的话，这就是双端队列，如果只能从一端进一端出，这个模型叫栈</p><hr><h4 id="5-2操作"><a href="#5-2操作" class="headerlink" title="5.2操作"></a>5.2操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lpush key value1 <span class="token punctuation">[</span>value2<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token comment">#从左边添加/修改数据(表头)</span>rpush key value1 <span class="token punctuation">[</span>value2<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token comment">#从右边添加/修改数据(表尾)</span>lpop key<span class="token comment">#从左边获取并移除第一个数据，类似于出栈/出队</span>rpop key<span class="token comment">#从右边获取并移除第一个数据</span>lrem key count value<span class="token comment">#删除指定数据，count=2删除2个，该value可能有多个(重复数据)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lrange key start stop<span class="token comment">#从左边遍历数据并指定开始和结束索引，0是第一个索引，-1是终索引</span>lindex key index<span class="token comment">#获取指定索引数据，没有则为nil，没有索引越界</span>llen key<span class="token comment">#list中数据长度/个数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>规定时间内获取并移除数据</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">b<span class="token comment">#代表阻塞</span>blpop key1 <span class="token punctuation">[</span>key2<span class="token punctuation">]</span> <span class="token function">timeout</span><span class="token comment">#在指定时间内获取指定key(可以多个)的数据，超时则为(nil)</span><span class="token comment">#可以从其他客户端写数据，当前客户端阻塞读取数据</span>brpop key1 <span class="token punctuation">[</span>key2<span class="token punctuation">]</span> <span class="token function">timeout</span><span class="token comment">#从右边操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>复制操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brpoplpush <span class="token builtin class-name">source</span> destination <span class="token function">timeout</span><span class="token comment">#从source获取数据放入destination，假如在指定时间内没有任何元素被弹出，则返回一个nil和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>注意事项</p><ol><li>list 中保存的数据都是 string 类型的，数据总容量是有限的，最多 2^32 - 1 个元素（4294967295）</li><li>list 具有索引的概念，但操作数据时通常以队列的形式进行入队出队，或以栈的形式进行入栈出栈</li><li>获取全部数据操作结束索引设置为 -1</li><li>list 可以对数据进行分页操作，通常第一页的信息来自于 list，第 2 页及更多的信息通过数据库的形式加载</li></ol><hr><h4 id="5-3实现"><a href="#5-3实现" class="headerlink" title="5.3实现"></a>5.3实现</h4><p>在 Redis3.2 版本以前列表对象的内部编码有两种：ziplist（压缩列表）和 linkedlist（链表）</p><ul><li><p>压缩列表实现的列表对象：PUSH 1、three、5 三个元素</p><p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1ziplist.png"></p></li><li><p>链表实现的列表对象：为了简化字符串对象的表示，使用了 StringObject 的结构，底层其实是 sdshdr 结构</p><p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1linkedlist.png"></p></li></ul><p>列表中存储的数据量比较小的时候，列表就会使用一块连续的内存存储，采用压缩列表的方式实现的条件：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节</li><li>列表对象保存的元素数量小于 512 个</li></ul><p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p><p>在 Redis3.2 版本 以后对列表数据结构进行了改造，使用 <strong>quicklist（快速列表）</strong>代替了 linkedlist，quicklist 实际上是 ziplist 和 linkedlist 的混合体，将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来，既满足了快速的插入删除性能，又不会出现太大的空间冗余</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" style="zoom: 50%;"><hr><h4 id="5-4应用"><a href="#5-4应用" class="headerlink" title="5.4应用"></a>5.4应用</h4><p>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p><ul><li>依赖 list 的数据具有顺序的特征对信息进行管理，右进左查或者左近左查</li><li>使用队列模型解决多路信息汇总合并的问题</li><li>使用栈模型解决最新消息的问题</li></ul><p>微信文章订阅公众号：</p><ul><li>比如订阅了两个公众号，它们发布了两篇文章，文章 ID 分别为 666 和 888，可以通过执行 <code>LPUSH key 666 888</code> 命令推送给我</li></ul><hr><h3 id="6-set"><a href="#6-set" class="headerlink" title="6.set"></a>6.set</h3><h4 id="6-1简介"><a href="#6-1简介" class="headerlink" title="6.1简介"></a>6.1简介</h4><p>数据存储需求：存储大量的数据，在查询方面提供更高的效率</p><p>数据存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p><p>set 类型：与 hash 存储结构哈希表完全相同，只是仅存储键不存储值（nil），所以添加，删除，查找的复杂度都是 O(1)，并且<strong>值是不允许重复且无序的</strong></p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/set%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom: 33%;"><hr><h4 id="6-2操作"><a href="#6-2操作" class="headerlink" title="6.2操作"></a>6.2操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sadd key member1 <span class="token punctuation">[</span>member2<span class="token punctuation">]</span><span class="token comment">#添加数据</span>srem key member1 <span class="token punctuation">[</span>member2<span class="token punctuation">]</span><span class="token comment">#删除数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">smembers key<span class="token comment">#获取全部数据</span>scard key<span class="token comment">#获取集合数据总量</span>sismember key member<span class="token comment">#判断集合中是否包含指定数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>随机操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">spop key <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token comment">#随机获取集中的某个数据并将该数据移除集合</span>srandmember key <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token comment">#随机获取集合中指定(数量)的数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>集合的交、并、差</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sinter key1 <span class="token punctuation">[</span>key2<span class="token punctuation">..</span>.<span class="token punctuation">]</span>  <span class="token comment">#两个集合的交集，不存在为(empty list or set)</span>sunion key1 <span class="token punctuation">[</span>key2<span class="token punctuation">..</span>.<span class="token punctuation">]</span>  <span class="token comment">#两个集合的并集</span><span class="token function">sdiff</span> key1 <span class="token punctuation">[</span>key2<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#两个集合的差集</span>sinterstore destination key1 <span class="token punctuation">[</span>key2<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#两个集合的交集并存储到指定集合中</span>sunionstore destination key1 <span class="token punctuation">[</span>key2<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#两个集合的并集并存储到指定集合中</span>sdiffstore destination key1 <span class="token punctuation">[</span>key2<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#两个集合的差集并存储到指定集合中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>复制</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">smove <span class="token builtin class-name">source</span> destination member<span class="token comment">#将指定数据从原始集合中移动到目标集合中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>注意事项</p><ol><li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li><li>set 虽然与 hash 的存储结构相同，但是无法启用 hash 中存储值的空间</li></ol><hr><h4 id="6-3实现"><a href="#6-3实现" class="headerlink" title="6.3实现"></a>6.3实现</h4><p>集合对象的内部编码有两种：intset（整数集合）、hashtable（哈希表、字典）</p><ul><li><p>整数集合实现的集合对象：</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1intset.png" style="zoom:67%;"></li><li><p>字典实现的集合对象：键值对的值为 NULL</p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1dict.png" style="zoom:80%;"></li></ul><p>当集合对象可以同时满足以下两个条件时，对象使用 intset 编码：</p><ul><li>集合中的元素都是整数值</li><li>集合中的元素数量小于 set-maxintset-entries配置（默认 512 个）</li></ul><p>以上两个条件的上限值是可以通过配置文件修改的</p><hr><h4 id="6-4应用"><a href="#6-4应用" class="headerlink" title="6.4应用"></a>6.4应用</h4><p>应用场景：</p><ol><li><p>黑名单：资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密。</p><p>注意：爬虫不一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</p></li><li><p>白名单：对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证</p></li><li><p>随机操作可以实现抽奖功能</p></li><li><p>集合的交并补可以实现微博共同关注的查看，可以根据共同关注或者共同喜欢推荐相关内容</p></li></ol><hr><h3 id="7-zset"><a href="#7-zset" class="headerlink" title="7.zset"></a>7.zset</h3><h4 id="7-1简介"><a href="#7-1简介" class="headerlink" title="7.1简介"></a>7.1简介</h4><p>数据存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p><p>数据存储结构：新的存储模型，可以保存可排序的数据</p><hr><h4 id="7-2操作"><a href="#7-2操作" class="headerlink" title="7.2操作"></a>7.2操作</h4><p>指令操作：</p><ul><li><p>数据操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zadd key score1 member1 <span class="token punctuation">[</span>score2 member2<span class="token punctuation">]</span><span class="token comment">#添加数据</span>zrem key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#删除数据</span>zremrangebyrank key start stop <span class="token comment">#删除指定索引范围的数据</span>zremrangebyscore key min max<span class="token comment">#删除指定分数区间内的数据</span>zscore key member<span class="token comment">#获取指定值的分数</span>zincrby key increment member<span class="token comment">#指定值的分数增加increment</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zrange key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span><span class="token comment">#获取指定范围的数据，升序，WITHSCORES 代表显示分数</span>zrevrange key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span><span class="token comment">#获取指定范围的数据，降序</span>zrangebyscore key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span><span class="token comment">#按条件获取数据，从小到大</span>zrevrangebyscore key max min <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#从大到小</span>zcard key<span class="token comment">#获取集合数据的总量</span>zcount key min max<span class="token comment">#获取指定分数区间内的数据总量</span>zrank key member<span class="token comment">#获取数据对应的索引（排名）升序</span>zrevrank key member<span class="token comment">#获取数据对应的索引（排名）降序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>min 与 max 用于限定搜索查询的条件</li><li>start 与 stop 用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset 与 count 用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li></ul></li><li><p>集合的交、并操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zinterstore destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#两个集合的交集并存储到指定集合中</span>zunionstore destination numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token comment">#两个集合的并集并存储到指定集合中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>注意事项：</p><ol><li>score 保存的数据存储空间是 64 位，如果是整数范围是 -9007199254740992~9007199254740992</li><li>score 保存的数据也可以是一个双精度的 double 值，基于双精度浮点数的特征可能会丢失精度，慎重使用</li><li>sorted_set 底层存储还是基于 set 结构的，因此数据不能重复，如果重复添加相同的数据，score 值将被反复覆盖，保留最后一次修改的结果</li></ol><hr><h4 id="7-3实现"><a href="#7-3实现" class="headerlink" title="7.3实现"></a>7.3实现</h4><p>有序集合对象的内部编码有两种：ziplist（压缩列表）和 skiplist（跳跃表）</p><ul><li><p>压缩列表实现有序集合对象：ziplist 本身是有序、不可重复的，符合有序集合的特性</p><p><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1ziplist.png"></p></li><li><p>跳跃表实现有序集合对象：<strong>底层是 zset 结构，zset 同时包含字典和跳跃表的结构</strong>，图示字典和跳跃表中重复展示了各个元素的成员和分值，但实际上两者会<strong>通过指针来共享相同元素的成员和分值</strong>，不会产生空间浪费</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">&#123;</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><img src="/2023/12/12/redis-de-dui-xiang-xi-tong/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1zset.png"></li></ul><p>使用字典加跳跃表的优势：</p><ul><li>字典为有序集合创建了一个<strong>从成员到分值的映射</strong>，用 O(1) 复杂度查找给定成员的分值</li><li><strong>排序操作使用跳跃表完成</strong>，节省每次重新排序带来的时间成本和空间成本</li></ul><p>使用 ziplist 格式存储需要满足以下两个条件：</p><ul><li>有序集合保存的元素个数要小于 128 个；</li><li>有序集合保存的所有元素大小都小于 64 字节</li></ul><p>当元素比较多时，此时 ziplist 的读写效率会下降，时间复杂度是 O(n)，跳表的时间复杂度是 O(logn)</p><p>为什么用跳表而不用平衡树？</p><ul><li>在做范围查找的时候，跳表操作简单（前进指针或后退指针），平衡树需要回旋查找</li><li>跳表比平衡树实现简单，平衡树的插入和删除操作可能引发子树的旋转调整，而跳表的插入和删除只需要修改相邻节点的指针</li></ul><hr><h4 id="7-4应用"><a href="#7-4应用" class="headerlink" title="7.4应用"></a>7.4应用</h4><ul><li>排行榜</li><li>对于基于时间线限定的任务处理，将处理时间记录为 score 值，利用排序功能区分处理的先后顺序</li><li>当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，采用 score 记录权重</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常见数据结构和数据类型</title>
      <link href="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/"/>
      <url>/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>Redis 构建了简单动态字符串（SDS）的数据类型，作为 Redis 的默认字符串表示，包含字符串的键值对在底层都是由 SDS 实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 记录buf数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment">// 记录buf数组中未使用字节的数量</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>        <span class="token comment">// 字节数组，用于保存字符串</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SDS 遵循 C 字符串<strong>以空字符结尾</strong>的惯例，保存空字符的 1 字节不计算在 len 属性，SDS 会自动为空字符分配额外的 1 字节空间和添加空字符到字符串末尾（由SDS函数自动完成），所以空字符对于 SDS 的使用者来说是完全透明的。</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-SDS%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>1.常数复杂度获取字符串长度：</strong></p><ul><li>C 字符串不记录自身的长度，获取时需要遍历整个字符串，遇到空字符串为止，时间复杂度为 O(N)</li><li>SDS 在len属性记录了字符串的长度，所以获取字符串长度的复杂度为 O(1)，设置和更新 SDS 长度由函数底层自动完成</li></ul><p><strong>2.杜绝缓冲区溢出：</strong></p><ul><li><p>C 字符串调用 strcat 函数拼接字符串时，如果字符串内存不够容纳目标字符串，就会造成缓冲区溢出（Buffer Overflow）</p><p>【例】s1 和 s2 是内存中相邻的字符串，如果一个程序员执行 <code>strcat(s1, &quot; Cluster&quot;)</code>（有空格），打算将s1的内容修改为”Redis Cluster”，但粗心的他忘了在执行strcat前为s1分配足够的空间，那么在strcat函数执行后，s1的数据将溢出到s2所在的空间，导致s2保存的的内容被意外修改：</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.png"></p></li><li><p>SDS 空间分配策略：当对 SDS 进行修改时，首先检查 SDS 的空间是否满足修改所需的要求， 如果不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后执行实际的修改操作， 避免了缓冲区溢出的问题</p></li></ul><p><strong>3.减少修改字符串时带来的内存重分配次数</strong></p><p>C 字符串<strong>每次</strong>增长或者缩短都会进行一次内存重分配，拼接操作通过重分配扩展底层数组空间，截断操作通过重分配释放不使用的内存空间，防止出现内存泄露</p><p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中 buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节，字节的数量由 free 属性记录</p><p>内存重分配涉及复杂的算法，需要执行<strong>系统调用</strong>，是一个比较耗时的操作，SDS 的两种优化策略：</p><ul><li><p>空间预分配：当 SDS 需要进行空间扩展时，程序不仅会为 SDS 分配修改所必需的空间， 还会为 SDS 分配额外的未使用空间</p><ul><li><p>对 SDS 修改之后，SDS 的长度（len 属性）小于 1MB，程序分配和 len 属性同样大小的未使用空间，此时 len 和 free 相等</p><p>s 为 Redis，执行 <code>sdscat(s, &quot; Cluster&quot;)</code> 后，len 变为 13 字节，所以也分配了 13 字节的 free 空间，总长度变为 27 字节（额外的一字节保存空字符，13 + 13 + 1 &#x3D; 27）</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-SDS%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D.png"></p></li><li><p>对 SDS 修改之后，SDS 的长度大于等于 1MB，程序会分配 1MB 的未使用空间</p></li></ul><p>在扩展 SDS 空间前，API 会先检查 free 空间是否足够，如果足够就无需执行内存重分配，所以通过预分配策略，SDS 将连续增长 N 次字符串所需内存的重分配次数从<strong>必定 N 次降低为最多 N 次</strong></p></li><li><p>惰性空间释放：当 SDS 缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来复用</p><p>SDS 提供了相应的 API 来真正释放 SDS 的未使用空间，所以不用担心空间惰性释放策略造成的内存浪费问题</p></li></ul><p><strong>3.二进制安全：</strong></p><ul><li>C 字符串中的字符必须符合某种编码（比如 ASCII）方式，除了字符串末尾以外其他位置不能包含空字符，否则会被误认为是字符串的结尾，所以只能保存文本数据</li><li>SDS 的 API 都是二进制安全的，<strong>使用 len 属性来判断数据的结尾</strong>，所以可以保存图片、视频、压缩文件等二进制数据。这也是我们将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。</li></ul><p><strong>4.兼容部分 C 字符串的函数：</strong></p><p>SDS 的API会保存的数据的末尾设置空字符串，并且总会在为 buf 数组分配空间时多分配一个字节来容纳空字符，所以可以重用一部分 C 字符串函数库的函数，从而避免了不必要的代码重复。</p><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，C 语言并没有内置这种数据结构，所以 Redis 构建了链表数据类型。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串，Redis就会使用链表作为列表键的底层实现</p><p>链表节点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 前置节点</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>        <span class="token comment">// 后置节点</span>    <span class="token keyword">struct</span> <span class="token class-name">listNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>        <span class="token comment">// 节点的值</span>    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">&#125;</span> listNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个 listNode 通过 prev 和 next 指针组成<strong>双端链表</strong>：</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>list 链表结构：提供了表头指针 head 、表尾指针 tail 以及链表长度计数器 len</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 表头节点</span>    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token comment">// 表尾节点</span>    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>        <span class="token comment">// 链表所包含的节点数量</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>        <span class="token comment">// 节点值复制函数，用于复制链表节点所保存的值</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 节点值释放函数，用于释放链表节点所保存的值</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E9%93%BE%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>Redis 链表实现的特性可总结如下：</p><ul><li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是 O(1)</li><li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点</li><li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的时间复杂度为 O(1)</li><li>带链表长度计数器：使用 len 属性来对 list 持有的链表节点进行计数，获取链表中节点数量的时间复杂度为 O(1)</li><li>多态：链表节点使用 void * 指针来保存节点值， 并且可以通过 dup、free 、match 三个属性为节点值设置类型特定函数，所以链表可以保存各种<strong>不同类型的值</strong></li></ul><hr><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典，是一种用于保存键值对（key-value pair）的抽象数据结构。字典经常作为一种数据结构内置在很多高级编程语言里面，但Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 哈希表数组，数组中每个元素指向 dictEntry 结构</span>dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>    <span class="token comment">// 哈希表大小，数组的长度</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token comment">// 哈希表大小掩码，用于计算索引值，总是等于 【size-1】</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>    <span class="token comment">// 该哈希表已有节点的数量 </span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> dictht<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哈希表节点结构：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 键</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token comment">// 值，可以是一个指针，或者整数</span><span class="token keyword">union</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span><span class="token comment">// 指针</span>        <span class="token class-name">uint64_t</span> u64<span class="token punctuation">;</span>        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> v<span class="token punctuation">;</span>    <span class="token comment">// 指向下个哈希表节点，形成链表，用来解决哈希冲突(collision)问题</span>    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> dictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h4><p>字典，又称为符号表、关联数组、映射（Map），用于保存键值对的数据结构，字典中的每个键都是独一无二的。底层采用哈希表实现，一个哈希表包含多个哈希表节点，每个节点保存一个键值对</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 类型特定函数</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>        <span class="token comment">// 私有数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>        <span class="token comment">// 哈希表，数组中的每个项都是一个dictht哈希表，</span>    <span class="token comment">// 一般情况下字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span>    <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> dict<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数</li><li>privdata 属性保存了需要传给那些类型特定函数的可选参数</li></ul><p>下面是一个普通状态下（没有进行rehash）的字典</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><hr><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>将一个新的键值对添加到字典里，需要先根据键值计算出哈希值，然后对哈希值和sizemask取模运算（取余），得到索引值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> dict<span class="token operator">-></span>ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>sizemask<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据索引值，把哈希表节点放到哈希表数组的指定索引上面。</p><p>Redis 使用 <code>MurmurHash2</code> 算法来计算键的哈希值，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快</p><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，就称这些键发生了<strong>哈希冲突（collision）</strong></p><p>Redis 的哈希表使用<strong>链地址法（separate chaining）</strong>来解决键哈希冲突， 每个哈希表节点都有一个 next 指针，多个节点通过 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p><p>dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，程序总是将新节点添加到链表的表头位置（<strong>头插法</strong>），时间复杂度为 O(1)</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%AD%97%E5%85%B8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png"></p><hr><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>负载因子的计算方式：哈希表中的<strong>节点数量</strong> &#x2F; 哈希表的大小（<strong>长度</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>used <span class="token operator">/</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了让哈希表的<strong>负载因子（load factor）</strong>维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时 ，程序会自动对哈希表的大小进行相应的扩展或者收缩</p><p>哈希表执行扩容的条件：</p><ul><li><p>服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 1</p></li><li><p>服务器正在执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 5</p><p>原因：执行这两个命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on­-write）技术来优化子进程的使用效率，通过提高执行扩展操作的负载因子，尽可能地避免在子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</p></li></ul><p>哈希表执行收缩的条件：负载因子小于 0.1（自动执行，servreCron 中检测）</p><hr><h4 id="重新散列"><a href="#重新散列" class="headerlink" title="重新散列"></a>重新散列</h4><p>扩展和收缩哈希表的操作通过 <strong>rehash（重新散列）</strong>来完成，步骤如下：</p><ul><li>为字典的 ht[1] 哈希表分配空间，空间大小取决于要执行的操作：<ul><li>如果执行的是扩展操作，ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n</li><li>如果执行的是收缩操作，ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n</li></ul></li><li>将保存在 ht[0] 中所有的键值对重新计算哈希值和索引值，迁移到 ht[1] 上</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 创建一个新的空白哈希表，为下一次 rehash 做准备</li></ul><p>如果哈希表里保存的键值对数量很少，rehash 就可以在瞬间完成，但是如果哈希表里数据很多，那么要一次性将这些键值对全部 rehash 到 ht[1] 需要大量计算，可能会导致服务器在一段时间内停止服务</p><p>因此，为了避免rehash对服务器性能造成影响，Redis 对 rehash 做了优化，使 rehash 的动作并不是一次性、集中式的完成，而是分多次，渐进式的完成，又叫<strong>渐进式 rehash</strong></p><p>以下是渐进式rehash的详细步骤：</p><ul><li>为 ht[1] 分配空间，此时字典同时持有 ht[0] 和 ht[1] 两个哈希表</li><li>在字典中维护了一个索引计数器变量 rehashidx，并将变量的值设为 0，表示 rehash 正式开始</li><li>在 rehash 进行期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后<strong>将 rehashidx 属性的值增一</strong></li><li>随着字典操作的不断执行，最终在某个时间点 ht[0] 的所有键值对都被 rehash 至 ht[1]，将 rehashidx 属性的值设为 -1</li></ul><p>渐进式 rehash 采用<strong>分而治之</strong>的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 带来的庞大计算量</p><p>渐进式 rehash 期间的哈希表操作：</p><ul><li>字典的查找、删除、更新操作会在两个哈希表上进行，比如查找一个键会先在 ht[0] 上查找，查找不到就去 ht[1] 继续查找</li><li>字典的添加操作会直接在 ht[1] 上添加，不在 ht[0] 上进行任何添加</li></ul><hr><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>跳跃表（skiplist）是一种有序（<strong>默认升序</strong>）的数据结构，在链表的基础上<strong>增加了多级索引以提升查找的效率</strong>，索引是占内存的，所以是一个<strong>空间换时间</strong>的方案，跳表平均 O(logN)、最坏 O(N) 复杂度的节点查找，效率与平衡树相当但是实现更简单</p><p>Redis 只在两个地方应用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。如果一个有序集合包含的元素数量比较多，又或者有序集合中的元素是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E8%B7%B3%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 表头节点和表尾节点，O(1) 的时间复杂度定位头尾节点</span>    <span class="token keyword">struct</span> <span class="token class-name">skiplistNode</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>        <span class="token comment">// 表的长度，也就是表内的节点数量 (表头节点不计算在内)</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>        <span class="token comment">// 表中层数最大的节点的层数 (表头节点的层高不计算在内)</span>    <span class="token keyword">int</span> level<span class="token punctuation">&#125;</span> zskiplist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 层</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 前进指针</span>        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>        <span class="token comment">// 跨度</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 后退指针</span>    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>        <span class="token comment">// 分值</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>        <span class="token comment">// 成员对象</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> zskiplistNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>层：</strong>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层加快访问其他节点的速度，一般来说，层数越多，访问其他节点的速度越快。</p><p><strong>跨度：</strong>层的跨度（level[i].span属性）用于记录两个节点之间的距离；初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样，遍历操作只使用前进指针就可以完成，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p><strong>分值和成员：</strong>节点的分值（score属性）是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序，当分值相同时，节点按照成员对象的大小进行排序。节点的成员对象（obj属性）是一个指针，它指向一个字符串对象。</p><hr><h4 id="属性分析"><a href="#属性分析" class="headerlink" title="属性分析"></a>属性分析</h4><p><strong>层：</strong>level 数组包含多个元素，每个元素包含指向其他节点的指针。根据幕次定律（power law，越大的数出现的概率越小）<strong>随机</strong>生成一个介于 1 和 32 之间的值（Redis5 之后最大为 64）作为 level 数组的大小，这个大小就是层的高度，节点的第一层是 level[0] &#x3D; L1</p><p><strong>前进指针：</strong>forward 用于从表头到表尾方向<strong>正序（升序）遍历节点</strong>，遇到 NULL 停止遍历</p><p><strong>跨度：</strong>level[i].span 用于记录两个节点之间的距离，用来计算排位（rank）：</p><ul><li><p>两个节点之间的跨度越大相距的就越远，指向 NULL 的所有前进指针的跨度都为 0</p></li><li><p>在查找某个节点的过程中，<strong>将沿途访问过的所有层的跨度累计起来，结果就是目标节点在跳跃表中的排位</strong></p></li></ul><p><strong>后退指针：</strong>backward 用于从表尾到表头方向<strong>逆序（降序）遍历节点</strong></p><p><strong>分值：</strong>score 属性，一个 double 类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</p><p><strong>成员对象：</strong>obj 属性是一个指针，指向一个 SDS 字符串对象。同一个跳跃表中，各个节点保存的<strong>成员对象必须是唯一的</strong>，但是多个节点保存的分值可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序（从小到大）</p><p>个人笔记：JUC → 并发包 → ConcurrentSkipListMap 详解跳跃表</p><hr><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>整数集合（intset）是用于保存整数值的集合数据结构，是 Redis 集合键的底层实现之一。当一个集合集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">&#123;</span><span class="token comment">// 编码方式</span><span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>    <span class="token comment">// 集合包含的元素数量，也就是 contents 数组的长度</span><span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>    <span class="token comment">// 保存元素的数组</span>    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> intset<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>encoding 取值为三种：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64</p><p>整数集合的每个元素都是 contents 数组的一个数组项（item），在数组中按值的大小从小到大<strong>有序排列</strong>，并且数组中<strong>不包含任何重复项</strong>。虽然 contents 属性声明为 int8_t 类型，但实际上数组并不保存任何 int8_t 类型的值， 真正类型取决于 encoding 属性</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>说明：底层存储结构是数组，所以为了保证有序性和不重复性，每次添加一个元素的时间复杂度是 O(N)</p><hr><h4 id="类型升级"><a href="#类型升级" class="headerlink" title="类型升级"></a>类型升级</h4><p>整数集合添加的新元素的类型比集合现有所有元素的类型都要长时，需要先进行升级（upgrade），升级流程：</p><ul><li><p>根据新元素的类型长度以及集合元素的数量（包括新元素在内），扩展整数集合底层数组的空间大小</p></li><li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放入正确的位置，放置过程保证数组的有序性</p><p>图示 32 * 4 &#x3D; 128 位，首先将 3 放入索引 2（64 位 - 95 位），然后将 2 放置索引 1，将 1 放置在索引 0，从后向前依次放置在对应的区间，最后放置 65535 元素到索引 3（96 位- 127 位），修改 length 属性为 4</p></li><li><p>将新元素添加到底层数组里</p></li></ul><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7.png"></p><p>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为 O(N)</p><p>引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，升级之后新元素的摆放位置：</p><ul><li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引 0）</li><li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引 length-1）</li></ul><p>整数集合升级策略的好处：</p><ul><li><p>提升整数集合的灵活性：C 语言是静态类型语言，为了避免类型错误通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以自动升级底层数组来适应新元素，所以可以随意的添加整数</p></li><li><p>节约内存：要让数组可以同时保存 int16、int32、int64 三种类型的值，可以直接使用 int64_t 类型的数组作为整数集合的底层实现，但是会造成内存浪费，整数集合可以确保升级操作只会在有需要的时候进行，尽量节省内存</p></li></ul><p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态</p><hr><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><h4 id="底层结构-2"><a href="#底层结构-2" class="headerlink" title="底层结构"></a>底层结构</h4><p>压缩列表（ziplist）是 Redis 为了节约内存而开发的，是列表键和哈希键的底层实现之一。是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><ul><li>zlbytes：uint32_t 类型 4 字节，记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算 zlend 的位置时使用</li><li>zltail：uint32_t 类型 4 字节，记录压缩列表表尾节点距离起始地址有多少字节，通过这个偏移量程序无须遍历整个压缩列表就可以确定表尾节点的地址</li><li>zllen：uint16_t 类型 2 字节，记录了压缩列表包含的节点数量，当该属性的值小于 UINT16_MAX (65535) 时，该值就是压缩列表中节点的数量；当这个值等于 UINT16_MAX 时节点的真实数量需要遍历整个压缩列表才能计算得出</li><li>entryX：列表节点，压缩列表中的各个节点，<strong>节点的长度由节点保存的内容决定</strong></li><li>zlend：uint8_t 类型 1 字节，是一个特殊值 0xFF (255)，用于标记压缩列表的末端</li></ul><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png"></p><p>列表 zlbytes 属性的值为 0x50 (十进制 80)，表示压缩列表的总长为 80 字节，列表 zltail 属性的值为 0x3c (十进制 60)，假设表的起始地址为 p，计算得出表尾节点 entry3 的地址 p + 60</p><hr><h4 id="列表节点"><a href="#列表节点" class="headerlink" title="列表节点"></a>列表节点</h4><p>列表节点 entry 的数据结构：</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png"></p><p>previous_entry_length：以字节为单位记录了压缩列表中前一个节点的长度，程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，完成<strong>从表尾向表头遍历</strong>操作</p><ul><li>如果前一节点的长度小于 254 字节，该属性的长度为 1 字节，前一节点的长度就保存在这一个字节里</li><li>如果前一节点的长度大于等于 254 字节，该属性的长度为 5 字节，其中第一字节会被设置为 0xFE（十进制 254），之后的四个字节则用于保存前一节点的长度</li></ul><p>encoding：记录了节点的 content 属性所保存的数据类型和长度</p><ul><li><p><strong>长度为 1 字节、2 字节或者 5 字节</strong>，值的最高位为 00、01 或者 10 的是字节数组编码，数组的长度由编码除去最高两位之后的其他位记录，下划线 <code>_</code> 表示留空，而 <code>b</code>、<code>x</code> 等变量则代表实际的二进制数据</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png"></p></li><li><p>长度为 1 字节，值的最高位为 11 的是整数编码，整数值的类型和长度由编码除去最高两位之后的其他位记录</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png"></p></li></ul><p>content：每个压缩列表节点可以保存一个字节数组或者一个整数值</p><ul><li><p>字节数组可以是以下三种长度的其中一种：</p><ul><li><p>长度小于等于 $63 (2^6-1)$ 字节的字节数组</p></li><li><p>长度小于等于 $16383(2^{14}-1)$ 字节的字节数组</p></li><li><p>长度小于等于 $4294967295(2^{32}-1)$ 字节的字节数组</p></li></ul></li><li><p>整数值则可以是以下六种长度的其中一种：</p><ul><li><p>4 位长，介于 0 至 12 之间的无符号整数</p></li><li><p>1 字节长的有符号整数</p></li><li><p>3 字节长的有符号整数</p></li><li><p>int16_t 类型整数</p></li><li><p>int32_t 类型整数</p></li><li><p>int64_t 类型整数</p></li></ul></li></ul><hr><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>Redis 将在特殊情况下产生的连续多次空间扩展操作称之为连锁更新（cascade update）</p><p>假设在一个压缩列表中，有多个连续的、长度介于 250 到 253 字节之间的节点 e1 至 eN。将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的头节点，new 就成为 e1 的前置节点。e1 的 previous_entry_length 属性仅为 1 字节，无法保存新节点 new 的长度，所以要对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从 1 字节长扩展为 5 字节长。由于 e1 原本的长度介于 250 至 253 字节之间，所以扩展后 e1 的长度就变成了 254 至 257 字节之间，导致 e2 的  previous_entry_length 属性无法保存 e1 的长度，程序需要不断地对压缩列表执行空间重分配操作，直到 eN 为止</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B01.png"></p><p> 删除节点也可能会引发连锁更新，big.length &gt;&#x3D; 254，small.length &lt; 254，删除 small 节点</p><p><img src="/2023/12/07/redis-chang-jian-shu-ju-jie-gou-he-shu-ju-lei-xing/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B02.png"></p><p>连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配，每次重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)</p><p>说明：尽管连锁更新的复杂度较高，但出现的记录是非常低的，即使出现只要被更新的节点数量不多，就不会对性能造成影响</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC和AOP详解</title>
      <link href="/2023/11/29/ioc-he-aop-xiang-jie/"/>
      <url>/2023/11/29/ioc-he-aop-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>ApplicationContext：</p><ol><li><p>ApplicationContext 是一个接口，提供了访问 Spring 容器的 API</p></li><li><p>ClassPathXmlApplicationContext 是一个类，实现了上述功能</p></li><li><p>ApplicationContext 的顶层接口是 BeanFactory</p></li><li><p>BeanFactory 定义了 bean 相关的最基本操作</p></li><li><p>ApplicationContext 在 BeanFactory 基础上追加了若干新功能</p></li></ol><p><strong>ApplicationContext 和 BeanFactory对比：</strong></p><ul><li><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器</p></li><li><p>BeanFactory 是 Spring 里面最底层的接口，是 IoC 的核心，定义了 IoC 的基本功能，包含了各种 Bean 的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext 接口作为 BeanFactory 的子类，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承 MessageSource，因此支持国际化</li><li>资源文件访问，如 URL 和文件（ResourceLoader）。</li><li>载入多个（有继承关系）上下文（即加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层</li><li>提供在监听器中注册 bean 的事件</li></ul></li><li><p>BeanFactory 创建的 bean 采用延迟加载形式，只有在使用到某个 Bean 时（调用 getBean），才对该 Bean 进行加载实例化（Spring 早期使用该方法获取 bean），这样就不能提前发现一些存在的 Spring 的配置问题；ApplicationContext 是在容器启动时，一次性创建了所有的 Bean，容器启动时，就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入</p></li><li><p>ApplicationContext 启动后预载入所有的单实例 Bean，所以程序启动慢，运行时速度快</p></li><li><p>两者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</p></li></ul><p>FileSystemXmlApplicationContext：加载文件系统中任意位置的配置文件，而 ClassPathXmlAC 只能加载类路径下的配置文件</p><p><img src="/2023/11/29/ioc-he-aop-xiang-jie/Spring-ApplicationContext%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>BeanFactory 的成员属性：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token constant">FACTORY_BEAN_PREFIX</span> <span class="token operator">=</span> <span class="token string">"&amp;"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>区分是 FactoryBean 还是创建的 Bean，加上 &amp; 代表是工厂，getBean 将会返回工厂</li><li>FactoryBean：如果某个 bean 的配置非常复杂，或者想要使用编码的形式去构建它，可以提供一个构建该 bean 实例的工厂，这个工厂就是 FactoryBean 接口实现类，FactoryBean 接口实现类也是需要 Spring 管理<ul><li>这里产生两种对象，一种是 FactoryBean 接口实现类（IOC 管理），另一种是 FactoryBean 接口内部管理的对象</li><li>获取 FactoryBean 接口实现类，使用 getBean 时传的 beanName 需要带 &amp; 开头</li><li>获取 FactoryBean 内部管理的对象，不需要带 &amp; 开头</li></ul></li></ul><p>BeanFactory 的基本使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Resource</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BeanFactory</span> bf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XmlBeanFactory</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">)</span>bf<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"userService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p>FactoryBean：对单一的 bean 的初始化过程进行封装，达到简化配置的目的</p><p>代码实现：</p><ul><li><p>FactoryBean，实现类一般是 MapperFactoryBean，创建 DAO 层接口的实现类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EquipmentDaoImplFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span><span class="token comment">//获取Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EquipmentDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span><span class="token comment">//获取bean的类型</span>    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span><span class="token comment">//是否单例</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>MapperFactoryBean 继承 SqlSessionDaoSupport，可以获取 SqlSessionTemplate，完成 MyBatis 的整合</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionDaoSupport</span> <span class="token keyword">extends</span> <span class="token class-name">DaoSupport</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">SqlSessionTemplate</span> sqlSessionTemplate<span class="token punctuation">;</span><span class="token comment">// 获取 SqlSessionTemplate 对象</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSqlSessionFactory</span><span class="token punctuation">(</span><span class="token class-name">SqlSessionFactory</span> sqlSessionFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplate <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>         sqlSessionFactory <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplate<span class="token punctuation">.</span><span class="token function">getSqlSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionTemplate <span class="token operator">=</span> <span class="token function">createSqlSessionTemplate</span><span class="token punctuation">(</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="两者区别："><a href="#两者区别：" class="headerlink" title="两者区别："></a>两者区别：</h5><ul><li>BeanFactory：IoC容器顶层接口，给IoC容器提供了一套完整的规范。以Factory结尾，表示它是一个工厂类（接口），用于管理Bean的一个工厂。</li><li>FactoryBean：也是一个工厂类接口，用户可以通过该接口定制实例化Bean的逻辑，Spring自身就提供了70多个FactoryBean的实现，他们隐藏了一些实例化复杂Bean的细节，从而给上层应用带来便捷</li></ul><hr><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><ul><li><p>DAO 层 UserDao、AccountDao、BookDao、EquipmentDao</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserDao</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user dao running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Service 业务层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">"userService"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span><span class="token comment">//...........BookDao等</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user service running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h5 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h5><p>名称：TypeFilter</p><p>类型：<strong>接口</strong></p><p>作用：自定义类型过滤器</p><p>示例：</p><ul><li><p>config &#x2F; filter &#x2F; MyTypeFilter</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTypeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">TypeFilter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment">/**    * metadataReader:读取到的当前正在扫描的类的信息    * metadataReaderFactory:可以获取到任何其他类的信息    */</span>    <span class="token comment">//加载的类满足要求，匹配成功</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">MetadataReader</span> metadataReader<span class="token punctuation">,</span> <span class="token class-name">MetadataReaderFactory</span> metadataReaderFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取当前类注解的信息</span><span class="token class-name">AnnotationMetadata</span> am <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getAnnotationMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前正在扫描的类的类信息</span><span class="token class-name">ClassMetadata</span> classMetadata <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getClassMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前类资源（类的路径）</span><span class="token class-name">Resource</span> resource <span class="token operator">=</span> metadataReader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//通过类的元数据获取类的名称</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> classMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果加载的类名满足过滤器要求，返回匹配成功</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"service.impl.UserServiceImpl"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token comment">//返回true表示匹配成功，返回false表示匹配失败。此处仅确认匹配结果，不会确认是排除还是加入，排除/加入由配置项决定，与此处无关</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>SpringConfig</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token comment">//设置排除bean，排除的规则是自定义规则（FilterType.CUSTOM），具体的规则定义为MyTypeFilter</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>        value <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"dao"</span><span class="token punctuation">,</span><span class="token string">"service"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        excludeFilters <span class="token operator">=</span> <span class="token annotation punctuation">@ComponentScan.Filter</span><span class="token punctuation">(</span>                type<span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span>                classes <span class="token operator">=</span> <span class="token class-name">MyTypeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="导入器"><a href="#导入器" class="headerlink" title="导入器"></a>导入器</h4><p>bean 只有通过配置才可以进入 Spring 容器，被 Spring 加载并控制</p><ul><li><p>配置 bean 的方式如下：</p><ul><li>XML 文件中使用 <bean> 标签配置</bean></li><li>使用 @Component 及衍生注解配置</li></ul></li></ul><p>导入器可以快速高效导入大量 bean，替代 @Import({a.class,b.class})，无需在每个类上添加 @Bean</p><p>名称： ImportSelector</p><p>类型：<strong>接口</strong></p><p>作用：自定义bean导入器</p><ul><li><p>selector &#x2F; MyImportSelector</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//      1.编程形式加载一个类</span><span class="token comment">//      return new String[]&#123;"dao.impl.BookDaoImpl"&#125;;</span><span class="token comment">//      2.加载import.properties文件中的单个类名</span><span class="token comment">//      ResourceBundle bundle = ResourceBundle.getBundle("import");</span><span class="token comment">//      String className = bundle.getString("className");</span><span class="token comment">//      3.加载import.properties文件中的多个类名</span>        <span class="token class-name">ResourceBundle</span> bundle <span class="token operator">=</span> <span class="token class-name">ResourceBundle</span><span class="token punctuation">.</span><span class="token function">getBundle</span><span class="token punctuation">(</span><span class="token string">"import"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> bundle<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"className"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> className<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>import.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#2.加载import.properties文件中的单个类名</span><span class="token comment">#className=dao.impl.BookDaoImpl</span><span class="token comment">#3.加载import.properties文件中的多个类名</span><span class="token comment">#className=dao.impl.BookDaoImpl,dao.impl.AccountDaoImpl</span><span class="token comment">#4.导入包中的所有类</span><span class="token key attr-name">path</span><span class="token punctuation">=</span><span class="token value attr-value">dao.impl.*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>SpringConfig</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"dao"</span><span class="token punctuation">,</span><span class="token string">"service"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">MyImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="注册器"><a href="#注册器" class="headerlink" title="注册器"></a>注册器</h4><p>可以取代 ComponentScan 扫描器</p><p>名称：ImportBeanDefinitionRegistrar</p><p>类型：<strong>接口</strong></p><p>作用：自定义 bean 定义注册器</p><ul><li><p>registrar &#x2F; MyImportBeanDefinitionRegistrar</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportBeanDefinitionRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">&#123;</span><span class="token comment">/** * AnnotationMetadata:当前类的注解信息 * BeanDefinitionRegistry:BeanDefinition注册类，把所有需要添加到容器中的bean调用registerBeanDefinition手工注册进来 */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//自定义注册器</span>        <span class="token comment">//1.开启类路径bean定义扫描器，需要参数bean定义注册器BeanDefinitionRegistry，需要制定是否使用默认类型过滤器</span>        <span class="token class-name">ClassPathBeanDefinitionScanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathBeanDefinitionScanner</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.添加包含性加载类型过滤器（可选，也可以设置为排除性加载类型过滤器）</span>        scanner<span class="token punctuation">.</span><span class="token function">addIncludeFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">MetadataReader</span> metadataReader<span class="token punctuation">,</span> <span class="token class-name">MetadataReaderFactory</span> metadataReaderFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//所有匹配全部成功，此处应该添加实际的业务判定条件</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置扫描路径</span>        scanner<span class="token punctuation">.</span><span class="token function">addExcludeFilter</span><span class="token punctuation">(</span>tf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排除</span>        scanner<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token string">"dao"</span><span class="token punctuation">,</span><span class="token string">"service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>SpringConfig</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">MyImportBeanDefinitionRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>通过创建类<strong>继承相应的处理器的接口</strong>，重写后置处理的方法，来实现<strong>拦截 Bean 的生命周期</strong>来实现自己自定义的逻辑</p><p>BeanPostProcessor：bean 后置处理器，bean 创建对象初始化前后进行拦截工作的</p><p>BeanFactoryPostProcessor：beanFactory 的后置处理器</p><ul><li><pre><code>    加载时机：在 BeanFactory 初始化之后调用，来定制和修改 BeanFactory 的内容；所有的 bean 定义已经保存加载到 beanFactory，但是 bean 的实例还未创建</code></pre></li><li><pre><code>    执行流程：</code></pre><ul><li>ioc 容器创建对象</li><li>invokeBeanFactoryPostProcessors(beanFactory)：执行 BeanFactoryPostProcessor<ul><li>在 BeanFactory 中找到所有类型是 BeanFactoryPostProcessor 的组件，并执行它们的方法</li><li>在初始化创建其他组件前面执行</li></ul></li></ul></li></ul><p>BeanDefinitionRegistryPostProcessor：</p><ul><li><p>加载时机：在所有 bean 定义信息将要被加载，但是 bean 实例还未创建，优先于 BeanFactoryPostProcessor 执行；利用 BeanDefinitionRegistryPostProcessor 给容器中再额外添加一些组件</p></li><li><p>执行流程：</p><ul><li>ioc 容器创建对象</li><li>refresh() → invokeBeanFactoryPostProcessors(beanFactory)</li><li>从容器中获取到所有的 BeanDefinitionRegistryPostProcessor 组件<ul><li>依次触发所有的 postProcessBeanDefinitionRegistry() 方法</li><li>再来触发 postProcessBeanFactory() 方法</li></ul></li></ul></li></ul><hr><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><h5 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h5><p>ApplicationListener：监听容器中发布的事件，完成事件驱动模型开发</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以监听 ApplicationEvent 及其下面的子事件</p><p>应用监听器步骤：</p><ul><li><pre><code>  写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）</code></pre></li><li><pre><code>  把监听器加入到容器 @Component</code></pre></li><li><pre><code>  只要容器中有相关事件的发布，就能监听到这个事件；</code></pre><ul><li><pre><code>  ContextRefreshedEvent：容器刷新完成（所有 bean 都完全创建）会发布这个事件</code></pre></li><li><pre><code>  ContextClosedEvent：关闭容器会发布这个事件</code></pre></li></ul></li><li><pre><code>  发布一个事件：`applicationContext.publishEvent()`</code></pre></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApplicationListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token comment">//当容器中发布此事件以后，方法触发</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到事件："</span> <span class="token operator">+</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>ContextRefreshedEvent 事件：</p><ul><li><p>容器初始化过程中执行 <code>initApplicationEventMulticaster()</code>：初始化事件多播器</p><ul><li>先去容器中查询 <code>id = applicationEventMulticaster</code> 的组件，有直接返回</li><li>没有就执行 <code>this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory)</code> 并且加入到容器中</li><li>以后在其他组件要派发事件，自动注入这个 applicationEventMulticaster</li></ul></li><li><p>容器初始化过程执行 <strong>registerListeners()</strong> 注册监听器</p><ul><li>从容器中获取所有监听器：<code>getBeanNamesForType(ApplicationListener.class, true, false)</code></li><li>将 listener 注册到 ApplicationEventMulticaster</li></ul></li><li><p>容器刷新完成：finishRefresh() → publishEvent(new ContextRefreshedEvent(this))</p><p>发布 ContextRefreshedEvent 事件：</p><ul><li>获取事件的多播器（派发器）：getApplicationEventMulticaster()</li><li>multicastEvent 派发事件<ul><li>获取到所有的 ApplicationListener</li><li>遍历 ApplicationListener<ul><li>如果有 Executor，可以使用 Executor 异步派发 <code>Executor executor = getTaskExecutor()</code></li><li>没有就同步执行 listener 方法 <code>invokeListener(listener, event)</code>，拿到 listener 回调 onApplicationEvent</li></ul></li></ul></li></ul></li></ul><p>容器关闭会发布 ContextClosedEvent</p><hr><h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><p>注解：@EventListener</p><p>基本使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@EventListener</span><span class="token punctuation">(</span>classes<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token class-name">ApplicationEvent</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"UserService。。监听到的事件："</span> <span class="token operator">+</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原理：使用 EventListenerMethodProcessor 处理器来解析方法上的 @EventListener，Spring 扫描使用注解的方法，并为之创建一个监听对象</p><p>SmartInitializingSingleton 原理：afterSingletonsInstantiated()</p><ul><li><pre><code>    IOC 容器创建对象并 refresh()</code></pre></li><li><pre><code>    finishBeanFactoryInitialization(beanFactory)：初始化剩下的单实例 bean</code></pre><ul><li>先创建所有的单实例 bean：getBean()</li><li>获取所有创建好的单实例 bean，判断是否是 SmartInitializingSingleton 类型的，如果是就调用 afterSingletonsInstantiated()</li></ul></li></ul><h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><h4 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h4><p>@EnableAspectJAutoProxy：AOP 注解驱动，给容器中导入 AspectJAutoProxyRegistrar</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">AspectJAutoProxyRegistrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAspectJAutoProxy</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 是否强制使用 CGLIB 创建代理对象 </span>    <span class="token comment">// 配置文件方式：&lt;aop:aspectj-autoproxy proxy-target-class="true"/></span><span class="token keyword">boolean</span> <span class="token function">proxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// 将当前代理对象暴露到上下文内，方便代理对象内部的真实对象拿到代理对象</span>    <span class="token comment">// 配置文件方式：&lt;aop:aspectj-autoproxy expose-proxy="true"/></span><span class="token keyword">boolean</span> <span class="token function">exposeProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AspectJAutoProxyRegistrar 在用来向容器中注册 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>，以 BeanDefiantion 形式存在，在容器初始化时加载。AnnotationAwareAspectJAutoProxyCreator 间接实现了 InstantiationAwareBeanPostProcessor，Order 接口，该类会在 Bean 的实例化和初始化的前后起作用</p><p>工作流程：创建 IOC 容器，调用 refresh() 刷新容器，<code>registerBeanPostProcessors(beanFactory)</code> 阶段，通过 getBean() 创建 AnnotationAwareAspectJAutoProxyCreator 对象，在生命周期的初始化方法中执行回调 initBeanFactory() 方法初始化注册三个工具类：BeanFactoryAdvisorRetrievalHelperAdapter、ReflectiveAspectJAdvisorFactory、BeanFactoryAspectJAdvisorsBuilderAdapter</p><hr><h4 id="后置处理"><a href="#后置处理" class="headerlink" title="后置处理"></a>后置处理</h4><p>Bean 初始化完成的执行后置处理器的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span> bean<span class="token punctuation">,</span><span class="token class-name">String</span> bN<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// cacheKey 是 【beanName 或者加上 &amp; 的 beanName】</span>        <span class="token class-name">Object</span> cacheKey <span class="token operator">=</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span> <span class="token operator">!=</span> bean<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 去提前代理引用池中寻找该 key，不存在则创建代理</span>                <span class="token comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span>                <span class="token keyword">return</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> bN<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AbstractAutoProxyCreator.wrapIfNecessary()：根据通知创建动态代理，没有通知直接返回原实例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Object</span> cacheKey<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 条件一般不成立，很少使用 TargetSourceCreator 去创建对象 BeforeInstantiation 阶段，doCreateBean 之前的阶段</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">hasLength</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>targetSourcedBeans<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// advisedBeans 集合保存的是 bean 是否被增强过了</span>    <span class="token comment">// 条件成立说明当前 beanName 对应的实例不需要被增强处理，判断是在 BeforeInstantiation 阶段做的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">FALSE</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 条件一：判断当前 bean 类型是否是基础框架类型，这个类的实例不能被增强</span>    <span class="token comment">// 条件二：shouldSkip 判断当前 beanName 是否是 .ORIGINAL 结尾，如果是就跳过增强逻辑，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInfrastructureClass</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">shouldSkip</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">FALSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 【查找适合当前 bean 实例的增强方法】（下一节详解）</span>    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> specificInterceptors <span class="token operator">=</span> <span class="token function">getAdvicesAndAdvisorsForBean</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 条件成立说明上面方法查询到适合当前class的通知</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>specificInterceptors <span class="token operator">!=</span> <span class="token constant">DO_NOT_PROXY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 根据查询到的增强创建代理对象（下一节详解）</span>        <span class="token comment">// 参数一：目标对象</span>        <span class="token comment">// 参数二：beanName</span>        <span class="token comment">// 参数三：匹配当前目标对象 clazz 的 Advisor 数据</span>        <span class="token class-name">Object</span> proxy <span class="token operator">=</span> <span class="token function">createProxy</span><span class="token punctuation">(</span>            bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> specificInterceptors<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTargetSource</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 保存代理对象类型</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>proxyTypes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> proxy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回代理对象</span>        <span class="token keyword">return</span> proxy<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 执行到这里说明没有查到通知，当前 bean 不需要增强</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">FALSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 【返回原始的 bean 实例】</span>    <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h4><p>AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()：查找适合当前类实例的增强，并进行排序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAdvicesAndAdvisorsForBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">TargetSource</span> targetSource<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 查询适合当前类型的增强通知</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Advisor</span><span class="token punctuation">></span></span> advisors <span class="token operator">=</span> <span class="token function">findEligibleAdvisors</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>advisors<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 增强为空直接返回 null，不需要创建代理</span>        <span class="token keyword">return</span> <span class="token constant">DO_NOT_PROXY</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 不是空，转成数组返回</span>    <span class="token keyword">return</span> advisors<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()：</p><ul><li><p><code>candidateAdvisors = findCandidateAdvisors()</code>：<strong>获取当前容器内可以使用（所有）的 advisor</strong>，调用的是 AnnotationAwareAspectJAutoProxyCreator 类的方法，每个方法对应一个 Advisor </p><ul><li><p><code>advisors = super.findCandidateAdvisors()</code>：<strong>查询出 XML 配置的所有 Advisor 类型</strong></p><ul><li><code>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors()</code>：通过 BF 查询出来 BD 配置的 class 中 是 Advisor 子类的 BeanName</li><li><code>advisors.add()</code>：使用 Spring 容器获取当前这个 Advisor 类型的实例</li></ul></li><li><p><code>advisors.addAll(....buildAspectJAdvisors())</code>：<strong>获取所有添加 @Aspect 注解类中的 Advisor</strong></p><p><code>buildAspectJAdvisors()</code>：构建的方法，<strong>把 Advice 封装成 Advisor</strong></p><ul><li><p><code> beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)</code>：获取出容器内 Object 所有的 beanName，就是全部的</p></li><li><p><code> for (String beanName : beanNames)</code>：遍历所有的 beanName，判断每个 beanName 对应的 Class 是否是 Aspect 类型，就是加了 @Aspect 注解的类</p><ul><li><p><code>factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName)</code>：使用工厂模式管理 Aspect 的元数据，关联的真实 @Aspect 注解的实例对象</p></li><li><p><code>classAdvisors = this.advisorFactory.getAdvisors(factory)</code>：添加了 @Aspect 注解的类的通知信息</p><ul><li><p>aspectClass：@Aspect 标签的类的 class</p></li><li><p><code>for (Method method : getAdvisorMethods(aspectClass))</code>：遍历<strong>不包括 @Pointcut 注解的方法</strong></p><p><code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName)</code>：<strong>将当前 method 包装成 Advisor 数据</strong></p><ul><li><p><code>AspectJExpressionPointcut expressionPointcut = getPointcut()</code>：获取切点表达式</p></li><li><p><code>return new InstantiationModelAwarePointcutAdvisorImpl()</code>：把 method 中 Advice 包装成 Advisor，Spring 中每个 Advisor 内部一定是持有一个 Advice 的，Advice 内部最重要的数据是当前 method 和aspectInstanceFactory，工厂用来获取实例</p><p><code>this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut)</code>：实例化 Advice 对象，逻辑是获取注解信息，根据注解的不同生成对应的 Advice 对象</p></li></ul></li></ul></li><li><p><code>advisors.addAll(classAdvisors)</code>：保存通过 @Aspect 注解定义的 Advisor 数据</p></li></ul></li><li><p><code>this.aspectBeanNames = aspectNames</code>：将所有 @Aspect 注解 beanName 缓存起来，表示提取 Advisor 工作完成</p></li><li><p><code>return advisors</code>：返回 Advisor 列表</p></li></ul></li></ul></li><li><p><code>eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, ...)</code>：<strong>选出匹配当前类的增强</strong></p><ul><li><p><code>if (candidateAdvisors.isEmpty())</code>：条件成立说明当前 Spring 没有可以操作的 Advisor</p></li><li><p><code>List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;()</code>：存放匹配当前 beanClass 的 Advisors 信息</p></li><li><p><code>for (Advisor candidate : candidateAdvisors)</code>：<strong>遍历所有的 Advisor</strong></p><p><code> if (canApply(candidate, clazz, hasIntroductions))</code>：判断遍历的 advisor 是否匹配当前的 class，匹配就加入集合</p><ul><li><p><code>if (advisor instanceof PointcutAdvisor)</code>：创建的 advisor 是 InstantiationModelAwarePointcutAdvisorImpl 类型</p><p><code>PointcutAdvisor pca = (PointcutAdvisor) advisor</code>：封装当前 Advisor</p><p><code>return canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>：重载该方法</p><ul><li><code>if (!pc.getClassFilter().matches(targetClass))</code>：<strong>类不匹配 Pointcut 表达式，直接返回 false</strong></li><li><code>methodMatcher = pc.getMethodMatcher()</code>：<strong>获取 Pointcut 方法匹配器</strong>，类匹配进行类中方法的匹配</li><li><code>Set&lt;Class&lt;?&gt;&gt; classes</code>：保存目标对象 class 和目标对象父类超类的接口和自身实现的接口</li><li><code>if (!Proxy.isProxyClass(targetClass))</code>：判断当前实例是不是代理类，确保 class 内存储的数据包括目标对象的class  而不是代理类的 class</li><li><code>for (Class&lt;?&gt; clazz : classes)</code>：<strong>检查目标 class 和上级接口的所有方法，查看是否会被方法匹配器匹配</strong>，如果有一个方法匹配成功，就说明目标对象 AOP 代理需要增强<ul><li><code>specificMethod = AopUtils.getMostSpecificMethod(method, targetClass)</code>：方法可能是接口的，判断当前类有没有该方法</li><li><code>return (specificMethod != method &amp;&amp; matchesMethod(specificMethod))</code>：<strong>类和方法的匹配</strong>，不包括参数</li></ul></li></ul></li></ul></li></ul></li><li><p><code>extendAdvisors(eligibleAdvisors)</code>：在 eligibleAdvisors 列表的索引 0 的位置添加 DefaultPointcutAdvisor，<strong>封装了 ExposeInvocationInterceptor 拦截器</strong></p></li><li><p><code> eligibleAdvisors = sortAdvisors(eligibleAdvisors)</code>：<strong>对拦截器进行排序</strong>，数值越小优先级越高，高的排在前面</p><ul><li>实现 Ordered 或 PriorityOrdered 接口，PriorityOrdered 的级别要优先于 Ordered，使用 OrderComparator 比较器</li><li>使用 @Order（Spring 规范）或 @Priority（JDK 规范）注解，使用 AnnotationAwareOrderComparator 比较器</li><li>ExposeInvocationInterceptor 实现了 PriorityOrdered ，所以总是排在第一位，MethodBeforeAdviceInterceptor 没实现任何接口，所以优先级最低，排在最后</li></ul></li><li><p><code>return eligibleAdvisors</code>：返回拦截器链</p></li></ul><hr><h4 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h4><p>AbstractAutoProxyCreator.createProxy()：根据增强方法创建代理对象</p><ul><li><p><code>ProxyFactory proxyFactory = new ProxyFactory()</code>：<strong>无参构造 ProxyFactory</strong>，此处讲解一下两种有参构造方法：</p><ul><li><p>public ProxyFactory(Object target)：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 将目标对象封装成 SingletonTargetSource 保存到父类的字段中</span>   <span class="token function">setTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取目标对象 class 所有接口保存到 AdvisedSupport 中的 interfaces 集合中</span>   <span class="token function">setInterfaces</span><span class="token punctuation">(</span><span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">getAllInterfaces</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ClassUtils.getAllInterfaces(target) 底层调用 getAllInterfacesForClassAsSet(java.lang.Class&lt;?&gt;, java.lang.ClassLoader)：</p><ul><li><code>if (clazz.isInterface() &amp;&amp; isVisible(clazz, classLoader))</code>：<ul><li>条件一：判断当前目标对象是接口</li><li>条件二：检查给定的类在给定的 ClassLoader 中是否可见</li></ul></li><li><code>Class&lt;?&gt;[] ifcs = current.getInterfaces()</code>：拿到自己实现的接口，拿不到接口实现的接口</li><li><code>current = current.getSuperclass()</code>：递归寻找父类的接口，去获取父类实现的接口</li></ul></li><li><p>public ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> proxyInterface<span class="token punctuation">,</span> <span class="token class-name">Interceptor</span> interceptor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 添加一个代理的接口</span>    <span class="token function">addInterface</span><span class="token punctuation">(</span>proxyInterface<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加通知，底层调用 addAdvisor</span>    <span class="token function">addAdvice</span><span class="token punctuation">(</span>interceptor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>addAdvisor(pos, new DefaultPointcutAdvisor(advice))</code>：Spring 中 Advice 对应的接口就是 Advisor，Spring 使用 Advisor 包装 Advice 实例</li></ul></li></ul></li><li><p><code>proxyFactory.copyFrom(this)</code>：填充一些信息到 proxyFactory</p></li><li><p><code>if (!proxyFactory.isProxyTargetClass())</code>：条件成立说明 proxyTargetClass 为 false（默认），两种配置方法：</p><ul><li><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; </code>：强制使用 CGLIB</li><li><code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code></li></ul><p><code>if (shouldProxyTargetClass(beanClass, beanName))</code>：如果 bd 内有 preserveTargetClass &#x3D; true ，那么这个 bd 对应的 class <strong>创建代理时必须使用 CGLIB</strong>，条件成立设置 proxyTargetClass 为 true</p><p><code>evaluateProxyInterfaces(beanClass, proxyFactory)</code>：<strong>根据目标类判定是否可以使用 JDK 动态代理</strong></p><ul><li><code>targetInterfaces = ClassUtils.getAllInterfacesForClass()</code>：获取当前目标对象 class 和父类的全部实现接口</li><li><code>boolean hasReasonableProxyInterface = false</code>：实现的接口中是否有一个合理的接口</li><li><code>if (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp; ifc.getMethods().length &gt; 0)</code>：遍历所有的接口，如果有任意一个接口满足条件，设置 hRPI 变量为 true<ul><li>条件一：判断当前接口是否是 Spring 生命周期内会回调的接口</li><li>条件二：接口不能是 GroovyObject、Factory、MockAccess 类型的</li><li>条件三：找到一个可以使用的被代理的接口</li></ul></li><li><code>if (hasReasonableProxyInterface)</code>：<strong>有合理的接口，将这些接口设置到 proxyFactory 内</strong></li><li><code>proxyFactory.setProxyTargetClass(true)</code>：<strong>没有合理的代理接口，强制使用 CGLIB 创建对象</strong></li></ul></li><li><p><code>advisors = buildAdvisors(beanName, specificInterceptors)</code>：匹配目标对象 clazz 的 Advisors，填充至 ProxyFactory</p></li><li><p><code>proxyFactory.setPreFiltered(true)</code>：设置为 true 表示传递给 proxyFactory 的 Advisors 信息做过基础类和方法的匹配</p></li><li><p><code>return proxyFactory.getProxy(getProxyClassLoader())</code>：创建代理对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)：参数是一个配置对象，保存着创建代理需要的生产资料，会加锁创建，保证线程安全</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">AopProxy</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 条件二为 true 代表强制使用 CGLIB 动态代理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>         <span class="token comment">// 条件三：被代理对象没有实现任何接口或者只实现了 SpringProxy 接口，只能使用 CGLIB 动态代理</span>        <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 条件成立说明 target 【是接口或者是已经被代理过的类型】，只能使用 JDK 动态代理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 JDK 动态代理</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 CGLIB 动态代理</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 【有接口的情况下只能使用 JDK 动态代理】</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JdkDynamicAopProxy.getProxy(java.lang.ClassLoader)：获取 JDK 的代理对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 配置类封装到 JdkDynamicAopProxy.advised 属性中</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>advised <span class="token operator">=</span> config<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 获取需要代理的接口数组</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> proxiedInterfaces <span class="token operator">=</span> <span class="token class-name">AopProxyUtils</span><span class="token punctuation">.</span><span class="token function">completeProxiedInterfaces</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查找当前所有的需要代理的接口，看是否有 equals 方法和 hashcode 方法，如果有就做一个标记</span>    <span class="token function">findDefinedEqualsAndHashCodeMethods</span><span class="token punctuation">(</span>proxiedInterfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 该方法最终返回一个代理类对象</span>    <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> proxiedInterfaces<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// classLoader：类加载器  proxiedInterfaces：生成的代理类，需要实现的接口集合</span>    <span class="token comment">// this JdkDynamicAopProxy 实现了 InvocationHandler</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AopProxyUtils.completeProxiedInterfaces(this.advised, true)：获取代理的接口数组，并添加 SpringProxy 接口</p><ul><li><p><code>specifiedInterfaces = advised.getProxiedInterfaces()</code>：从 ProxyFactory 中拿到所有的 target 提取出来的接口</p><ul><li><code>if (specifiedInterfaces.length == 0)</code>：如果没有实现接口，检查当前 target 是不是接口或者已经是代理类，封装到 ProxyFactory 的 interfaces 集合中</li></ul></li><li><p><code> addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)</code>：判断目标对象所有接口中是否有 SpringProxy 接口，没有的话需要添加，这个接口<strong>标识这个代理类型是 Spring 管理的</strong></p><ul><li><code>addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)</code>：判断目标对象的所有接口，是否已经有 Advised 接口</li><li><code> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class))</code>：判断目标对象的所有接口，是否已经有 DecoratingProxy 接口</li><li><code>int nonUserIfcCount = 0</code>：非用户自定义的接口数量，接下来要添加上面的三个接口了</li><li><code>proxiedInterfaces = new Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount]</code>：创建一个新的 class 数组，长度是原目标对象提取出来的接口数量和 Spring 追加的数量，然后进行 <strong>System.arraycopy 拷贝到新数组中</strong></li><li><code>int index = specifiedInterfaces.length</code>：获取原目标对象提取出来的接口数量，当作 index</li><li><code>if(addSpringProxy)</code>：根据上面三个布尔值把接口添加到新数组中</li><li><code>return proxiedInterfaces</code>：返回追加后的接口集合</li></ul></li></ul><p>JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods()：查找在任何定义在接口中的 equals 和 hashCode 方法</p><ul><li><code>for (Class&lt;?&gt; proxiedInterface : proxiedInterfaces)</code>：遍历所有的接口<ul><li><p><code> Method[] methods = proxiedInterface.getDeclaredMethods()</code>：获取接口中的所有方法</p></li><li><p><code>for (Method method : methods)</code>：遍历所有的方法</p><ul><li><code>if (AopUtils.isEqualsMethod(method))</code>：当前方法是 equals 方法，把 equalsDefined 置为 true</li><li><code>if (AopUtils.isHashCodeMethod(method))</code>：当前方法是 hashCode 方法，把 hashCodeDefined 置为 true</li></ul></li><li><p><code>if (this.equalsDefined &amp;&amp; this.hashCodeDefined)</code>：如果有一个接口中有这两种方法，直接返回</p></li></ul></li></ul></li></ul><hr><h4 id="方法增强"><a href="#方法增强" class="headerlink" title="方法增强"></a>方法增强</h4><p>main() 函数中调用用户方法，会进入代理对象的 invoke 方法</p><p>JdkDynamicAopProxy 类中的 invoke 方法是真正执行代理方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// proxy：代理对象，method：目标对象的方法，args：目标对象方法对应的参数</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> oldProxy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> setProxyContext <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// advised 就是初始化 JdkDynamicAopProxy 对象时传入的变量</span>    <span class="token class-name">TargetSource</span> targetSource <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span>targetSource<span class="token punctuation">;</span>    <span class="token class-name">Object</span> target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 条件成立说明代理类实现的接口没有定义 equals 方法，并且当前 method 调用 equals 方法，</span>        <span class="token comment">// 就调用 JdkDynamicAopProxy 提供的 equals 方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>equalsDefined <span class="token operator">&amp;&amp;</span> <span class="token class-name">AopUtils</span><span class="token punctuation">.</span><span class="token function">isEqualsMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">equals</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//.....</span>        <span class="token class-name">Object</span> retVal<span class="token punctuation">;</span><span class="token comment">// 需不需要暴露当前代理对象到 AOP 上下文内</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span>exposeProxy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 【把代理对象设置到上下文环境】</span>            oldProxy <span class="token operator">=</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">setCurrentProxy</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>            setProxyContext <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 根据 targetSource 获取真正的代理对象</span>        target <span class="token operator">=</span> targetSource<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 查找【适合该方法的增强】，首先从缓存中查找，查找不到进入主方法【下文详解】</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> chain <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getInterceptorsAndDynamicInterceptionAdvice</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 拦截器链是空，说明当前 method 不需要被增强</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chain<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> argsToUse <span class="token operator">=</span> <span class="token class-name">AopProxyUtils</span><span class="token punctuation">.</span><span class="token function">adaptArgumentsIfNecessary</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            retVal <span class="token operator">=</span> <span class="token class-name">AopUtils</span><span class="token punctuation">.</span><span class="token function">invokeJoinpointUsingReflection</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> argsToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 有匹配当前 method 的方法拦截器，要做增强处理，把方法信息封装到方法调用器里</span>            <span class="token class-name">MethodInvocation</span> invocation <span class="token operator">=</span>                <span class="token keyword">new</span> <span class="token class-name">ReflectiveMethodInvocation</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> target<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> targetClass<span class="token punctuation">,</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 【拦截器链驱动方法，核心】</span>            retVal <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> returnType <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retVal <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> retVal <span class="token operator">==</span> target <span class="token operator">&amp;&amp;</span>            returnType <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">&amp;&amp;</span> returnType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span><span class="token class-name">RawTargetAccess</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 如果目标方法返回目标对象，这里做个普通替换返回代理对象</span>            retVal <span class="token operator">=</span> proxy<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 返回执行的结果</span>        <span class="token keyword">return</span> retVal<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>targetSource<span class="token punctuation">.</span><span class="token function">isStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            targetSource<span class="token punctuation">.</span><span class="token function">releaseTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 如果允许了提前暴露，这里需要设置为初始状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>setProxyContext<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 当前代理对象已经完成工作，【把原始对象设置回上下文】</span>            <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">setCurrentProxy</span><span class="token punctuation">(</span>oldProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)：查找适合该方法的增强，首先从缓存中查找，获取通知时是从全部增强中获取适合当前类的，这里是<strong>从当前类的中获取适合当前方法的增强</strong></p><ul><li><p><code>AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance()</code>：向容器注册适配器，<strong>可以将非 Advisor 类型的增强，包装成为 Advisor，将 Advisor 类型的增强提取出来对应的 MethodInterceptor</strong></p><ul><li><p><code>instance = new DefaultAdvisorAdapterRegistry()</code>：该对象向容器中注册了 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter 三个适配器</p></li><li><p>Advisor 中持有 Advice 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Advisor</span> <span class="token punctuation">&#123;</span><span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><code>advisors = config.getAdvisors()</code>：获取 ProxyFactory 内部持有的增强信息</p></li><li><p><code>interceptorList = new ArrayList&lt;&gt;(advisors.length)</code>：拦截器列表有 5 个，1 个 ExposeInvocation和 4 个增强器</p></li><li><p><code>actualClass = (targetClass != null ? targetClass : method.getDeclaringClass())</code>：真实的目标对象类型</p></li><li><p><code>Boolean hasIntroductions = null</code>：引介增强，不关心</p></li><li><p><code>for (Advisor advisor : advisors)</code>：<strong>遍历所有的 advisor 增强</strong></p></li><li><p><code>if (advisor instanceof PointcutAdvisor)</code>：条件成立说明当前 Advisor 是包含切点信息的，进入匹配逻辑</p><p><code>pointcutAdvisor = (PointcutAdvisor) advisor</code>：转成可以获取到切点信息的接口</p><p><code>if(config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass))</code>：当前代理被预处理，或者当前被代理的 class 对象匹配当前 Advisor 成功，只是 class 匹配成功</p><ul><li><p><code>mm = pointcutAdvisor.getPointcut().getMethodMatcher()</code>：获取切点的方法匹配器，不考虑引介增强</p></li><li><p><code>match = mm.matches(method, actualClass)</code>：<strong>静态匹配成功返回 true，只关注于处理类及其方法，不考虑参数</strong></p></li><li><p><code>if (match)</code>：如果静态切点检查是匹配的，在运行的时候才进行<strong>动态切点检查，会考虑参数匹配</strong>（代表传入了参数）。如果静态匹配失败，直接不需要进行参数匹配，提高了工作效率</p><p><code>interceptors = registry.getInterceptors(advisor)</code>：提取出当前 advisor 内持有的 advice 信息 </p><ul><li><p><code>Advice advice = advisor.getAdvice()</code>：获取增强方法</p></li><li><p><code>if (advice instanceof MethodInterceptor)</code>：当前 advice 是 MethodInterceptor 直接加入集合</p></li><li><p><code>for (AdvisorAdapter adapter : this.adapters)</code>：<strong>遍历三个适配器进行匹配</strong>（初始化时创建的），匹配成功创建对应的拦截器返回，以 MethodBeforeAdviceAdapter 为例</p><p><code>if (adapter.supportsAdvice(advice))</code>：判断当前 advice 是否是对应的 MethodBeforeAdvice</p><p><code>interceptors.add(adapter.getInterceptor(advisor))</code>：条件成立就往拦截器链中添加 advisor</p><ul><li><code>advice = (MethodBeforeAdvice) advisor.getAdvice()</code>：<strong>获取增强方法</strong></li><li><code>return new MethodBeforeAdviceInterceptor(advice)</code>：<strong>封装成 MethodBeforeAdviceInterceptor 返回</strong></li></ul></li></ul><p><code>interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm))</code>：向拦截器链添加动态匹配器</p><p><code>interceptorList.addAll(Arrays.asList(interceptors))</code>：将当前 advisor 内部的方法拦截器追加到 interceptorList</p></li></ul></li><li><p><code>interceptors = registry.getInterceptors(advisor)</code>：进入 else 的逻辑，说明当前 Advisor 匹配全部 class 的全部 method，全部加入到 interceptorList</p></li><li><p><code>return interceptorList</code>：返回 method 方法的拦截器链</p></li></ul><p>retVal &#x3D; invocation.proceed()：<strong>拦截器链驱动方法</strong></p><ul><li><p><code>if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1)</code>：条件成立说明方法拦截器全部都已经调用过了（index 从 - 1 开始累加），接下来需要执行目标对象的目标方法</p><p><code>return invokeJoinpoint()</code>：<strong>调用连接点（目标）方法</strong></p></li><li><p><code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>：<strong>获取下一个方法拦截器</strong></p></li><li><p><code>if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)</code>：需要运行时匹配</p><p><code>if (dm.methodMatcher.matches(this.method, targetClass, this.arguments))</code>：判断是否匹配成功</p><ul><li><code>return dm.interceptor.invoke(this)</code>：匹配成功，执行方法</li><li><code>return proceed()</code>：匹配失败跳过当前拦截器</li></ul></li><li><p><code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code>：<strong>一般方法拦截器都会执行到该方法，此方法内继续执行 proceed() 完成责任链的驱动，直到最后一个  MethodBeforeAdviceInterceptor 调用前置通知，然后调用 mi.proceed()，发现是最后一个拦截器就直接执行连接点（目标方法），return 到上一个拦截器的 mi.proceed() 处，依次返回到责任链的上一个拦截器执行通知方法</strong></p></li></ul><p>图示先从上往下建立链，然后从下往上依次执行，责任链模式</p><ul><li><p>正常执行：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 返回通知</p></li><li><p>出现异常：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 异常通知</p></li><li><p>MethodBeforeAdviceInterceptor 源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 先执行通知方法，再驱动责任链</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>advice<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>mi<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 开始驱动目标方法执行，执行完后返回到这，然后继续向上层返回</span>    <span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AfterReturningAdviceInterceptor 源码：没有任何异常处理机制，直接抛给上层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 先驱动责任链，再执行通知方法</span>    <span class="token class-name">Object</span> retVal <span class="token operator">=</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>advice<span class="token punctuation">.</span><span class="token function">afterReturning</span><span class="token punctuation">(</span>retVal<span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mi<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> retVal<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AspectJAfterThrowingAdvice 执行异常处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> mi<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 默认直接驱动责任链</span>        <span class="token keyword">return</span> mi<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 出现错误才执行该方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldInvokeOnThrowing</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">invokeAdviceMethod</span><span class="token punctuation">(</span><span class="token function">getJoinPointMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="/2023/11/29/ioc-he-aop-xiang-jie/Spring-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoC </tag>
            
            <tag> AOP </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存详解</title>
      <link href="/2023/11/19/xu-ni-nei-cun-xiang-jie/"/>
      <url>/2023/11/19/xu-ni-nei-cun-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>使用了虚拟内存技术的操作系统，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong></p><p>一项新技术的产生是为了解决一些问题。在讲虚拟内存技术之前我们可以了解一下传统的内存管理方式的特征和缺点。</p><p><strong>一次性：程序必须一次性全部装入内存才能开始执行。</strong>这会造成两个问题：1.程序很大时，不能全部装入内存，导致<strong>大程序无法运行</strong>。2.当大量程序要求运行时，由于内存无法容纳所有的进程，因此只有少量的程序能运行，导致<strong>多道程序并发度下降</strong>。</p><p><strong>驻留性：</strong>一旦程序装入内存中，就会<strong>一直驻留在内存中</strong>，直到进程运行结束。事实上，在一个时间段内，只要访问作业的一小部分数据就能正常运行，这就会导致内存中驻留大量暂时用不到的数据，浪费了宝贵的内存资源。</p><p>而虚拟内存技术就是为解决上面的问题而提出的，它主要是基于<strong>时间局部性</strong>和<strong>空间局部性</strong>原理</p><blockquote><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行:如果某个数据被访问过，不久之后该数据很可能再次被访问。 (因为程序中存在大量的循环)  <em>比如一个while循环</em></p></blockquote><blockquote><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)    <em>比如一个数组</em></p></blockquote><h3 id="概括的说如何实现虚拟内存？"><a href="#概括的说如何实现虚拟内存？" class="headerlink" title="概括的说如何实现虚拟内存？"></a>概括的说如何实现虚拟内存？</h3><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。（请求调页&#x2F;请求调段）<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（页面置换&#x2F;段置换）</p><p>因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。离散分配管理内存方式有两种：内存分段和内存分页。</p><blockquote><p>什么是内存分页？</p></blockquote><p>将内存空间分为一个个<strong>大小相等的分区</strong>(比如:每个分区4KB)，每个分区就是一个“<strong>页框</strong>”，每个页框有一个编号，页框号从0开始。</p><p>将进程的逻辑地址空间也分为与页框大小相等的部分，每个部分称为一个“<strong>页</strong>”，每个页面也有一个编号即“页号”，页号也是从0开始。</p><p>操作系统以页框为单位为各个进程分配内存空间。页框和页面一一对应，各个页面不必连续存放，可以放到不相邻的各个页框中。操作系统如何记录并且描述这种一一对应关系？使用了一种数据结构——<strong>页表</strong></p><p><img src="/2023/11/19/xu-ni-nei-cun-xiang-jie/Snipaste_2024-01-07_21-28-20.png"></p><blockquote><p>什么是内存分段？</p></blockquote><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址内存。</p><p>分配规则:以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p>段表：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称<strong>段表</strong>。</p><blockquote><p>分页机制和分段机制的区别和共同点</p></blockquote><p>共同点</p><ul><li>首先他们都是非连续式内存分配方式，在内存中的存放都是离散式的</li><li>分页和分段都是为了减少内存碎片和降低内存换入和换出的开销</li></ul><p>不同点</p><ul><li>分页机制所分出来的页是固定大小的，而分段机制所分出来的段不是固定大小的，由运行时程序决定</li><li>分页机制分出来的页是没有实际含义的，程序员无法根据某一页来判断里面的内容是什么，分段机制分出来的段是有具体含义的，程序员得到关于段的信息</li></ul><h3 id="具体的说是如何实现虚拟内存？"><a href="#具体的说是如何实现虚拟内存？" class="headerlink" title="具体的说是如何实现虚拟内存？"></a>具体的说是如何实现虚拟内存？</h3><blockquote><p>虚拟存储管理需要考虑的问题</p></blockquote><ul><li>读取策略:某一页什么时候调入到内存中</li><li>置换策略:选择哪一页换出到内存</li><li>驻留集管理:给进程分配多少帧，置换时牺牲谁的帧</li><li>清除策略:何时将脏页写回到磁盘中</li><li>加载控制:调整系统的并发度，防止抖动</li></ul><p>目前来说，虚拟内存的实现方案可以基于现成的内存管理机制进行实现，比如说有请求式分页，请求式分段，请求式段页，目前应用最为广泛的有请求分页式，这种方案中，为了能够淘汰掉一些无用的内存页让那些目前急需的内存页进行加载，就需要给这些页添加一个头，通过读取这个头得到依据。</p><p>目前来说，有<strong>请求分页式管理</strong>，这种管理方式是基于页式管理进行实现的，相比于传统的页式管理，请求分页式的根本不同在于进程在运行的时候不必将所有的内存页加载进去内存，而是在需要某段内存页的时候，请求调页，将内存页从外存中调入内存，在请求分页系统中，每当要访问的页面不在内存的时候，就会产生一个缺页的中断，请求中断处理函数将在外存中的页调入内存中。</p><p>一般来说在处理中断的时候需要经过以下的步骤：</p><ul><li>保存现场，也就是将当前进程的一些状态保存到PCB，比如说什么基地址寄存器，页表寄存器等，把这些东西存储到PCB的头部里面</li><li>解析中断号，从中断向量表中查看需要调用什么中断函数</li><li>执行中断处理程序，将页面调入内存</li><li>恢复进程，将PCB首部的值恢复到寄存器中</li><li>将进程恢复到就绪态</li></ul><p>在指令的执行期间产生和处理中断信号，而非一条指令执行完毕后才处理中断。</p><p>虚拟内存的地址转换流程如下:首先是先从当前的页表寄存器中取出来页表的首地址，然后根据虚拟地址计算出来的页号，用页号*页表项的大小，然后用这个数值+页表的首地址，然后就是这一个虚拟地址所对应的物理页的地址(第一次访问内存完毕)</p><p>然后拿着这个物理页的地址，拼接虚拟地址的偏移量，就是实际的物理地址，然后用这个物理地址去访问对应的内存(第二次访问内存完毕)</p><p>那么这此处的MMU中也引入了<code>TLB</code>，这个<code>TLB</code>存储了对应的页号的信息，它相当于一层缓存，将内存中的页表项的数据存储到了<code>TLB</code>中，这样的话就减少了一次访问内存的时间</p><p>然而引入TLB的代价是需要多一层的数据一致性的维护，比如说:当MMU启动数据的查询之后，它会先查询TLB中是否有数据?如果TLB中没有数据，那么就回去查找页表，当页表中也没有数据的时候，就会发起一个缺页的中断，这时候会将寄存器中的值保存到PCB中，然后根据中断号从中断向量表中获取中断处理程序的入口，然后执行中断处理程序，替换通知磁盘读取该页，CPU启动磁盘IO，将这一页读取到内存中，如果内存满了，那么就会执行页面的置换，修改被置换页的驻留位P，修改置换页的驻留位P，访问位A，将该页植入到内存中。恢复PCB，继续执行。</p><blockquote><p>如果内存有而TLB中没有会怎么样?会将内存写入到TLB中，如果TLB的空间不足则会执行页面的置换</p></blockquote><p><strong>页面置换算法有哪些？</strong></p><p>首先第一种是最佳置换算法<code>OPT</code>，这种算法仅在理论上提出，实际上无法做到，其核心的思路就还是淘汰永不使用或者下次访问间距当前时间最长的页面</p><p>置换策略:<code>LRU</code>算法，叫做最近最少使用算法，这种算法的目的是从内存中淘汰掉目前驻留集中最少使用次数的页面，实现的思路是为每一页添加上次访问时间戳，它的理论基础是最近使用过的页面很有可能会被再次使用，而过去很久没有使用过的内存在短期内不会再被使用</p><p><code>FIFO</code>算法:将页面按调度内存的时间先后排成一个队列，每次都淘汰队首页，性能比较差的</p><p><code>CLOCK</code>时钟轮转算法，每个页表项设置一个使用位<code>U</code>，某个进程的所有页面排成一个循环缓冲链。</p><p>有一个指针从开头开始指向，具体的算法是:置换的时候顺序查找这个链，当<code>U=0</code> 的时候证明这一页在最近没有使用过，那么这时候就把它替换掉，当<code>U=1</code>的时候，就先放过它，但是会将<code>U=0</code>，如果下次到来还是<code>U=0</code>，那么就会替换掉这一页，通常还可以加入一个<code>修改位进行辅助</code></p><blockquote><p>如果无法替换页怎么办?最终就会导致OOM</p></blockquote><p>如果最近没有使用，而且没有修改，那么也就是说这一页，既不需要刷回数据库，在缓存中也不需要，把它淘汰掉没有任何代价。</p><p>如果最近没有使用，但是被修改过了，那么也就是说这一页，需要刷回数据，具有一定的代价，需要将其淘汰掉。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解HTTP协议</title>
      <link href="/2023/11/06/shen-ru-li-jie-http-xie-yi/"/>
      <url>/2023/11/06/shen-ru-li-jie-http-xie-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>超文本传输协议，也就是HyperText Transfer Protocol。HTTP 是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 是一个基于 TCP&#x2F;IP 通信协议来传递数据。</p><p><strong>特点：</strong></p><ul><li>无连接的：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。</li><li>HTTP协议是无状态协议。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><p><strong>常见状态码：</strong></p><ul><li>1xx：信息性状态码，接收的请求正在处理。</li><li>2xx：成功状态码，200 OK（成功）服务器已成功处理了请求。204 Not Connent 请求处理成功，但是没有资源返回</li><li>3xx：重定向状态码，301 MovedPermanently 资源永久移动。302 Found 资源临时移动</li><li>4xx：客户端错误状态码，401 403 Forbidden。表明对请求资源的访问被服务器拒绝了。404 Not Found。表明服务器上找不到请求的资源。</li><li>5xx：服务器错误状态码。500 Internal Server Error。表明服务器端在执行请求时发生了错误。504。Gateway Time-Out。指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li></ul><p><strong>请求报文</strong>由4部分组成：请求行，请求头部，空行，请求体。</p><p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/Snipaste_2024-02-25_15-40-48.png"></p><ul><li><p>请求行包括：请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。</p></li><li><p>请求头部：请求头部由键&#x2F;值对组成，每行一对，关键字和值用英文冒号“：”分隔</p></li><li><p>请求体： post put等请求携带的数据</p></li></ul><p><strong>响应报文</strong>由4部分组成：响应行，响应头部，空行，响应体。</p><p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/Snipaste_2024-02-25_15-47-36.png"></p><p><strong>常见字段：</strong></p><ul><li>Host：服务器的域名，允许多个域名同处一个IP地址，即虚拟主机。</li><li>Content-Length：服务器在返回数据时，会有该字段，表明本次回应的数据长度。例如，Content-Length：1000，就是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。</strong></li><li>Connection：最常用于客户端要求服务器使用<code>HTTP 长连接</code>机制，以便其他请求复用。</li></ul><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/Snipaste_2024-02-25_15-55-19.png" style="zoom：67%;"><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><ul><li><p>Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式。</p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/Snipaste_2024-02-25_15-57-47.png" style="zoom：67%;"></li><li><p>Content-Encoding：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/Snipaste_2024-02-25_15-59-57.png" style="zoom：67%;"></li></ul><h4 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h4><p><strong>代理：</strong>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p><strong>网关：</strong>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p><p><strong>隧道：</strong>隧道可按要求建立起一条与其他服务器通信的线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在双方通信断开是结束。</p><hr><h3 id="2-GET和POST有什么区别？"><a href="#2-GET和POST有什么区别？" class="headerlink" title="2.GET和POST有什么区别？"></a>2.GET和POST有什么区别？</h3><p><strong>GET请求</strong></p><p><code>GET</code>的语义是说从服务器获取指定的资源，这个资源可以是静态的文件，页面，图片，视频等。<code>GET</code>请求的参数位置一般是写在<code>URL</code>中的，<code>URL</code>规定只能支持<code>ASCII</code>，所以<code>GET</code>请求的参数只允许<code>ASCII</code>字符，而且浏览器对<code>URL</code>的长度是有限制的</p><p><strong>POST请求</strong></p><p><code>POST</code>的语义是根据请求的负荷<code>(报文body)</code>对指定的资源做出处理，具体的处理方式视资源的类型而不同，<code>POST</code>请求携带的数据一般都是写在<code>body</code>中的，而且浏览器对<code>body</code>的大小不会做出限制</p><blockquote><p>实际上Get也能带Body，只是规范中不提倡，同时Post请求的url中也能提交参数。</p></blockquote><hr><h3 id="3-GET和POST都是幂等的吗"><a href="#3-GET和POST都是幂等的吗" class="headerlink" title="3.GET和POST都是幂等的吗?"></a>3.GET和POST都是幂等的吗?</h3><p><code>安全</code>：请求方法不会破坏浏览器上的资源</p><p><code>幂等</code>：多次执行相同的操作，结果都是相同的</p><ul><li><code>Get</code>方法是安全而且幂等的，因为它是只读操作，无论操作多少次，都不会对服务器上的数据造成影响</li></ul><blockquote><p>基于<code>GET</code>请求的幂等性，因为它是只读的操作，无论操作多少次，服务器上的数据都是安全的，所以可以对<code>GET</code>请求做缓存，这个缓存既可以缓存到代理服务器上，也可以缓存到浏览器本身</p></blockquote><ul><li><code>POST</code>因为是新增或者提交数据，因此是不安全的，同时也不一定是幂等的，因为提交数据可能导致服务器资源的改变，而且多次提交就会多次创建资源</li></ul><blockquote><p>为了避免数据被窃取，就要使用<code>HTTPS</code>协议</p></blockquote><hr><h3 id="4-HTTP缓存的实现方式？"><a href="#4-HTTP缓存的实现方式？" class="headerlink" title="4.HTTP缓存的实现方式？"></a>4.HTTP缓存的实现方式？</h3><p><code>强制缓存</code>和<code>协商缓存</code></p><p>这两种缓存的对象都是那些每次请求都能得到一样的请求数据</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存指的是浏览器只要判断缓存没有过期，就可以继续使用，是否使用缓存的决定权在于浏览器</p><blockquote><p>比如说我在项目开发的时候，有一次偶然看到HTTP的状态码中标注<code>from disk cache</code></p></blockquote><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/fromdiskcache.webp" style="zoom：30%;"><p>强制缓存是利用下面这两个首部字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>：表示的是相对过期时间</li><li><code>Expires</code>：表示的是绝对过期时间</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中的<code>max-age</code>参数指明了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。第一次访问之后，客户端本地有了缓存，当第二次发起请求收到的响应报文的状态码为<code>304</code>，这个时候浏览器就可以使用本地缓存。</p><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。</p><p><strong>为什么 ETag 的优先级更高？</strong>这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><hr><h3 id="5-讲讲http缓存的实现原理"><a href="#5-讲讲http缓存的实现原理" class="headerlink" title="5.讲讲http缓存的实现原理"></a>5.讲讲http缓存的实现原理</h3><p>HTTP的缓存工作原理是基于<code>强缓存+协商缓存</code>的，这种实现能够尽可能的减少网络通信量。</p><p>首先，当浏览器要发出一个请求时，他会先检查字段，分别是<code>Cache-Control</code>，这个字段在缓存工作时设置为<code>max-age=???</code>，然后在通过比较当前的时间和请求头中的<code>Date+max-age</code>值的大小，如果小于了，直接走缓存，否则的话视为缓存不命中。</p><p>当缓存不命中的时候，开始请求服务器，首先它会发现响应头中有<code>eTag</code>，于是将<code>eTag</code>的值赋值给<code>If-None-Match</code>，如果这个<code>If-None-Match</code>在服务端找不到或者在服务端的资源能够对应上，这时候直接返回304，告诉浏览器走缓存，否则携带上这个<code>eTag</code>进行响应。</p><p>如果没有<code>eTag</code>这个字段，它会在响应头中找一个叫做<code>Last-Modified</code>的字段，然后通过赋值<code>If-Modified-Since</code>，发起新新的请求，服务端就检查这个资源的<code>Last-Modified</code>，然后这时候会有两种情况</p><ul><li>客户端的修改时间比服务端的修改时间要晚，因此直接走缓存，304</li><li>客户端的修改时间比服务端的修改时间要早，因此重新发送数据，200</li></ul><p>然后在返回新响应的时候，带上这个<code>Last-Modified</code></p><p>还有一种情况是强缓存仅基于<code>expire</code>实现，它记录的是绝对时间，但是通常由于服务端时钟和客户端时钟不一致，而不使用，精度较低</p><p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/%E4%B8%8B%E8%BD%BD%20(3).png"></p><hr><h3 id="6-HTTP-1-1了解过吗-说说优点和缺点"><a href="#6-HTTP-1-1了解过吗-说说优点和缺点" class="headerlink" title="6.HTTP&#x2F;1.1了解过吗?说说优点和缺点?"></a>6.HTTP&#x2F;1.1了解过吗?说说优点和缺点?</h3><h4 id="HTTP的优点"><a href="#HTTP的优点" class="headerlink" title="HTTP的优点"></a>HTTP的优点</h4><ul><li>简单</li></ul><p>HTTP报文段的格式就是<code>head+Body</code>，头部信息也是基于<code>key-value</code>实现的，因此简单</p><ul><li>灵活，容易扩展</li></ul><p>HTTP协议中规定的<code>URI</code>和<code>URL</code>等组成部分并没有固定，允许开发人员自行定义和扩充，因此功能上比较容易扩充</p><p>其底层的实现是可插拔式的，而且用户无感知，或者增加<code>TSL/SSL</code>等安全认证机制</p><ul><li>跨平台：各种设备都能够使用HTTP协议进行网络的通信</li></ul><h4 id="HTTP-1-1无状态的双刃剑问题"><a href="#HTTP-1-1无状态的双刃剑问题" class="headerlink" title="HTTP&#x2F;1.1无状态的双刃剑问题"></a>HTTP&#x2F;1.1无状态的双刃剑问题</h4><p><code>HTTP</code>协议是无状态的，无状态的好处是能够减少维护这次连接上的各种复杂的状态信息，减轻了CPU和内存的负担，使得这些资源更加专注于为用户提供服务</p><p>坏处则是其因为无法存储当前的状态信息，当需要完成一系列有关联性的操作的时候，需要添加附加信息</p><p>HTTP&#x2F;1.1虽然是无状态协议，但是为了实现保持状态的功能引入了<code>Cookie</code>技术。响应报文中有一个Set-Cookie的首部字段，服务器在发送响应报文时往这个字段写入，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值再发出去。服务端发现客户端发送过来的Cookie后，会和服务器上的记录做对比，最后得知之前的状态信息。</p><h4 id="HTTP-1-1明文传输的双刃剑问题"><a href="#HTTP-1-1明文传输的双刃剑问题" class="headerlink" title="HTTP&#x2F;1.1明文传输的双刃剑问题"></a>HTTP&#x2F;1.1明文传输的双刃剑问题</h4><p>明文传输的好处是程序容易调试，仅仅使用浏览器就能够对请求的信息进行分析</p><p>但是坏处是导致用户的信息泄漏，在复杂的网络中进行传输的时候，会经过错综复杂的网络结构，一旦被别有用心之人截获，就会导致非常严重的后果，问题的解决具有一定成本，比如引入复杂的加密算法，如<code>TSL/SSL</code>等机制，保护用户的信息，这增加了双方的通信量以及协议的复杂程度，因为还需要对加密的数据进行编码和解码</p><blockquote><p>HTTP&#x2F;1.1最严重的问题就是不安全，然而这个问题可以通过<code>SSL/TSL</code>的方式进行解决</p></blockquote><h4 id="HTTP-1-1的长连接是什么原理"><a href="#HTTP-1-1的长连接是什么原理" class="headerlink" title="HTTP&#x2F;1.1的长连接是什么原理?"></a>HTTP&#x2F;1.1的长连接是什么原理?</h4><p>在<code>HTTP/1.1</code>之前使用的是<code>HTTP/1.0</code>，在早期的<code>1.0</code>版本中，有一个非常严重的性能问题，就是它使用的是<code>短连接</code>，所谓短连接就是<code>一次TCP的连接与释放对应一次HTTP的请求和响应</code>，在高并发的情况下，会导致大量的<code>TCP</code>的三报文握手和四报文挥手，十分浪费，因为光是TCP报文的首部就要占20个字节，更不用说底层的IP头的加装额外消耗。</p><p>于是<code>HTTP/1.1</code>提出了长连接，这个机制使得<code>连接可复用</code>，只要任意一端没有明确提出提出断开连接，则保持TCP连接状态。在HTTP&#x2F;1.1中所有的连接默认都是长连接。</p><h4 id="管道网络传输是什么？"><a href="#管道网络传输是什么？" class="headerlink" title="管道网络传输是什么？"></a>管道网络传输是什么？</h4><p><code>长连接</code>使得<code>管道网络传输</code>成为了可能，所谓管道网络传输是说，原本的<code>请求-响应</code>模型是阻塞式的，比如说第一个请求发出了，必须要等到第一个响应回来才能发第二个请求</p><p>而管道网络传输规定：可以一次性发送多个请求出去，但是接收响应必须按照请求的顺序进行接收。</p><p>然而<code>HTTP/1.1</code>是没有默认开启这个功能的</p><h4 id="管道网络传输会带来什么问题"><a href="#管道网络传输会带来什么问题" class="headerlink" title="管道网络传输会带来什么问题?"></a>管道网络传输会带来什么问题?</h4><p>这个问题叫做<code>队头阻塞</code>问题，严重时可能导致请求大量丢失和服务宕机</p><p>这个问题是这样发生，当第一个请求发送出去之后，由于I&#x2F;O或者其他原因很长时间都没有收到响应，但是这时候后面的请求又都在排队，从而导致后面的请求无法得到响应，客户端陷入阻塞状态</p><p>这种会大大降低吞吐量，比如说请求2的完成只需要1ms，而请求1需要10s，等待的时间远远大于执行任务的时间。</p><hr><h3 id="7-HTTPS与HTTP有什么区别"><a href="#7-HTTPS与HTTP有什么区别" class="headerlink" title="7.HTTPS与HTTP有什么区别?"></a>7.HTTPS与HTTP有什么区别?</h3><p>这个问题我认为可以从<code>连接的建立过程</code>、<code>传输的信息安全性</code>、<code>默认端口</code>、<code>通信基础</code>来回答</p><ul><li>HTTP的建立是依托于TCP连接的，因此在连接建立的过程只需要完成三次握手即可，而<code>HTTPS</code>因为在HTTP和TCP之间引入了<code>SSL/TSL</code>协议，因此在完成三次握手之后，还需要完成<code>SSL/TSL</code>握手</li><li>HTTP的报文传输是明文传输的，而<code>HTTPS</code>的报文传输是经过加密之后的</li><li>HTTP的默认端口是80，HTTPS的默认端口是443</li><li>HTTPS在通信的时候需要有对应的CA来证明服务器是可信的</li></ul><hr><h3 id="8-HTTPS解决了HTTP的哪些问题？"><a href="#8-HTTPS解决了HTTP的哪些问题？" class="headerlink" title="8.HTTPS解决了HTTP的哪些问题？"></a>8.HTTPS解决了HTTP的哪些问题？</h3><p>首先我们来看看HTTP存在的安全问题：</p><ul><li>数据被窃听的风险：通信使用明文（不加密），内容有可能被窃听。</li><li>数据被篡改的风险：无法证明报文的完整性，有可能已经被篡改</li><li>冒充的风险：不验证通信方的身份，因此有可能遭遇伪装</li></ul><p>那么HTTPS引入了<code>TSL/SSL</code>就是为了解决这些问题</p><ul><li>信息加密手段：交互信息在没有密钥的情况下无法解密</li><li>校验机制：通过杂凑函数等手段，校验数据是否被篡改过，篡改过则直接丢弃数据报</li><li>身份机制：通过CA机构颁发的证书证明服务器是可信的</li></ul><hr><h3 id="9-HTTPS是如何建立的"><a href="#9-HTTPS是如何建立的" class="headerlink" title="9.HTTPS是如何建立的?"></a>9.HTTPS是如何建立的?</h3><p>由于引入了<code>TLS/SSL</code>算法，因此在TCP的三报文握手之后，还要执行身份验证等操作</p><ul><li>客户端向服务器索要公钥并且验证公钥的身份</li><li>双方协商生产共享密钥</li><li>之后都使用共享密钥进行数据的传输</li></ul><p><code>TLS</code>的握手过程包含了四次通信过程</p><ul><li>ClientHello：客户端向服务器发起加密通信请求</li></ul><p>(1) 客户端支持的TLS版本号</p><p>(2) 客户端支持生产的随机数，后面用于生成会话密钥的条件之一</p><p>(3) 客户端支持的密码套件，如RSA加密算法</p><ul><li>ServerHello</li></ul><p>(1) 确定TLS版本号</p><p>(2) 服务器生产的随机数，生产会话密钥的条件</p><p>(3) 确认的密码套件</p><p>(4) 服务器的数字证书</p><ul><li>客户端回应</li></ul><p>客户端收到数字证书后，通过浏览器等软件提供的<code>CA</code>公钥，确认服务器的数字证书的真实性</p><p>如果数字证书没有问题，就从中取出公钥，然后用其加密报文</p><p>(1) 一个随机数，这个随机数通过公钥进行加密</p><p>(2) 加密算法改变通知，之后都用共享密钥进行通信</p><p>(3) 客户端握手结束通知，表示客户端的握手阶段已经结束了，同时将之前的所有内容的发生数据做个摘要，用来给服务端进行验证</p><blockquote><p>此时，一共生产了三个随机数，然后通过这三个随机数，其中第三个随机数是通过公钥加密的，最终生产出了共享密钥</p></blockquote><ul><li>服务器的最后响应</li></ul><p>(1) 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>(2) 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><hr><h3 id="10-HTTPS一定安全可靠吗？"><a href="#10-HTTPS一定安全可靠吗？" class="headerlink" title="10.HTTPS一定安全可靠吗？"></a>10.HTTPS一定安全可靠吗？</h3><p>这个问题实际上考察的是<code>中间人攻击的问题</code></p><p>首先我们在之前，已经讨论到了数字证书的问题了，但是这个数字证书只要具有一定的资质就可以申请。</p><blockquote><p>于是，如果中间人具有一份合法的数字证书，或者说它窃取了别人的数字证书，那么它也可以发起攻击</p></blockquote><p>攻击的具体原因，首先客户端会向服务器发起请求，但是被一个假基站转发到了一个中间人服务器，然而这个中间人服务器使用了一份别人的数字证书，而这份数字证书是有效的，于是客户端完成了4次TLS握手，然后建立起通信，在这个过程中，中间人服务器同时向真正的服务器发起通信。</p><p>那么这样就很微妙了，中间人可以解开所有的数据，甚至能够篡改有关的数据，这样的话就会导致数据泄漏。</p><blockquote><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p></blockquote><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。</p><p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><hr><h3 id="11-CA机构是如何颁发数字证书的？"><a href="#11-CA机构是如何颁发数字证书的？" class="headerlink" title="11.CA机构是如何颁发数字证书的？"></a>11.CA机构是如何颁发数字证书的？</h3><p>首先，服务器的运营人员向CA机构提出公开秘钥的申请，CA机构在检查了申请者的身份之后，会对已申请的公开秘钥做数字签名，然后分配这个已签名的公开秘钥，CA机构将<code>个人信息+公钥+数字签名</code>打包成一个数字证书。</p><p>服务器会将这份数字证书发给客户端，来进行公开秘钥加密通信。</p><p>接到数字证书的客户端使用CA机构的公钥对证书上的数字签名做验证，一旦验证通过，客户端便可以确定两件事，一是给这个服务器做认证的机构是真实有效的，二是该服务器的公钥是值得信赖的。</p><p>客户端上的CA机构的公钥是怎么来的呢？为了确保安全的转交，多数浏览器开发商发布版本时，会事先在内部植入常用认证机构的公钥。</p><hr><h3 id="12-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#12-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="12.HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>12.HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h3><p>这个问题我打算从<code>HTTP/1.0</code>和<code>HTTP/1.1</code>的区别进行描述</p><p>首先<code>HTTP/1.0</code>的最重要的特征就是<code>短连接</code>，也就是<code>一次请求与响应就对应一次TCP的连接与释放</code></p><p>因此在大量请求到来的时候，性能就会严重下降。</p><p>于是<code>HTTP/1.1</code>引入了长连接，这种机制就是说，只要请求的收发双方没有一方明确提出要断开连接，那么底层就会保留这条<code>TCP</code>连接，减少了<code>TCP</code>连接的三报文握手和四报文挥手的巨大开销</p><p>同时，由于多个<code>请求-响应</code>复用同一条<code>TCP</code>连接，这使得<code>管道网络传输</code>成为可能，也就是说，这时候客户端发送请求时，不必等待前一个请求的响应到达即可发送请求。</p><p>但是同时<code>HTTP/1.1</code>具有相当一部分缺点</p><ul><li><code>data</code>的<code>header</code>没有做压缩，而只能对<code>body</code>做压缩，因此当<code>header</code>的体积过大时，将导致网络<code>I/O</code>传输性能下降</li><li>将导致队头阻塞问题，虽然使用管道网络传输能够异步发送请求，但是接收响应却是同步的，在这种情况下，如果前面的响应没有发回来，然后后面的请求将一直无法接收到响应</li><li>没有提供解决队头阻塞的优先级机制</li><li>冗长的首部将导致传输浪费</li><li>请求只能从客户端开始，服务器只能够被动响应，服务端无法主动推送服务</li></ul><hr><h3 id="13-HTTP-2-做了什么优化？"><a href="#13-HTTP-2-做了什么优化？" class="headerlink" title="13.HTTP&#x2F;2 做了什么优化？"></a>13.HTTP&#x2F;2 做了什么优化？</h3><p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/%E4%B8%8B%E8%BD%BD%20(4).png"></p><p>关于这个问题，我想应该要从两个方面进行回答，第一个方面是安全方面</p><p><code>HTTP/2</code>引入了<code>TLS1.2+</code>，也就是基于<code>HTTPS</code>的机制，使得<code>HTTP/2</code>的传输变得更加安全了</p><p>第二个方面是性能方面，性能方面做了较大的改动：</p><p>首先我们先来看看<code>HTTP/1.1</code>中各个痛点</p><ul><li><code>HTTP/1.1</code>的数据传输低效</li></ul><p>它的传输低效主要存在于两点，第一，它的头部没有经过压缩，如果发送的请求&#x2F;响应的头部冗长，而每次都发送这些请求的话，导致导致大量冗余信息在网络中传输</p><blockquote><p>对于这个痛点，HTTP&#x2F;2提供的解决方案是，客户端和服务端双方维护一张<code>头信息表</code>，这张表在初始化就被静态写入一些常用的头部字段，当需要使用到这些头部字段<code>(以key-value的形式存储)</code>的时候，就在数据包的头部中封装一个字段<code>header：1 xxxx</code>，其中1代表着这个头部字段在头信息表存在，xxx代表的是索引号，当第一个字段为0的时候，代表不存在，然后后边的这些xxx就是实际上的头部字段，然后传输到对等端的时候，会将这个字段记录到动态表中，方便下次使用</p></blockquote><p>第二个低效的原因在于频繁的编码操作，<code>HTTP/1.1</code>的数据传输是基于<code>文本传输</code>的，而计算机硬件无法读取纯文本格式，只能够读取二进制的数据，在接收数据的时候，还需要将文本格式的数据解析为二进制的数据。</p><p>这就带来了严重的空间浪费了，比如说要传输的是<code>200</code></p><ul><li>在<code>HTTP/1.1</code>中的形式是”2””0””0”，然后以二进制编码的方式就是三个字节</li><li>然而在<code>HTTP/2</code>中由于全面采用了二进制编码格式，因此200就表示为<code>1100 1000</code>，节省了两个字节</li></ul><blockquote><p>全面采用了二进制，节省了传输所需要的编码量</p></blockquote><ul><li>存在队头阻塞问题</li></ul><p>这个队头阻塞问题指的是当响应迟迟没有到来的时候，后续的请求就无法得到响应</p><blockquote><p>那么它是怎么解决的呢?</p></blockquote><p>它引入了<code>Stream</code>流的概念，我们首先来理解为什么存在队头阻塞现象，这是因为如果不按请求顺序进行响应，就有可能将A的响应给到B，将B的响应给A，造成错乱</p><blockquote><p>那么我们为什么不给这响应包加上一个控制字段，让这些包能够标识出来谁是谁的响应呢?</p></blockquote><p>这就是<code>Stream</code>机制提出的一个核心思路，它在同一个<code>TCP</code>连接中存在多个<code>Strteam</code>，这多个<code>Stream</code>就代表着同一个<code>请求-响应</code>，他们通过在标识<code>StreamId</code>对这些<code>Stream</code>进行标识，从而确保对应的请求能够收到对应的请求</p><p>如果是这样的话，我们假设响应是乱序返回的，比如请求1、请求2发送，然后响应2、响应1返回，因为存在<code>StreamId</code>，接收方就能够通过不同<code>Id</code>标识拿到自己想要的数据包</p><p>通过<code>Stream</code>流的并发传输，提高了性能</p><ul><li>只能是客户端主动请求响应，而无法服务器主动推送</li></ul><p>假设客户端向服务器等待服务器的长IO操作，只要等待它的长IO操作完成后才能返回响应，那么在这期间只能干等着，如果服务端能够主动推送响应，那么可以这样操作：</p><p>等服务器接收到客户端的请求，先临时告知客户端服务器正在操作，然后客户端就可以干自己的事情去了</p><p>然后当服务器做完自己的事情了，再向客户端推送，这样的话就可以提供用户的使用体验</p><blockquote><p>HTTP&#x2F;2有什么缺陷</p></blockquote><p>它同样存在队头阻塞的问题，<code>只不过它的队头阻塞问题</code>是因为滑动窗口的限制而产生的，也就是队头阻塞产生在<code>TCP</code>层面，先来讲讲它是怎么产生的</p><p>我们假设发送双方维护了一个窗口，然后A同时发送了<code>P1/P2/P3/p4/p5</code>然后等待ACK，然后B能够接收<code>P1/P2</code></p><p><code>P1</code>，但是P2丢掉了，于是它只能够等待<code>P2</code>的超时重传，那么这期间，如果A再发送<code>P3/P4/P5</code>，都不能够再次接收</p><blockquote><p>当考虑每个包大小一样的话，此时B应该能接收到<code>P2/P3</code>，但是后续的<code>P4/P5</code>均会被阻塞发送，即使到了也会被丢弃，因此此时<code>P4/P5</code>的响应就被搁置了，变成了队头阻塞</p></blockquote><hr><h3 id="14-HTTP-3-做了哪些优化？"><a href="#14-HTTP-3-做了哪些优化？" class="headerlink" title="14.HTTP&#x2F;3 做了哪些优化？"></a>14.HTTP&#x2F;3 做了哪些优化？</h3><p>既然谈到了优化，那么肯定就是解决<code>HTTP/2</code>所没有解决的问题，<code>HTTP/2</code>没有解决<code>TCP</code>层面的队头阻塞问题</p><blockquote><p>但是这个问题是致命的，因为发送窗口和接收窗口不可能无限制大小，而且为了可靠传输，必须保证数据包的有序接收，因此一个思路就是，修改底层的实现，改为<code>UDP</code>实现</p></blockquote><p><img src="/2023/11/06/shen-ru-li-jie-http-xie-yi/%E4%B8%8B%E8%BD%BD%20(5).png"></p><p>首先要解决的问题是：之前提供的<code>HTTP</code>协议都是<code>TCP</code>的可靠传输，那么我们必须基于<code>UDP</code>实现可靠传输</p><blockquote><p>核心就是上图中的<code>QUIC</code>协议</p></blockquote><p><code>QUIC</code>协议也有类似的<code>HTTP/2</code>中的<code>Stream</code>的机制，也就是说一条连接中有也有多个<code>Stream</code>，但是每一个<code>Stream</code>并不公用一个窗口，而是有各自的滑动窗口，因此如果流中的包丢失了，只会导致这个<code>请求-响应</code>被阻塞，其他的不被阻塞，这就解决了队头问题</p><p>与此同时，<code>QUIC</code>协议还基于<code>UDP</code>协议提高了性能</p><p><strong>更快的连接建立</strong></p><p>对比与<code>HTTP/1.0、HTTP/1.1</code>的实现，由于<code>TCP+TLS</code>的实现基于内核的<code>TCP</code>传输层和<code>openssl</code>库实现的，因此难以解耦，而<code>QUIC</code>的思路是：在完成连接握手的时候，在帧的首部携带上<code>TLS</code>认证信息，这个过程主要是为了确认双方的连接<code>ID</code></p><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p><strong>连接的迁移</strong></p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><hr><h3 id="15-一台服务器怎么搭建多个web站点？"><a href="#15-一台服务器怎么搭建多个web站点？" class="headerlink" title="15.一台服务器怎么搭建多个web站点？"></a>15.一台服务器怎么搭建多个web站点？</h3><p>HTTP&#x2F;1.1规范允许一台服务器搭建多个web站点。比如我们可以在阿里云申请一个域名，搭建网站。其使用的就是<code>虚拟主机（虚拟服务器）</code>功能。在互联网上，域名通过DNS服务器解析成IP地址，之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址销售访问了。</p><blockquote><p>那么有着多个域名的服务器怎么知道这个请求是要去哪个域名呢？</p></blockquote><p>在发送HTTP请求时，必须在首部的Host字段完整指定主机名或域名的URI。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解TCP协议</title>
      <link href="/2023/11/02/shen-ru-li-jie-tcp-xie-yi/"/>
      <url>/2023/11/02/shen-ru-li-jie-tcp-xie-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是TCP协议"><a href="#1-什么是TCP协议" class="headerlink" title="1.什么是TCP协议"></a>1.什么是TCP协议</h3><p>TCP叫做传输控制协议，与之相关的，在传输层还有一个叫做<code>用户数据报</code>的协议，叫做UDP</p><p>TCP是面向连接的、可靠的、基于字节流的传输层通信协议</p><ul><li>所谓面向连接:就是必须通信双方都建立起连接后才能够连接，因此其必须通过三次握手等机制来确保连接正常后才能够进行通信</li><li>所谓可靠:TCP通信的双方维护了一个发送窗口和接收窗口，这两个窗口说明了当前接收方发送了哪些数据，接收方接收了哪些数据，同时通过<code>序列号+确认号</code>的机制不断推进传输，从而可以保证传输的有序接收，而且超时重传机制能够使得发送方将未到达的报文重新发送到对方</li><li>所谓字节流:用户消息通过TCP协议进行传输的时候，这个消息可能是一大段报文，它有可能会被操作系统分组为多个TCP报文，如果接收方的程序不知道消息的边界，是无法读取出一个有效的用户消息的，并且TCP报文是有序的，当前一个TCP报文没有收到的时候，即使它先收到了后面的报文，也不能够传输到应用层进行处理，重复的TCP报文会被自动丢弃</li></ul><blockquote><p>这也就是常说的原生TCP所固有的粘包和半包的症结所在</p></blockquote><hr><h3 id="2-TCP报文段的首部格式"><a href="#2-TCP报文段的首部格式" class="headerlink" title="2. TCP报文段的首部格式"></a>2. TCP报文段的首部格式</h3><p>为了实现可靠传输，TCP采用了<strong>面向字节流</strong>的方式。但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为<strong>TCP报文段</strong>后进行发送。一个TCP报文段由<strong>首部</strong>和<strong>数据载荷</strong>两部分构成；TCP的全部功能都体现在它首部中各字段的作用</p><p><img src="/2023/11/02/shen-ru-li-jie-tcp-xie-yi/QQ%E5%9B%BE%E7%89%8720230722151145.png"></p><p>下面列举几个比较重要的字段</p><p><strong>序号（seq）</strong>：占32比特，取值范围[0，2^32-1]，确认号增加到最后一个后，下一个确认号就又回到0。每发送一次数据，就累加一次该数据字节数的大小，它同时也可以用来解决网络包乱序的问题。</p><p><strong>确认号(ack)：</strong>占32比特，取值范围[0，2^32-1]，确认号增加到最后一个后，下一个确认号就又回到0.</p><ul><li>指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</li><li>若确认号&#x3D;n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</li></ul><p><strong>控制位</strong>：主要有4个</p><ul><li>确认标志位ACK：这个位为1时，表示上一次对方发送过来的数据包已经正确接收，是一个应答的信号。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1.</li><li>同步标志位SYN：当这个位为1时，表示希望与对方建立连接，在此阶段初始化序列号</li><li>复位标志位RST：当这个位为1时，表示TCP连接出现了异常必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</li><li>终止标志位FIN:当这个位为1时，表示希望与对方断开连接，当数据交换完毕后，通信双方的主机就可以相互交换<code>FIN=1</code>的TCP段</li></ul><hr><h3 id="3-如何确定唯一一个TCP"><a href="#3-如何确定唯一一个TCP" class="headerlink" title="3. 如何确定唯一一个TCP"></a>3. 如何确定唯一一个TCP</h3><p>一个TCP连接的四元组表示如下:<code>&#123;源地址，源端口，目标地址，目标端口&#125;</code></p><p>在网络传输的过程中， 源地址和目的地址的字段是在<code>IP</code>头部中的，而源端口和目的端口的字段是在<code>TCP</code>头部中的</p><blockquote><p>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</p></blockquote><p>服务端通常固定在某个本地端口上进行监听，等待客户端的连接请求，它会存在一个<code>监听socket</code></p><p>那么根据<code>TCP</code>的唯一标识，可以看出<code>连接数 = 客户端的IP*客户端的端口数</code>，理论上最多可以到<code>2^48</code>（服务端的IP和端口号是固定的）。</p><blockquote><p>然而，每一个连接代表着一个fd，fd是受系统管控的资源，会受到以下的因素影响</p></blockquote><ul><li><p>文件描述符的限制，每一个TCP连接都是一个文件，如果文件描述符被占满了，会发生<code>Too Many open files</code>。</p><p><code>Linux</code>对可以打开的文件描述符的数量做了三个方面的限制</p><ul><li>系统级:当前系统可以打开的最大数量，可以通过<code>cat /proc/sys/fs/file-max</code>进行查看</li></ul></li><li><p>用户级:指定用户可打开的最大数量，可以通过<code>cat /etc/security/limits.conf</code>进行查看</p><ul><li>进程级:单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li></ul></li><li><p><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM</p></li></ul><hr><h3 id="4-UDP和TCP有什么区别-在应用上有什么异同"><a href="#4-UDP和TCP有什么区别-在应用上有什么异同" class="headerlink" title="4.UDP和TCP有什么区别?在应用上有什么异同?"></a>4.UDP和TCP有什么区别?在应用上有什么异同?</h3><p><code>UDP</code>和<code>TCP</code>的最重要的区别在于:<code>UDP</code>并不提供复杂的控制机制，它是利用<code>IP</code>提供面向<code>无连接</code>的通信服务</p><p>我们从<code>UDP</code>的头部就可见端倪，TCP的首部除了有描述接收双方的源端口号和目的端口号之外，还有<code>序列号</code>、<code>确认号</code>、<code>ACK</code>、<code>SYN</code>、<code>FIN</code>、<code>RST</code>等复杂的控制字段，因此<code>UDP</code>相对于<code>TCP</code>而言，其使用更加简单，但是是不可靠的传输</p><p>UDP的头部格式有<code>源端口号</code>、<code>目标端口号</code>、<code>包长度</code>、<code>检验和</code></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><p>下面具体来讲讲两者的异同:</p><ul><li>关于连接方面</li></ul><p>TCP是面向连接的协议，必须要建立连接后才能够收发数据</p><p>UDP是面向无连接的协议，不需要复杂的握手的连接建立和回收的连接释放，即刻传送数据即可</p><ul><li>关于服务对象</li></ul><p><code>TCP</code>是一对一的两点服务，也就是说一条连接只有两个端点</p><p><code>UDP</code>支持一对一，一对多，多对多的通信</p><ul><li>关于可靠性</li></ul><p>TCP实现的是可靠传输，数据的传输可以实现<code>无差错</code>、<code>不丢失</code>、<code>不重复</code>、<code>按序到达</code></p><p>UDP是尽最大努力交付的，不保障具体的交付过程，但是可以在<code>UDP</code>之上应用层中添加相关协议，实现<code>UDP</code>的可靠传输</p><ul><li>拥塞控制和流量控制</li></ul><p>TCP有拥塞控制和流量控制的极值，保证了数据传输的安全性</p><p>而UDP并没有此套机制，当网络极度拥堵的时候也不会调整网络包的发送速率，导致网络更加拥堵</p><ul><li>关于首部的开销</li></ul><p>TCP的首部由于携带大量的字段，因此其首部会很长，基础的长度是20个字节，当使用了选项中的字段，最大可能增长到40个字节</p><p>UDP首部只有8个字节</p><ul><li>传输方式</li></ul><p>TCP是面向字节流的，按照流式进行传输，没有边界，但是保证顺序和可靠</p><p>UDP是一个包一个包地发送的，是有边界的，但是可能会丢包和乱序</p><ul><li>分片的不同</li></ul><p>TCP的数据长度如果大于了<code>MSS</code>的大小，那么就直接在传输层进行分片，目标主机收到之后，也同样会在传输层组装TCP的数据包，如果中途丢失了一个分片，那么就只需要重传丢失的这个分片</p><p>UDP的长度如果大于了<code>MTU</code>大小，那么就会在IP层进行分片，目标主机收到之后，在IP层组装完数据之后，才会交付到传输层</p><p><strong>关于应用场景</strong></p><p>由于TCP实现的是可靠传输，可以保证数据的可靠传输，因此通常用于</p><ul><li>FTP的文件传输</li><li>HTTPs&#x2F;HTTP传输</li></ul><p>由于UDP面向的是无连接的，它随时可以发送数据，因此使用的场景大多数是实时的场景</p><ul><li>包总量较小的通信，如DNS，SNMP</li><li>视频，音频等多媒体通信</li><li>广播通信</li></ul><blockquote><p>为什么UDP头部没有首部长度字段，而TCP的首部具有首部长度字段呢?</p></blockquote><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><blockquote><p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p></blockquote><p>TCP数据的长度 &#x3D; IP总长度 - IP首部长度 - TCP首部长度</p><ul><li>第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li><li>第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</li></ul><hr><h3 id="5-TCP和UDP可以使用同一个端口吗"><a href="#5-TCP和UDP可以使用同一个端口吗" class="headerlink" title="5.TCP和UDP可以使用同一个端口吗?"></a>5.TCP和UDP可以使用同一个端口吗?</h3><p>首先先来弄明白端口到底是用来干嘛的</p><p>在数据链路层中，通过<code>MAC</code>地址来寻找局域网中的主机</p><p>在网际层中通过<code>IP地址</code>来寻找网络中互连的主机或者路由器</p><p>在传输层中，需要通过<code>端口</code>进行寻址，来识别同一计算机中同时通信的不同应用程序</p><p><strong>端口的作用就是用来区分同一个主机上不同应用程序的数据包</strong></p><p>因此，如果这个程序同时使用了<code>UDP</code>和<code>TCP</code>就可以使用同一个端口，这是一种理解，从<code>Linux</code>内核和协议头部控制的角度来看，当主机收到一个<code>IP</code>数据包之后，可以根据协议的字段知道这个包是属于<code>UDP</code>还是<code>TCP</code>，而在<code>Linux</code>内核中，它有两个独立的模块分别用来处理<code>TCP</code>包和<code>UDP</code>包，因此就可以将包分发给这两个不同的模块，然后通过这些模块再分发到不同的端口中。这样的话，即使是不同的程序，也可以监听相同的端口，因为内核有能力区分出来这些包应该要发送给哪个用户进程</p><p>但是要注意的是，当存在多个<code>TCP</code>连接监听同一个端口的时候，就会导致错误的发生了</p><blockquote><p>问题在于:程序是怎么知道这个包是属于UDP还是TCP的?</p></blockquote><p>当主机收到数据包之后，在<code>IP</code>包头的协议号中就可以知道这个数据包是<code>TCP/UDP</code>，根据信息然后分用，交付到不同的模块进行处理，送给<code>TCP/UDP</code>模块的报文根据端口号送给应用程序进程处理</p><hr><h3 id="6-TCP的三次握手过程"><a href="#6-TCP的三次握手过程" class="headerlink" title="6.TCP的三次握手过程"></a>6.TCP的三次握手过程</h3><p><img src="/2023/11/02/shen-ru-li-jie-tcp-xie-yi/QQ%E5%9B%BE%E7%89%8720230722-143431.png"></p><h4 id="为什么是三次握手而不是两次？"><a href="#为什么是三次握手而不是两次？" class="headerlink" title="为什么是三次握手而不是两次？"></a>为什么是三次握手而不是两次？</h4><p>这是为了防止客户端迟到的SYN报文又到了服务器，因而产生错误。</p><p>我们假设两次握手就可以建立连接。假设目前客户端在发出第一个握手报文，但是这个报文因为网络问题被阻塞在某个路由器中，客户端因为没有收到确认，又重传了一次，后面收到了确认，建立了连接数据传输完就释放了连接。后面这个迟到的报文来了，服务器以为这是一个新的请求连接，然后对它确认，建立了连接，并且一直等客户端发送数据，但是客户端不理睬，就这样服务器的资源被白白浪费了。这些资源可以是序列号，可以是缓存窗口，他们在操作系统中都需要预分配，如果存在大量的无效连接，可能导致内存溢出等问题，从而导致正常的服务无法执行。</p><blockquote><p>那么三次握手是怎么解决这个问题的呢?</p></blockquote><p>基于三次握手，客户端可以确认服务端接收到的连接请求是否已经过期，举个例子:</p><p>假设第一个过期的报文，它的序列号是<code>90</code>，而第二个有效的报文，它的序列号是<code>55</code>，然后服务端给回响应的时候就会给出两个<code>91</code>和<code>56</code>，客户端这边是可以检查上下文的，它检查到它应该要收到的是<code>56</code>，然后就会这个序列号为<code>91</code>的回复做出一个<code>重置</code>的操作， 也就是将控制位<code>RST</code>设置为1，最终连接终止。</p><h4 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4><p>为了防止历史报文被下一个相同的四元组的连接接受。</p><p>假设现在序列号都是固定从0开始的</p><p>初始情况:假设客户端和服务端建立好了连接，窗口为10，于是发送了<code>1~11</code>的东西出去，恰好这时候，服务端宕机了但是客户端没有宕机，然后客户端看到服务端迟迟没有发ACK，于是超时重传，网络中有大量的<code>1~11</code>的数据包。然后服务端重启了，之前与客户端建立的连接也消失了，于是收到客户端的历史数据包的时候就会发送RST报文。</p><p>在重新连接之后，历史数据包正好抵达了服务端，刚好该数据包的序列号正好在服务端的接收窗口，服务端就这些数据，就会造成数据错乱。</p><h4 id="第一次握手丢失了，会发生什么"><a href="#第一次握手丢失了，会发生什么" class="headerlink" title="第一次握手丢失了，会发生什么?"></a>第一次握手丢失了，会发生什么?</h4><p>第一次握手报文是整个连接建立的起始报文，如果该报文不起作用后面则无从谈起。</p><p>握手丢失的实际现象表现为客户端没有收到来自服务端的<code>ACK</code>，当长时间没有收到<code>ACK</code>，与普通的报文一样，都会触发一个超时重传机制，但是这个超时重传的超时时间并不是均匀的，而是以2的指数倍进行翻倍</p><p>比如说一开始等待1s，后面就是2s，4s，8s，…，在linux下，当超时重传这个syn的次数达到一定的次数，就会直接断开连接，不再发送<code>syn</code>报文。</p><h4 id="第二次握手丢失了，会发生什么"><a href="#第二次握手丢失了，会发生什么" class="headerlink" title="第二次握手丢失了，会发生什么?"></a>第二次握手丢失了，会发生什么?</h4><p>目前假设第一次握手收到了，但是服务端发送的<code>ACK+SYN</code>丢掉了，会发生什么?</p><p>注意，此时的状况是客户端已经发出了第一次握手报文了，它在等待服务端发送的第二次握手报文，如果服务端迟迟不发来这个<code>ACK+SYN</code>，那么就会触发超时重传机制</p><p>然后服务端也已经发出了第二次握手报文，但是迟迟没有收到客户端发来的第三次握手报文，于是它也会触发一个超时重传的机制</p><p>在这两种情况下，会导致客户端和服务端不断的重发，最终两端同时达到最大的重试次数，连接断开。</p><h4 id="第三次握手丢失了，会发生什么"><a href="#第三次握手丢失了，会发生什么" class="headerlink" title="第三次握手丢失了，会发生什么?"></a>第三次握手丢失了，会发生什么?</h4><p>首先搞明白第三次握手报文的性质是<code>ACK</code>报文，ACK报文并不会重传。</p><p>因此当第三次握手丢失了，那么这时候服务端就会不断重发<code>SYN+ACK</code>的报文，直到重试次数全部用完</p><h4 id="什么是SYN攻击"><a href="#什么是SYN攻击" class="headerlink" title="什么是SYN攻击?"></a>什么是SYN攻击?</h4><p><code>SYN</code>攻击指的是:黑客非法地伪造大量不存在的<code>IP</code>地址向服务端发送<code>第一次的握手SYN报文</code>，此时每一个<code>第一次握手的SYN</code>报文到来，就意味着内核有一个<code>半连接对象的产生</code>，内核会将这个半连接对象放入到<code>半连接队列中</code>，然后发出一个<code>第二次握手报文</code>，等待来自客户端的回复，如果客户端迟迟没有回复，那么这些连接对象就会一直放在半连接队列中，直到重试次数达到上限后被移除。如果等到了回复，那么就可以将这个半连接对象加入到全连接队列，由应用程序进行轮询或者信号通知的方式将这些连接对象通过<code>accept()</code>的方式拿出来。</p><blockquote><p>那么问题就在于，当半连接队列被打满了之后，之后到来的<code>SYN</code>报文都会被丢弃，从而导致服务器无法正常工作。</p></blockquote><p>那么怎么解决这个问题呢?</p><ul><li>调大<code>网络数据包缓存区</code>的大小，可以使得未处理的报文有位置存放而不会丢弃</li><li>增大<code>TCP</code>的半连接队列</li><li>开启cookie，cookie是一种绕开<code>SYN半连接队列</code>的机制，具体工作如下:这种机制下，不会创建半连接的对象，而是在接收到第一个握手报文之后，计算出一个<code>cookie</code>值，然后发出去，等待来自客户端的第三次握手报文，经过验证之后，当这个<code>cookie</code>值能够对得上，那么就直接创建连接对象，加入到accpet队列中</li><li>减小重传的次数，加快无效连接的淘汰</li></ul><hr><h3 id="7-既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#7-既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="7.既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>7.既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><p><img src="/2023/11/02/shen-ru-li-jie-tcp-xie-yi/%E4%B8%8B%E8%BD%BD.png"></p><p>根据以太网的规定，MAC帧的数据部分不能够超过<code>1500</code>个字节，<code>MAC</code>帧如果太长，会影响传输的效率，是人为规定的。因此当上层交付下来的数据太长的话是不合法，一般来说会<code>IP</code> 层进行分片。假设有一份数据，较大，且在TCP层不分段，如果这份数据在发送的过程中出现<strong>丢包</strong>现象，TCP会发生重传，那么重传的就是这一大份数据这无疑是极大的影响效率的。</p><p>因此TCP层为自己设计分片的规则，这个<code>MSS</code>并没有特别的限定，而是由通信双方在连接建立的时候商定的。</p><p>经过TCP层的分片之后，重发是以<code>MSS</code>为单位的，而不需要重发整个TCP数据包</p><h3 id="8-TCP的四次挥手"><a href="#8-TCP的四次挥手" class="headerlink" title="8.TCP的四次挥手"></a>8.TCP的四次挥手</h3><p><img src="/2023/11/02/shen-ru-li-jie-tcp-xie-yi/QQ%E5%9B%BE%E7%89%8720230722145123.png"></p><p><code>TCP</code>的四次挥手预告着TCP连接的释放，由于全双工的特性，双方都可以主动断开连接，断开连接后就可以将主机中关于连接的资源释放掉。</p><p>可以看出，每个方向都需要有一个FIN和ACK，主动关闭连接的才有<code>TIME-WAIT</code>的状态</p><h4 id="为什么是四次挥手，不是一次挥手？"><a href="#为什么是四次挥手，不是一次挥手？" class="headerlink" title="为什么是四次挥手，不是一次挥手？"></a>为什么是四次挥手，不是一次挥手？</h4><p>与不能一次握手的道理相同，一次握手甚至不能够保证结束连接的请求给到对等端，必须采用<code>ACK</code>的机制才能够保证对等端收到停止连接的请求。</p><h4 id="为什么是四次挥手，不是两次挥手？"><a href="#为什么是四次挥手，不是两次挥手？" class="headerlink" title="为什么是四次挥手，不是两次挥手？"></a>为什么是四次挥手，不是两次挥手？</h4><p>两次挥手，意味着客户端发出请求后，服务端收到了请求。挥手与握手的过程不同，当客户端提出断开连接的时候，只是说明客户端没数据发了，但是服务端可能依然还在发数据，或者有一些收尾数据需要发送到客户机上，因此在确认了客户端想要断开连接的时候，还需要给它一段机动的时间，在这段时间内将数据全部发完。</p><h4 id="为什么是四次挥手，不是三次挥手？"><a href="#为什么是四次挥手，不是三次挥手？" class="headerlink" title="为什么是四次挥手，不是三次挥手？"></a>为什么是四次挥手，不是三次挥手？</h4><p>注意:四次挥手在一定情况下是可以转换成三次挥手的。</p><p>在第二次握手报文和第三次握手报文的中途，实际上是给客户端发送数据，那么如果确认没有数据要发送，并且开启了TCP延迟确认机制，那么第二次和第三次的挥手就会合并。</p><blockquote><p>什么叫TCP的延迟确认机制</p></blockquote><p>一个TCP的首部长度40个字节，还需要经过底层的IP封装和MAC封装，因此发送一个没有数据的空包，是非常浪费的，而ACK包的作用就是用来应答上一次的数据的，其本身的作用不具有携带数据的功能，但是它完全能够顺便携带数据到对方的，因此就提出了<code>TCP的延迟确认机制</code>，其具体运作机制是这样的:</p><ul><li>当有响应数据要发送的时候，ACK会随着响应数据一起立刻发送</li><li>当没有响应数据要发送的时候，ACK将会延迟一段时间，以等待是否有数据可以一起发送</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又来了，说明等太久了，此时立即发送ACK</li></ul><h4 id="第一次挥手丢失了会发生什么？"><a href="#第一次挥手丢失了会发生什么？" class="headerlink" title="第一次挥手丢失了会发生什么？"></a>第一次挥手丢失了会发生什么？</h4><p>假设客户端发出了第一次挥手的FIN报文，但是服务器没有收到。那么接下来：</p><p>客户端：会不断重发<code>FIN</code>报文，直到最大的重试次数，当达到最大的重试次数，代表着这个报文无法发出去了，那么就会直接关闭连接<br>服务器：直接没收到<code>FIN</code>报文，此时就会一直处于一个<code>ESTABLISHED</code>的状态，直到保活计时器启动，然后发现对方已不可达的时候，直接关闭连接</p><blockquote><p>什么是保活计时器？</p></blockquote><p>服务器每收到一次TCP客户进程的数据，就重新设置并启动<em>保活计时器</em>（2小时定时）。<br>若保活计时器定时周期内未收到TCP客户进程发来的数据，则<strong>当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段</strong>，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</p><h4 id="第二次挥手丢失了会发生什么？"><a href="#第二次挥手丢失了会发生什么？" class="headerlink" title="第二次挥手丢失了会发生什么？"></a>第二次挥手丢失了会发生什么？</h4><p>当服务端收到客户端发送的FIN后，就会回复一个ACK（第二次挥手）。此时服务端就会进入到CLOSE_WAIT状态。</p><p>假如这个ACK丢失了，客户端就会以为自己发送的FIN报文丢失了，便会触发超时重传机制，进行重传FIN报文。如果超过重传次数后，还没有收到服务端的第二次挥手，那么客户端就会断开连接。</p><h4 id="第三次挥手丢失了会发生什么？"><a href="#第三次挥手丢失了会发生什么？" class="headerlink" title="第三次挥手丢失了会发生什么？"></a>第三次挥手丢失了会发生什么？</h4><p>注意，第三次挥手是在服务端发送完数据之后才发送的，因此第三次挥手的时机取决于什么时候发送完数据，那么怎么知道什么时候发送完数据了呢?就是当服务端的数据写入完毕后，调用<code>close()</code>函数就证明完成了。</p><p>在这时候，内核就会发出一个<code>FIN</code>报文，然后服务端这边进入了<code>LAST-ACK</code>，等待客户端返回给我<code>ACK</code>来结束连接</p><p>如果迟迟收不到这个<code>ACK</code>，那么就会重发这个<code>FIN</code>，然而这个重发的次数也是有限制，当达到上限的时候，那么就直接关闭连接，进入到<code>CLOSED</code></p><p>然后客户端进入了<code>FIN-WAIT-2</code>的时间不能太长，于是根据<code>tcp_fin_timeout</code>的时间的超时时间，提前进入<code>CLOSED</code></p><p><strong>第四次挥手丢失了会发生什么？</strong></p><p>第四次挥手报文的作用是用来告诉服务端，可以关闭你的连接了。这个报文的性质属于一个<code>ACK</code>的性质，服务端在没有收到这个<code>ACK</code>之前，都是处于一个<code>LAST-ACK</code>的状态。如果超时就重传<code>FIN</code>报文。</p><p>假设第四次挥手一直丢失，那么就会导致这个<code>FIN</code>不断重传，直到超过重试次数为止。</p><p>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</p><h4 id="为什么TIME-WAIT的时间是2MSL"><a href="#为什么TIME-WAIT的时间是2MSL" class="headerlink" title="为什么TIME_WAIT的时间是2MSL"></a>为什么TIME_WAIT的时间是2MSL</h4><p><code>MSL</code>是<code>Maximum Segment Lifetime</code>，叫做报文最大生存时间，它是任何网络上存在的最长时间，超过这个时间报文将会被丢弃。</p><p>假设一个包经过最大的<code>TTL</code>所需要的时间为<code>t</code>，那么<code>MSL必须要大于t</code></p><p>首先理解一个报文的生命周期:</p><p>从客户端出发-&gt;到网络中传输-&gt;到达服务端或者被丢弃，因此，一个MSL是单程票，指的是从对等端传送到另一个对等端的最大时长，那么为什么是<code>2MSL</code>呢?</p><p>首先理解一下，当收到第三个挥手的时候，这时候就进入了<code>2MSL</code>了，这时候是在等什么，是在确认对方是否收到我这个<code>ACK</code>然后关闭了连接，如果我提前关闭了连接，那么后面那个服务器发来的<code>FIN</code>我就都处理不了了，白白浪费资源</p><p>所以的话这个<code>2MSL</code>就是从进入<code>TIME-WAIT</code>开始计时的，然后这时候假如说网络很堵，<code>ACK</code>踩着点到服务端，可以理解为到达<code>MSL</code>的后一刻到达服务端，然后失效了，又正好触发超时重传，发回了一次<code>FIN</code>，然后<code>FIN</code>也踩着点到，于是就恰好等了<code>2MSL</code>才收到这个<code>FIN</code>，此时计时器重新开始计时。</p><p>就是说这个过程能够确保:本次连接中产生的所有报文段都从网络中消失了，下一个新的连接就不会出现旧的连接请求报文段了</p><h4 id="为什么需要TIME-WAIT的状态"><a href="#为什么需要TIME-WAIT的状态" class="headerlink" title="为什么需要TIME_WAIT的状态"></a>为什么需要TIME_WAIT的状态</h4><p>第一：为了保证客户端发出的最后一个ACK报文能够到达服务器。如果没有TIME_WAIT状态，客户端发送完ACK就关闭了。假如这个ACK报文丢失了，服务器就会超时重传FIN+ACK报文，因为这个时候客户端已经关闭了，它不会再发送一个ACK报文，这样服务器就没法正常关闭。</p><p>第二：防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个ACK报文后，再经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。这样下一个新的连接中不会出现这种旧的连接请求报文段。</p><hr><h3 id="9-TIME-WAIT状态过多有什么危害"><a href="#9-TIME-WAIT状态过多有什么危害" class="headerlink" title="9.TIME_WAIT状态过多有什么危害?"></a>9.TIME_WAIT状态过多有什么危害?</h3><p>客户端和服务端的<code>TIME_WAIT</code>的状态过多，所造成的状态是不一样的。</p><p>如果客户端对同一个服务端的相同<code>[IP+PORT]</code>的组合占满了之后，那么就会导致无法再对这个服务端再次发起请求了，这是因为一个<code>TCP</code>连接的标识主要是通过<code>[源IP，源PORT，目标IP，目标PORT]</code>，那么如果已经建立了连接，而且这些连接还没有进入<code>closed</code>状态的话，那么就不能够再建立一模一样的连接了，从而导致客户端无法连接上服务端</p><blockquote><p>无法连接上服务端的根本原因是已经存在了相同的连接。</p></blockquote><p>如果服务端对客户端存在太多的<code>TIME-WAIT</code>实际上对服务端的影响并不大，服务端对于新来的客户端请求依然可以接受，只要它的四元组有变化，那么就可以视为新的连接并且创建出来。但是我们说<code>TCP</code>传输数据的核心是<code>fd</code>以及执行相关<code>IO</code>操作的内核线程，如<code>select</code>等，因此有过多的无用连接存在的话，会导致服务端内存在大量的无用垃圾，如果不及时加以清理，轻则服务器性能下降，重则服务器宕机。</p><hr><h3 id="10-如何优化TIME-WAIT？"><a href="#10-如何优化TIME-WAIT？" class="headerlink" title="10.如何优化TIME_WAIT？"></a>10.如何优化TIME_WAIT？</h3><p>关于如何优化，可以从<code>TIME-WAIT</code>状态的特点入手</p><ul><li>关于<code>TIME-WAIT</code>，它被设计出来的原意是为了尽快关闭对等端的连接，避免资源被浪费</li><li>同时避免历史报文对现存的连接的报文传输造成影响</li></ul><p>那么假设，如果这个<code>TIME-WAIT</code>不会造成资源浪费呢?就是说有这样一种场景，如果对等端又发起一个一模一样的<code>TCP</code>连接请求，那么就不会造成资源浪费了，不用关闭该连接，而是直接复用，这是一种优化的思路，在<code>linux</code>下通常用:<code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_timestamps</code>的选项进行设置</p><p>当开启了这两个参数之后，当有新的连接请求<code>conncet()</code>来的时候，那么就会在内核中的<code>TIME-WAIT</code>的连接中，看是否有连接可以复用的，如果可以复用，那么就直接用它就行了</p><p>还有一种方式，一种基于限流的思想，当<code>TIME-WAIT</code>的状态严重影响系统的使用的时候，那么这时候就需要对<code>TIME-WAIT</code>加以限制，比如说超过一定的阈值，直接将连接给重置掉，不要再等了。在<code>linux</code>下通常用<code>net.ipv4.tcp_max_tw_buckets</code></p><p>还有一种方式，称为<code>SO_LINGER</code>，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code>状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p><hr><h3 id="11-服务器出现大量的TIME-WAIT的原因有什么"><a href="#11-服务器出现大量的TIME-WAIT的原因有什么" class="headerlink" title="11.服务器出现大量的TIME_WAIT的原因有什么?"></a>11.服务器出现大量的TIME_WAIT的原因有什么?</h3><p>首先<code>TIME-WAIT</code>是只有在主动断开连接的一方才会出现的，当服务器出现了大量的<code>TIME-WAIT</code>，也就是说服务器主动地断开了大量的与客户端的连接。</p><ul><li>HTTP没有使用长连接</li><li>HTTP长连接超时掉了</li><li>HTTP长连接的请求数量达到上限</li></ul><p><strong>当HTTP没有使用长连接</strong></p><p>目前来说，大部分的浏览器使用的<code>HTTP</code>协议都是<code>HTTP/1.1</code>，这与<code>HTTP/1.0</code>的区别在于，它改进了使用了长连接的技术，而不像<code>HTTP/1.0</code>一样，一个请求就对应的一个<code>TCP</code>连接，这样的消耗是很大的</p><p>先来看看长连接是如何打开的，在<code>HTTP/1.0</code>的时候，如果要开启长连接，那么就需要在请求头的<code>header</code>中添加:</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Conncetion</span><span class="token punctuation">:</span> <span class="token header-value">Keep-alive</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后当服务器收到请求做出回应的时候，这个header也被添加到响应<code>header</code>中</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">Keep-alive</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的话TCP就不会产生中断，当客户端发起了另一个请求的时候，就会复用这一条连接</p><p>那么如何来关闭<code>长连接</code>的机制呢?</p><pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">close</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要客户端和服务端任意一方的<code>header</code>中有这个字段，那么就无法使用这个机制了。</p><p>无论是哪一方禁用长连接，主动关闭连接的都是服务端</p><blockquote><p>客户端禁用了长连接，服务端开启了长连接</p></blockquote><p>此时是服务端主动关闭连接的，为什么是服务端?这是因为是<code>请求-响应</code>模型，请求-响应复用同一条连接的初衷是为用户的下一次请求能够减少连接的次数，那么客户端都关闭了长连接，就说明下一次请求就肯定不是复用这一条连接了呀</p><p>那客户端的行为应该是这样的，发起了一次请求，然后等待响应后直接关闭，不会再给服务端发送信息，因此关闭连接的时机就是在服务端了。</p><blockquote><p>客户端开启了长连接，而服务端关闭了长连接</p></blockquote><p>这个问题可以从<code>linux</code>内核的角度进行分析，如果客户端要求关闭，那么也就是说需要这样的过程:</p><p>客户端发起请求-&gt;服务端发送响应-&gt;等待客户端再发一次请求，发送断开连接的信号-&gt;发送信号-&gt;四次挥手结束</p><p>如果是服务端主动要求关闭</p><p>客户端发起请求-&gt;服务端发送响应-&gt;发送完毕发送断开连接的信号-&gt;四次挥手结束</p><p>从上面的例子可以看出，如果是客户端主动要求关闭，那么就意味着服务端有一段时间内是什么都没干，而且还占用了一定的资源的，但是结果却和服务端主动断开连接后的一样，那么当然选择消耗更小的方式了。</p><p><strong>HTTP</strong>长连接的超时问题</p><p>首先超时时间的概念就是:如果双方在完成一个<code>请求-响应</code>之后，如果在一定的时间之内没有发送新的<code>请求-响应</code>，那么系统就会回收掉这条连接，它的具体实现是基于一个<code>计时器+回调函数</code>的模型来关闭连接的，那么此时服务端上就会出现<code>TIME-WAIT</code>状态的连接。</p><p>这种往往是客户端在某一个特定的时间点内涌入系统，向服务端发送HTTP请求，然后只执行了几步操作后就完成了，那么这时候服务端就会有大量的长连接产生，并且过一段时间后超时。这种属于是正常情况，还有一种情况是服务端的接收产生问题了，客户端的请求没有被服务端接收到，从而导致无法触发自动续期的机制，导致过期。</p><p><strong>HTTP长连接的请求数量达到了上限</strong></p><p><code>Web</code>服务器通常会有一个参数来定义一条<code>HTTP</code>长连接上最大能够处理的请求数量，当超过了最大的限制之后，就会主动关闭连接，比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p><p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 ， 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p><hr><h3 id="12-如果已经建立了连接，但是客户端突然出现了故障"><a href="#12-如果已经建立了连接，但是客户端突然出现了故障" class="headerlink" title="12.如果已经建立了连接，但是客户端突然出现了故障?"></a>12.如果已经建立了连接，但是客户端突然出现了故障?</h3><p>客户端出现了故障，分为两种情况:</p><ul><li>客户端进程崩溃掉掉了，相当于调用信号函数<code>kill -9 pid</code></li><li>客户端主机宕机</li></ul><p>首先进程崩溃的情况，进程崩溃在内核中是有一套处理机制的，当进程崩溃退出的时候，如果建立了网络连接，然后就会向对方发送<code>FIN</code>报文，而一个很关键的点是<strong>四次挥手的任务是内核完成的</strong>，因此在这种情况下，网络连接是能够正常关闭的。</p><p>然而，如果是主机宕机的话，那么就意味着没有<code>FIN</code>报文的回复了，服务端无法感知，会一直处于一个<code>ESTABLISH</code>的状态，直到报活计时器超时，断开这个连接</p><hr><h3 id="13-如果已经建立了连接，但是服务端突然出现了故障"><a href="#13-如果已经建立了连接，但是服务端突然出现了故障" class="headerlink" title="13.如果已经建立了连接，但是服务端突然出现了故障?"></a>13.如果已经建立了连接，但是服务端突然出现了故障?</h3><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><hr><h3 id="14-TCP的重传机制是如何工作的"><a href="#14-TCP的重传机制是如何工作的" class="headerlink" title="14.TCP的重传机制是如何工作的?"></a>14.TCP的重传机制是如何工作的?</h3><h4 id="TCP是如何保证可靠传输的"><a href="#TCP是如何保证可靠传输的" class="headerlink" title="TCP是如何保证可靠传输的?"></a>TCP是如何保证可靠传输的?</h4><p>要保证可靠传输，首先要明白TCP在传输的时候会产生什么问题</p><p>第一个问题就是<code>数据被破坏了</code>，从而导致对方接收到的包是<code>存在错误的</code></p><p>第二个问题就是数据的<code>丢包</code>问题，从而导致TCP报文<code>没有按序到达</code></p><p>第三个问题就是数据的重复，这个通常是出现在确认迟到的情况下，简单来说就是当一个数据报到达了对等端了，但是因为确认ACK包在网络中被阻塞掉了最终导致发送方再次发送了数据，最终就导致了问题的发生</p><p>第四个问题就是没有到达对等端的数据混乱的问题，比如说发送端一次性发送了多个包，但是这多个包在网络中的传递速率是不确定的，从而导致这几个包没有按照字节流的顺序到达对等端，那么它的解决办法就是在窗口内的才接受，不在窗口内的就不接受。</p><h4 id="什么是超时重传机制"><a href="#什么是超时重传机制" class="headerlink" title="什么是超时重传机制?"></a>什么是超时重传机制?</h4><p>超时重传机制就是在发送方发送数据到对等端的开始，这时候内部就会开启一个计时器，如果在计时器的期间收到了对方的ACK，那么计时器就会重置，否则的话就会超时重传之前的报文，直到回复了本次的ACK为止。</p><h4 id="什么情况下会超时重传"><a href="#什么情况下会超时重传" class="headerlink" title="什么情况下会超时重传?"></a>什么情况下会超时重传?</h4><p>第一种情况，数据没有被对等端收到，这种情况下因为没有收到数据，所以肯定就不会发送ACK</p><p>第二种情况，数据被对等端收到了，但是ACK发送了，但是ACK却丢失了，这时候就会重传</p><p>第三种情况，ACK迟到，这种情况下数据和ACK都正常存活，但是会导致了超时重传。</p><h4 id="如何设置超时的时间"><a href="#如何设置超时的时间" class="headerlink" title="如何设置超时的时间"></a>如何设置超时的时间</h4><p><code>重传机制</code>的其中一个重要点就是如何来确认超时时间。</p><p>理论:从理论上计算，超时的时间应该要略长与RTT，当超时时间远远大于RTT，就会导致响应缓慢，无法及时重传</p><p>当超时时间远远小于RTT，就会导致不必要的重传，导致的是资源的浪费</p><p>重传超时的时间称为是RTO，这是一个非常复杂的问题，因为底层的IP网络是复杂多变的，时时刻刻都有新的网络接入或者新的网络退出，绝大部分耗时都是因为路由转发所带来的，而TCP是无法控制底层的IP网络的，因此只能够根据每一次的数据传输来确认目前的RTO应该要是多少</p><p>简单来说，就是当超时重传的数据，再次超时需要再次重传的时候，TCP的策略就是超时的间隔进行翻倍</p><p>为什么呢?这是因为当出现这种迹象的时候，就代表网络中出现用拥塞了，就不宜重传了</p><blockquote><p>超时重传存在的问题是，超时的周期可能相对较长，可以使用快速重传机制来解决超时重发的时间等待</p></blockquote><h4 id="什么是快速重传机制"><a href="#什么是快速重传机制" class="headerlink" title="什么是快速重传机制?"></a>什么是快速重传机制?</h4><p>快速重传的触发条件有:首先在超时时间之前，连续收到了三个相同的ACK，这时候就不会在超时时间到达之后才进行重传，而是立即重传数据包，这样的话就避免了当网络畅通的时候，还一直在等待超时重传的时间</p><p>快速重传机制存在什么问题?存在的问题主要是:在重传报文的时候，到底要重传什么过去?</p><p>比如说发送方发送了1 2 3 4 5 6数据报，对方收到了1 4 5 6，因此连发了4个ACK，但是因为没有收到2，因此回答的<code>ACK</code>都是2，那么在这样的情况下，对方并不知道后续的数据包是全部收到的还是全部丢失比如说:</p><p>如果只发数据包2，那么后续的数据包3完全可以一起发送过去的，这样的话就导致两次网络传输，浪费</p><p>如果将数据包2后面的数据全部一起发送过去，那么后续那些已经被接收到数据包就会被全部丢弃了，造成了不必要传输成本</p><hr><h3 id="15-什么是流量控制"><a href="#15-什么是流量控制" class="headerlink" title="15.什么是流量控制"></a>15.什么是流量控制</h3><p>一般来说，我们总希望数据传输的快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。</p><p>所谓流量控制(flow control)就是<em>让发送方的发送速率不要太快，要让接收方来得及接收</em>。</p><p>利用<strong>滑动窗口</strong>机制可以很方便地在TCP连接上实现对发送方的流量控制。TCP接收方利用自己的<strong>接收窗口</strong>的大小来限制发送方的<strong>发送窗口</strong>的大小。TCP发送方收到接收方的<strong>零窗口通知</strong>后，应启动<strong>持续计时器</strong>。持续计时器超时后，向接收方发送<strong>零窗口探测报文</strong>。</p><hr><h3 id="16-TCP的滑动窗口机制是如何工作的"><a href="#16-TCP的滑动窗口机制是如何工作的" class="headerlink" title="16.TCP的滑动窗口机制是如何工作的?"></a>16.TCP的滑动窗口机制是如何工作的?</h3><h4 id="为什么需要滑动窗口-没有滑动窗口会发生什么"><a href="#为什么需要滑动窗口-没有滑动窗口会发生什么" class="headerlink" title="为什么需要滑动窗口?没有滑动窗口会发生什么?"></a><strong>为什么需要滑动窗口?没有滑动窗口会发生什么?</strong></h4><p>TCP是每发送一个数据，都要进行一次ACK，当上一个数据包收到了应答之后，就会发送下一个数据包，这种方式叫做是<code>停止等待协议</code>，这样的传输方式有一个缺点，就是数据的往复时间越长，就会导致通信的效率越低。</p><blockquote><p>窗口:它的实现实际上是操作系统开辟的一个缓存空间，它指的是不需要等待应答，而可以继续发送数据的最大值。</p></blockquote><p>窗口的实现实际上是操作系统中开辟的一个缓存空间，发送方主机在等到应答返回之前，必须在缓冲区中保留已经发送的数据，如果按期收到了应答，那么就可以将数据从缓冲区中删除。</p><h4 id="什么叫做累计确认"><a href="#什么叫做累计确认" class="headerlink" title="什么叫做累计确认?"></a><strong>什么叫做累计确认?</strong></h4><p>累计确认是说当接收方收到一个数据报时，并不立即发送ACK，而是等到累计到一定的数量的时候才发送ACK，这样的话一次性可以确认多个报文，这个就叫做累计确认或者累计应答的模式，同时这个模式可以有效解决确认丢失的问题，比如说当发送方没有接收到序列号为500的ACK，但是如果在超时时间之内收到了500以上的ACK的，那么发送方就不需要重传序列号为500的ACK了。</p><h4 id="窗口大小由哪一方来决定"><a href="#窗口大小由哪一方来决定" class="headerlink" title="窗口大小由哪一方来决定?"></a><strong>窗口大小由哪一方来决定?</strong></h4><p>TCP的头部字段中有一个字段叫做<code>windows</code>，也就是窗口的大小，这个字段是接收端用来告诉发送自己的缓冲区还能够接收多少数据，从而发送方就可以根据这个字段来调整。</p><p>综合来说，发送的报文的大小取决于双方窗口的最小值，当发送方的窗口较小而接收方的窗口较大的时候，此时发送数据量的瓶颈在发送方，当接收方窗口较小的时候，而发送方的窗口较大的时候，由于接收方的接收能力有限，此时发送数据量的瓶颈在接收方，最终就导致了这样一个公式<code>windows = min&#123;sentWindows，getWindows&#125;</code></p><h4 id="发送方的窗口是如何工作的"><a href="#发送方的窗口是如何工作的" class="headerlink" title="发送方的窗口是如何工作的?"></a><strong>发送方的窗口是如何工作的?</strong></h4><p>对于发送的窗口而言，可以分成三个部分，已经确认的数据，已经发送但还没有确认的数据，还没有发送的数据，其中还没有发送的数据可以分为可以发送但是还没有发送的数据，不在窗口内，不能发送的数据。</p><p>它是这样工作的，有一个窗口的前沿指针，这个指针指向的是窗口的起点，有一个窗口的后沿，这个后沿决定了能够发送的最后一个字节的序号，然后后面的就都是不能够发送的字节序号。</p><p>当发送方发送完了一批数据之后，必须等待接收方的ACK，当ACK没有到来的时候，都必须要等待，不能够删除缓冲区中的数据，当接收到ACK之后，窗口开始滑动，将接收到<code>ACK-1</code>的最后一个字节的后面一个字节序号设置为窗口的前沿，然后窗口开始扩张，可以这意味着有新的数据可以发送了。</p><h4 id="接收方的窗口是如何工作的"><a href="#接收方的窗口是如何工作的" class="headerlink" title="接收方的窗口是如何工作的?"></a><strong>接收方的窗口是如何工作的?</strong></h4><p>接收方的窗口由接收方自己决定，<code>windows</code>，同样分为前沿后沿，只有在前沿和后沿中规定的数据才能接收，其他数据都会被忽略，也就是直接丢弃，当接收到了一部分的数据报之后，窗口就会向后滑动。</p><p>就可以分成三个部分:</p><ul><li>已经成功接收的数据，这些数据提交到上层应用等待读取</li><li>还没有成功接收的数据，当这些数据到来的时候，就会触发ACK并且使得接收窗口向右滑动</li><li>还没有能力接收的数据，必须等待还没有成功的数据接收到才能轮到它们</li></ul><h4 id="程序是如何表示发送方的四个部分的呢"><a href="#程序是如何表示发送方的四个部分的呢" class="headerlink" title="程序是如何表示发送方的四个部分的呢?"></a><strong>程序是如何表示发送方的四个部分的呢?</strong></h4><p>TCP的滑动窗口方案使用的是三个指针在四个传输类别中的每一个类别的指针，其中两个指针是绝对指针，它指的是特定的序列号，还有一个相对指针，需要做一个偏移</p><pre class="line-numbers language-none"><code class="language-none">SND.WND&#96;:表示发送窗口的大小&#96;(大小是由接收方指定的)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>SND.UNA</code>:是一个绝对指针，它指向的是已经发送但是还没有收到确认的第一个字节的序列号</p><p><code>SND.NXT</code>:是一个绝对指针，指向的是没有发送但是可发送范围的第一个字节的序列号。</p><pre class="line-numbers language-none"><code class="language-none">还不能够发送的数据的字节指针&#96;:&#96;SND.UNA&#96;+&#96;SND.WND<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序是如何表示接收方的三个部分的呢"><a href="#程序是如何表示接收方的三个部分的呢" class="headerlink" title="程序是如何表示接收方的三个部分的呢"></a><strong>程序是如何表示接收方的三个部分的呢</strong></h4><p><code>RCV.WND</code>:表示的是接收窗口的大小，它会通告给发送方</p><p><code>RCV.NXT</code>:是一个指针，表示的是期望的下一个数据字节的序列号</p><p><code>RCV.UNR</code>:是一个指针，表示的是指向<code>#4</code>的第一个字节。</p><hr><h3 id="17-TCP的拥塞控制机制是如何工作的"><a href="#17-TCP的拥塞控制机制是如何工作的" class="headerlink" title="17.TCP的拥塞控制机制是如何工作的?"></a>17.TCP的拥塞控制机制是如何工作的?</h3><h4 id="为什么需要拥塞控制-拥塞控制是做什么的"><a href="#为什么需要拥塞控制-拥塞控制是做什么的" class="headerlink" title="为什么需要拥塞控制?拥塞控制是做什么的?"></a><strong>为什么需要拥塞控制?拥塞控制是做什么的?</strong></h4><p>所谓的拥塞控制就是防止过多的数据注入到网络中，这样可以使得网络中的路由器或者链路不至于过载，拥塞控制所要做的都有一个前提，就是网络能够承受注目前的网络的网络负荷。</p><p><code>流量控制</code>:流量控制是保证了双方在接收和发送的数据速率保持一个相对平衡的阶段，保证发送方不会发送太快导致接收方产生丢包的情况</p><p><code>拥塞控制</code>:则是解决了在双方的接收和发送窗口都充足的情况下，却还是导致不断丢包的情况发生，这种情况下，如果在网络上的主机不对注入网络中的数据包进行限制，就会导致数据包越来越多，最终导致网络的速度奇慢无比，一种方法是在检测到发生拥塞的时候，就将减缓数据注入网络的速度，等网络畅通了之后才继续传输数据</p><h4 id="拥塞控制靠什么实现的"><a href="#拥塞控制靠什么实现的" class="headerlink" title="拥塞控制靠什么实现的?"></a><strong>拥塞控制靠什么实现的?</strong></h4><p>拥塞控制是基于拥塞窗口以及检测到拥塞后启动的那些算法来执行的，首先要搞明白，拥塞出现的原因都基本上是因为数据注入到网络中速度过快导致的，因此拥塞窗口是在发送方进行维护的。其次还有四个非常重要的算法来支持拥塞控制，拥塞控制的数据结构基础是拥塞窗口，那么执行算法就是慢启动、拥塞避免、拥塞发生、快速恢复</p><h4 id="拥塞窗口和发送窗口有什么关系"><a href="#拥塞窗口和发送窗口有什么关系" class="headerlink" title="拥塞窗口和发送窗口有什么关系?"></a><strong>拥塞窗口和发送窗口有什么关系?</strong></h4><p><code>拥塞窗口cwnd</code>是发送方维护的一个变量，它会根据网络的拥塞程度来进行动态变化，它的变化原则是:只要网络中没有出现拥塞，<code>cwnd</code>就会变大，但是只要网络中出现了拥塞，那么<code>cwnd</code>就会减少</p><p>而这个<code>cwnd</code>也是决定发送窗口的一个因素。因此有<code>swnd = min(cwnd，rwnd)</code></p><h4 id="如何检测网络中是否出现拥塞"><a href="#如何检测网络中是否出现拥塞" class="headerlink" title="如何检测网络中是否出现拥塞?"></a><strong>如何检测网络中是否出现拥塞?</strong></h4><p>网络中出现拥塞的标志通常是网络数据报在网络中被长时间的阻塞，在这种情况下通常就会导致超时重传，这个就是发生拥塞的一个标志</p><h4 id="拥塞控制有哪些算法"><a href="#拥塞控制有哪些算法" class="headerlink" title="拥塞控制有哪些算法?"></a><strong>拥塞控制有哪些算法?</strong></h4><p><code>慢启动</code>:由于加入网络时，并不知道网络中的情况如何，因此以最小的速率传递数据，在网络情况稳定了之后，因此这个过程可以看成是一个试探性的算法，一旦遇到拥塞就马上降低速率</p><p><code>拥塞避免</code><br><code>拥塞发生</code><br><code>快速恢复</code></p><h4 id="具体说说这些算法"><a href="#具体说说这些算法" class="headerlink" title="具体说说这些算法"></a><strong>具体说说这些算法</strong></h4><blockquote><p>慢启动</p></blockquote><p>慢启动的规则大概可以这样描述:首先是当初始化的时候，窗口设定为1，然后当正确收到ACK之后，这个窗口就会不断+1，因此在网络畅通的情况下，窗口会呈一个指数级的增长，那么什么时候终止呢</p><ul><li>当拥塞窗口的大小小于这个门限值的时候，就会开始启动一个慢启动的算法</li><li>当拥塞窗口的大小大于等于这个门限值的时候，就会使用一个拥塞避免的算法</li></ul><blockquote><p>拥塞避免算法</p></blockquote><p>拥塞避免指的是在慢启动阶段结束以后，就会开始一个线性的算法，这个算法主要就是每经过一个<code>RTT</code>，就会使得拥塞窗口的大小+1，它会不断地增加窗口的大小，然后就这么增长之后，网络就会慢慢进入一个拥塞的情况，于是就会开始出现丢包的现象，这时候就需要对丢失的数据包进行重传，当触发了重传的机制之后，也就进入了<code>拥塞发生算法</code></p><blockquote><p>拥塞发生算法</p></blockquote><p>当网络出现拥塞，也就是会发生数据包的重传，重传的机制主要有两种</p><ul><li>超时重传</li><li>快速重传</li></ul><h4 id="超时重传是如何工作的"><a href="#超时重传是如何工作的" class="headerlink" title="超时重传是如何工作的?"></a><strong>超时重传是如何工作的?</strong></h4><p>当发生了超时重传之后，那么就会使用拥塞发生算法，这时候就会设置<code>sshresh</code>和<code>cwnd</code></p><p>这时候的门限值就设置为<code>cwnd</code>的一半，<code>cwnd</code>重置为1，然后重新开始慢启动算法直到达到那个门限之后就变成了拥塞避免算法</p><blockquote><p>这个算法对于超时现象比较敏感，也就是说当发生了超时的时候，就会导致网络传输的速率大幅度下降。</p></blockquote><h4 id="快速重传是如何工作的"><a href="#快速重传是如何工作的" class="headerlink" title="快速重传是如何工作的?"></a><strong>快速重传是如何工作的?</strong></h4><p>快重传是让发送方尽早地直到个别报文段发生了丢失，快重传要求接收方不要等待自己发送数据的时候才捎带确认而是应该立即发送确认。</p><blockquote><p>也就是说拿到数据之后就马上发送确认，而不是携带上自己的数据到达一定阈值后才进行确认。</p></blockquote><p>快速重传和快速恢复算法一般是同时使用的，这时因为是个别报文段丢失了，属于一个偶然的现象，因此没有必要说像<code>RTO</code>超时那么剧烈，这时候会将拥塞的窗口设置为原来的一半，然后门限设置为当前的拥塞窗口。</p><p>然后这时候并不执行慢开始算法，而是执行拥塞避免算法</p><h4 id="为什么快速恢复算法中，cwnd设置回了ssthresh"><a href="#为什么快速恢复算法中，cwnd设置回了ssthresh" class="headerlink" title="为什么快速恢复算法中，cwnd设置回了ssthresh?"></a><strong>为什么快速恢复算法中，cwnd设置回了ssthresh?</strong></h4><p>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</p><p>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</p><hr><h3 id="18-断点续传的功能要怎么做"><a href="#18-断点续传的功能要怎么做" class="headerlink" title="18.断点续传的功能要怎么做?"></a>18.断点续传的功能要怎么做?</h3><p><strong>断点续传的功能</strong>可以基于切片进行实现，大概思路就是将文件进行切片，切成若干个小块，这样的话就基于使得文件的上传本来由串行上传变成了并发上传若干个小分片，这样的话可以大大减少上传的时间，另外由于是并发，传输到服务端的顺序可能会发生变化，因此还需要给每个切片记录顺序。</p><p><strong>服务端</strong></p><ul><li>服务端必须要能够合并切片，根据切片头部的文件名，切片的尺寸以及切片的顺序来确定如何将这些切片组装成最终的数据</li><li>服务端什么时候来合并切片?</li></ul><p>首先来说什么时候来合并切片?在每个切片的头部都携带一个当前文件的最大切片数量，当达到了这个数量之后就直接开始合并切片，也可以由客户端发起请求，让客户端来发起确认什么时候来合并切片</p><p>如何来合并切片?依据服务端中的切片顺序，可以在服务端中开辟一个链表之类的数据结构，给这些切片的下标进行排序，最终读取这条链表，以<code>I/O</code>流的形式写入到文件中</p><p><strong>如何实现秒传功能</strong></p><p>所谓秒传，就是指当服务端中能够检索到具有相同内容的文件的时候，直接返回文件的地址，而不需要再次上传</p><p>但是问题是:如何来确认这个文件是否已经上传过了，并且能够检测到这个文件的内容是否和之前的数据不同呢?</p><p>可以使用哈希的思路，对文件的内容进行哈希运算，生成一个数字签名，那么问题是，大文件要如何计算哈希?</p><p>可以采用一个异步线程，这个异步线程在客户端读文件进行扫描，扫描出来计算一个hash码，最终提交到服务端，服务端检查是否有这个哈希码，有这个哈希码的话就执行地址的返回，否则的话就继续执行文件的上传。</p><hr><h3 id="19-TCP的粘包问题如何解决"><a href="#19-TCP的粘包问题如何解决" class="headerlink" title="19.TCP的粘包问题如何解决?"></a>19.TCP的粘包问题如何解决?</h3><h4 id="解决方案一：特殊字符作为边界"><a href="#解决方案一：特殊字符作为边界" class="headerlink" title="解决方案一：特殊字符作为边界"></a>解决方案一：特殊字符作为边界</h4><p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p><p>HTTP 是一个非常好的例子。HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p><p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p><h4 id="解决方案二：自定义消息结构"><a href="#解决方案二：自定义消息结构" class="headerlink" title="解决方案二：自定义消息结构"></a>解决方案二：自定义消息结构</h4><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">u_int32_t</span> message_length<span class="token punctuation">;</span>     <span class="token keyword">char</span> message_data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> message<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面解析java注解</title>
      <link href="/2023/10/27/quan-mian-jie-xi-java-zhu-jie/"/>
      <url>/2023/10/27/quan-mian-jie-xi-java-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。</p><ul><li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li><li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li><li><strong>父类中的注解是不能被子类继承的</strong></li></ul><p>注解作用：</p><ul><li>标记</li><li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li><li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li></ul><p>注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p><h3 id="1-Java中的常见注解"><a href="#1-Java中的常见注解" class="headerlink" title="1.Java中的常见注解"></a>1.Java中的常见注解</h3><h4 id="JDK自带注解"><a href="#JDK自带注解" class="headerlink" title="JDK自带注解"></a>JDK自带注解</h4><p>三种标准注解</p><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><p>先定义一个接口，初始时有2个方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Deprecated</span>  <span class="token comment">//后期发现并不是所有人都会唱歌，但是这个方法也不能删，因为还有人在使用</span>    <span class="token keyword">void</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现该接口的子类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// @Override 表示覆写了父类的方法，如果把父类的 name 这个方法注释掉，则不能通过编译</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I like sing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再测试该方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span>   <span class="token comment">//加上该注解后就可以忽略"该方法已弃用"的警告，前提是自己要确定这个人的确会sing</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4种元注解"><a href="#4种元注解" class="headerlink" title="4种元注解"></a>4种元注解</h4><ul><li><p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p><ul><li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li><li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li><li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li><li><code>ElementType.METHOD</code>：用于描述方法</li><li><code>ElementType.PACKAGE</code>：用于描述包</li><li><code>ElementType.PARAMETER</code>：用于描述参数</li><li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li></ul></li><li><p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p><ul><li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li><li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li><li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li></ul></li><li><p>@Inherited：表示修饰的自定义注解可以被子类继承</p></li><li><p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p></li></ul><h4 id="常见第三方注解"><a href="#常见第三方注解" class="headerlink" title="常见第三方注解"></a>常见第三方注解</h4><p>Spring：</p><ul><li>@Autowired</li><li>@Service</li><li>@Repository</li></ul><p>Mybatis：</p><ul><li>@InsertProvider</li><li>UpdateProvider</li><li>@Options</li></ul><h3 id="2-注解的分类"><a href="#2-注解的分类" class="headerlink" title="2.注解的分类"></a>2.注解的分类</h3><h4 id="按照运行机制分"><a href="#按照运行机制分" class="headerlink" title="按照运行机制分"></a>按照运行机制分</h4><ul><li>源码注解：注解只在源码中存在，编译成.class文件就不存在了</li><li>编译时注解：注解在源码和.class文件中都存在。@Override、@Deprecated、@SuppressWarnings都属于这类</li><li>运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解</li></ul><h4 id="按来源分"><a href="#按来源分" class="headerlink" title="按来源分"></a>按来源分</h4><ul><li>来自JDK的注解</li><li>来自第三方的注解</li><li>我们自己定义的注解</li></ul><h3 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h3><p>语法规则：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">,</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">FIELD</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span>修饰符 <span class="token annotation punctuation">@interface</span> 注解名 <span class="token punctuation">&#123;</span>  <span class="token comment">//使用 @interface 关键字定义注解</span>    <span class="token comment">// 1.属性类型是受限的，合法的类型包括基本类型及String,Class,Annotation,Enumeration</span>    <span class="token comment">// 2.如果注解只有一个属性，则属性名必须取名为value()，在使用时可以忽略属性名和赋值号（=）</span>    <span class="token comment">// 3.注解类可以没有属性，没有属性的注解称为标识注解</span>    <span class="token class-name">String</span> <span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//属性以无参无异常方式声明</span>    <span class="token class-name">String</span> <span class="token function">author</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">18</span><span class="token punctuation">;</span>  <span class="token comment">//可以用default为成员指定一个默认值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-解析注解"><a href="#4-解析注解" class="headerlink" title="4.解析注解"></a>4.解析注解</h3><p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p><p>Class 类 API ：</p><ul><li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li><li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li><li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li><li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li></ul><p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParseAnn</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1.定位Class类对象</span>        <span class="token class-name">Class</span> c <span class="token operator">=</span> <span class="token class-name">Child</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment">//2.判断这个类上是否使用了某个注解</span>        <span class="token keyword">boolean</span> isCExist <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Description</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isCExist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//3.获取这个注解对象</span>            <span class="token class-name">Description</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Description</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Description</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//4.找到方法上的注解</span>        <span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">boolean</span> isMExist <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Description</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isMExist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Description</span> m <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Description</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//另一种解析方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Annotation</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Annotation</span> a <span class="token operator">:</span> as<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Description</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Description</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Description</span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-注解实战"><a href="#5-注解实战" class="headerlink" title="5.注解实战"></a>5.注解实战</h3><p>需求：</p><ol><li>有一张用户表，字段包括用户id，用户名，昵称，年龄，性别，所在城市，邮箱，手机号</li><li>方便的对每个字段或字段的组合条件进行检索，并打印出SQL</li><li>使用方式要足够简单，见代码示例</li></ol><p>一个注解，将实体类与表名映射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Table</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个注解，将实体类的属性名与表的字段映射</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">FIELD</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Column</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"nick_name"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> nickName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"city"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span><span class="token string">"mobile"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> mobile<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token class-name">String</span> userName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nickName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNickName</span><span class="token punctuation">(</span><span class="token class-name">String</span> nickName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nickName <span class="token operator">=</span> nickName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> city<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCity</span><span class="token punctuation">(</span><span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> email<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token class-name">String</span> email<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>email <span class="token operator">=</span> email<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mobile<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMobile</span><span class="token punctuation">(</span><span class="token class-name">String</span> mobile<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mobile <span class="token operator">=</span> mobile<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类，包括注解的解析</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Filter</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f1<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//查询id为10的用户</span>        <span class="token class-name">Filter</span> f2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f2<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f2<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"lucy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//模糊查询用户名为lucy，年龄为18的用户</span>        <span class="token class-name">Filter</span> f3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f3<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token string">"liu@sina.com,zh@163.com,77777@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查询邮箱为其中任意一个的用户</span>        <span class="token class-name">String</span> sql1 <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql2 <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql3 <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>f3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">Object</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//1.获取到class</span>        <span class="token class-name">Class</span> c <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取table的名字</span>        <span class="token keyword">boolean</span> exists <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Table</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>exists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Table</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Table</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Table</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> tableName <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"select * from "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>tableName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" where 1= 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.遍历所有的字段</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fArray <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> field <span class="token operator">:</span> fArray<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//4.处理每个字段对应的sql</span>            <span class="token comment">//4.1拿到字段名</span>            <span class="token keyword">boolean</span> fExists <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">Column</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fExists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">Column</span> column <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">Column</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> columnName <span class="token operator">=</span> column<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//4.2拿到字段值</span>            <span class="token class-name">String</span> fieldName <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> getMethodName <span class="token operator">=</span> <span class="token string">"get"</span> <span class="token operator">+</span> fieldName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> fieldName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Object</span> fieldValue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Method</span> getMethod <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>getMethodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                fieldValue <span class="token operator">=</span> getMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//4.3拼装sql</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fieldValue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span>fieldValue <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> fieldValue <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" and "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fieldValue <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> fieldValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> fieldValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" in ("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    sb<span class="token punctuation">.</span><span class="token function">deleteCharAt</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" = "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>fieldValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fieldValue <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" = "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>fieldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码的打印输出结果</p><p><img src="/2023/10/27/quan-mian-jie-xi-java-zhu-jie/Snipaste_2024-03-21_16-00-46.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程基础</title>
      <link href="/2023/10/18/juc-zhi-jin-cheng-xian-cheng-ji-chu/"/>
      <url>/2023/10/18/juc-zhi-jin-cheng-xian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是进程？什么是线程？"><a href="#1-什么是进程？什么是线程？" class="headerlink" title="1.什么是进程？什么是线程？"></a>1.什么是进程？什么是线程？</h3><p>进程是操作系统资源分配的基本单位。在 Java 中，当我们启动 main 函数时其实就是启动了⼀个 JVM 的进程，⽽ main函数所在的线程就是这个进程中的⼀个线程，也称主线程。</p><p>线程是进程中的⼀个执⾏单元。⼀个进程可以包含多个线程，这些线程共享进程的内存空间和系统资源。线程是操作系统调度的最⼩单位，它负责执⾏进程中的任务，但是线程的并发执⾏也可能导致⼀些问题，如竞态条件、死锁等。</p><p>通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><img src="/2023/10/18/juc-zhi-jin-cheng-xian-cheng-ji-chu/java-runtime-data-areas-jdk1.8.png" style="zoom: 80%;"><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、</strong>虚拟机栈** 和 <strong>本地方法栈</strong>。</p><h4 id="1-1程序计数器为什么是私有的？"><a href="#1-1程序计数器为什么是私有的？" class="headerlink" title="1.1程序计数器为什么是私有的？"></a>1.1程序计数器为什么是私有的？</h4><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h4 id="1-2虚拟机栈和本地方法栈为什么是私有的？"><a href="#1-2虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="1.2虚拟机栈和本地方法栈为什么是私有的？"></a>1.2虚拟机栈和本地方法栈为什么是私有的？</h4><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。方法调用对应着一个栈帧在 Java 虚拟机栈中入栈，方法执行结束对应着出栈。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h4 id="1-3一句话了解堆和方法区"><a href="#1-3一句话了解堆和方法区" class="headerlink" title="1.3一句话了解堆和方法区"></a>1.3一句话了解堆和方法区</h4><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><hr><h3 id="2-如何创建线程？"><a href="#2-如何创建线程？" class="headerlink" title="2.如何创建线程？"></a>2.如何创建线程？</h3><p>一般来说，创建线程有很多种方式，例如继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口、使用线程池、使用<code>CompletableFuture</code>类等等。</p><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p><p>严格来说，Java 就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><hr><h3 id="3-线程的生命周期和状态"><a href="#3-线程的生命周期和状态" class="headerlink" title="3.线程的生命周期和状态"></a>3.线程的生命周期和状态</h3><p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW（新建）</td><td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td></tr><tr><td>Runnable（可运行）</td><td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td></tr><tr><td>Blocked（阻塞）</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td></tr><tr><td>Waiting（无限等待）</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td></tr><tr><td>Timed Waiting （限期等待）</td><td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td></tr><tr><td>Teminated（结束）</td><td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td></tr></tbody></table><img src="/2023/10/18/juc-zhi-jin-cheng-xian-cheng-ji-chu/640.png" style="zoom: 80%;"><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>在操作系统层面，线程有 READY 和 RUNNING 状态，而在 JVM 层面，只能看到 RUNNABLE 状态。因为现在的时分(time-sharing)多任务(multi-task)操作系统通常都是用时间分片方式抢占式轮转调度。这个时间分片很小，一个线程在CPU上运行比如10-20ms（running），时间片用完就被换下等待调度(redy)。线程切换的如此之快，区分这两种状态就没什么意义了</p></blockquote><hr><h3 id="4-如何预防和避免线程死锁？"><a href="#4-如何预防和避免线程死锁？" class="headerlink" title="4.如何预防和避免线程死锁？"></a>4.如何预防和避免线程死锁？</h3><p>产生死锁有4个必要条件：</p><ul><li>互斥条件：该资源任意时刻只能有一个线程占有</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：线程已获得的资源在使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li><li>循环等待条件：即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li></ul><p>要预防死锁，我们破坏死锁产生的必要条件即可：</p><ul><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ul><hr><h3 id="5-sleep-方法和wait-方法对比"><a href="#5-sleep-方法和wait-方法对比" class="headerlink" title="5.sleep()方法和wait()方法对比"></a>5.sleep()方法和wait()方法对比</h3><p>共同点：两者都可以暂停线程的执行。</p><p>区别：</p><ul><li><p><strong>sleep()方法没有释放锁，而wait()方法释放了锁。</strong></p></li><li><p>sleep()通常被用于暂停执行，而wait通常被用于线程间交互&#x2F;通信</p></li><li><p><code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。<code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。</p></li><li><p><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？下一个问题就会聊到。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ架构</title>
      <link href="/2023/10/05/rocketmq-jia-gou/"/>
      <url>/2023/10/05/rocketmq-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>本章，我们先来看下RocketMQ的基本架构，涉及哪些核心组件，以及各个组件之间的关系又是怎样的。</p><h3 id="1-基本架构"><a href="#1-基本架构" class="headerlink" title="1.基本架构"></a>1.基本架构</h3><p>在RockectMQ中，一共有四个核心组件：<strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>、<strong>Consumer</strong>，它们之间的基本关系可以用<a href="http://rocketmq.apache.org/docs/rmq-arc/">RocketMQ官方</a>的一张图表示：</p><p><img src="/2023/10/05/rocketmq-jia-gou/jiagou.png"></p><p>上图中，Broker Cluster就是各个RocketMQ进程，Producer Cluster和Consumer Cluster分别是生产者和消费者，NameServer Cluster是路由中心。</p><h4 id="1-1Broker"><a href="#1-1Broker" class="headerlink" title="1.1Broker"></a>1.1Broker</h4><p>我们在每台机器上部署的RocketMQ进程，就称为<strong>Broker</strong>。 Broker主要负责消息的存储，一般来说，在一台配置好一点的机器上部署单个Broker实例后，可以抗大约10万QPS的请求。</p><p>我们可以看上图，Broker本身可以构建成一个集群，我们的所有消息数据是以数据分片的形式分布在各个Broker节点上，也就是每个Broker节点保存总数据的一部分。此外，为了保证集群的可用性，每个Broker节点都有自己的副本（Slave），它们之间会进行数据同步。</p><blockquote><p>Broker集群的整个架构就是数据分片集群架构和主从架构的结合</p></blockquote><h4 id="1-2NameServer"><a href="#1-2NameServer" class="headerlink" title="1.2NameServer"></a>1.2NameServer</h4><p>NameServer是RocketMQ的路由中心，每一个NameServer节点都保存着<strong>全量</strong>的路由信息。因为Broker是集群部署，所以当生产者发送消息时，需要知道将消息发送到哪个Broker，当消息者获取消息时，也需要知道从哪个Broker获取消息。</p><p>每一个Broker节点（包括Slave）都会通过<strong>心跳机制</strong>（TCP长连接），将自己的基本信息注册到每一个NameServer中，这样Producer和Consumer就可以从NameServer拉取到路由消息。</p><p>默认情况下，每个Broker会<strong>每隔30s</strong>给所有的NameServer发送心跳，告诉NameServer自己还活着；与此同时，每个NameServer<strong>每隔10s</strong>检查一下各个Broker的最近一次心跳时间，如果发现某个Broker<strong>超过120s</strong>都没发送心跳，就认为这个Broker已经挂掉了，会将其从路由信息里移除。</p><p><img src="/2023/10/05/rocketmq-jia-gou/xtjz.png"></p><blockquote><p>所谓的路由信息，可以理解为Broker集群里的各个Broker的自身信息。</p></blockquote><h4 id="1-3Producer"><a href="#1-3Producer" class="headerlink" title="1.3Producer"></a>1.3Producer</h4><p>生产者，用于生产消息，会<strong>定时从NameServer拉取路由信息</strong>，然后根据路由信息与指定的Broker建立TCP长连接，从而将消息发送到Broker中。</p><h4 id="1-4Consumer"><a href="#1-4Consumer" class="headerlink" title="1.4Consumer"></a>1.4Consumer</h4><p>消费者，用于消费消息，会<strong>定时从NameServer拉取路由信息</strong>，然后根据路由信息与指定的Broker建立TCP长连接，从而从Broker拉取消息。</p><hr><h3 id="2-高可用"><a href="#2-高可用" class="headerlink" title="2.高可用"></a>2.高可用</h3><p>了解完RocketMQ的基本架构后，我们先来看看RocketMQ是如何实现高可用的。由于Producer和Consumer是直接与我们的客户端程序相关的，可用性由我们自己来保证，所以重点看下NameServer和Broker。</p><h4 id="2-1NameServer的可用性"><a href="#2-1NameServer的可用性" class="headerlink" title="2.1NameServer的可用性"></a>2.1NameServer的可用性</h4><p>NameServer管理着Broker的基本信息，如果NameServer挂掉了，那么生产者和消费者就找不到Broker了，所以NameServer需要以集群方式部署来实现高可用。在RocketMQ中，<strong>每个NameServer都保存着Broker集群的所有Broker信息</strong>，所以就算一台NameServer服务器宕机了，还有其它NameServer可用。</p><h4 id="2-2Broker的可用性"><a href="#2-2Broker的可用性" class="headerlink" title="2.2Broker的可用性"></a>2.2Broker的可用性</h4><p>每个Broker节点都是主从架构，所以就算主节点宕掉了，从节点依然可以提供服务。但这里就要思考两个问题：</p><ol><li>主从节点之间如何进行数据同步？</li><li>RokectMQ是否具有故障自动转移机制（即主节点挂掉后，从节点自动成为主节点，不需要人工介入）？</li></ol><p>对于第一点，每一个Slave-Broker节点都会去自己的Master节点那里拉取数据，以进行同步；</p><p>对于第二点，在RocketMQ4.5版本以前，如果Master节点挂掉了，需要手动选出一个Slave节点重新作为Master节点，效率很低。所以4.5版本后，RocketMQ引入了<strong>Dleger机制</strong>，采用Raft协议进行主从节点的选举，实现故障自动转移。</p><p><img src="/2023/10/05/rocketmq-jia-gou/kyx.png"></p><hr><h3 id="3-可扩展"><a href="#3-可扩展" class="headerlink" title="3.可扩展"></a>3.可扩展</h3><p>RocketMQ之所以具有可扩展性，是因为每个Broker节点只保存整体数据的一部分，这样当数据量越来越大时，可以进行水平切分。如果读者对RabbitMQ有所了解就知道，RabbitMQ中的每个节点保存着全量数据，那么当数据量越来越大时，是没法水平扩展的，而RocketMQ通过数据分散集群的模式实现了水平扩展。</p><h4 id="3-1Topic和Tag"><a href="#3-1Topic和Tag" class="headerlink" title="3.1Topic和Tag"></a>3.1Topic和Tag</h4><p>在RocketMQ中，每一个消息都有其所属的<em><strong>Topic</strong></em>，所谓Topic，就是<em><strong>数据集合</strong></em>的意思，是一个逻辑概念。</p><p>举个例子，假设我们的订单系统需要往MQ里发送订单消息，那此时就应该建立一个Topic，它的名字可以叫做：topic_orderInfo，也就是一个包含了所有订单消息的数据集合。然后生产者发送消息时，就必须指定好消息所属的Topic，消费者消费消息时，也需要指定从哪个Topic里获取消息。</p><p>Broker在存储消息时，每一个Topic中的所有消息数据可能会分散在不同的Broker节点上，我们可以在创建Topic时进行指定。比如，假设我们的topic_orderInfo包含900万条消息，我们指定其分散在3个Broker节点上，那么每个节点就包含300万条消息数据：</p><p><img src="/2023/10/05/rocketmq-jia-gou/topic.png"></p><p>除了Topic外，还有一个<code>Tag</code>分类，区分在于 Topic 是一级分类，而 Tag 可以理解为是二级分类。</p><img src="/2023/10/05/rocketmq-jia-gou/tag.png" style="zoom:80%;"><p>那到底什么时候该用 Topic，什么时候该用 Tag？建议如下：</p><ul><li>消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分；</li><li>业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分；</li><li>消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分；</li><li>消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。</li></ul><blockquote><p>每个Broker都通过心跳机制告诉NameServer：我这里有哪些类型的Topic，每类Topic的哪些数据保存在我这。所以生产者才会知道向哪个Broker发送消息，消费者同理。</p><p>另外要注意：<strong>生产者只能往Master-Broker节点发送消息，消费既可以从Master-Broker节点消费消息，也可以从Slave-Broker节点消费消息</strong>，这个我们后面讲解Broker持久化原理时会详细介绍。</p></blockquote><hr><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>本章，我们介绍了RocketMQ的基本架构，并对其中的<strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>、<strong>Customer</strong>这四个核心组件进行了简要讲解。RocketMQ实现高可用和可扩展的思路其实没什么新意，就是基于Raft协议的主从架构，以及数据分散集群模式。</p><p>如果读者对Spring Cloud有所了解，就会发现，RocketMQ的基本架构和Spring Cloud中的很多组件非常相似，比如<strong>NameServer</strong>，其实就是类似于Spring Cloud中的Eureka服务注册中心。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap是如何保证线程安全的</title>
      <link href="/2023/10/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan-de/"/>
      <url>/2023/10/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan-de/</url>
      
        <content type="html"><![CDATA[<h3 id="1-HashMap的问题"><a href="#1-HashMap的问题" class="headerlink" title="1.HashMap的问题"></a>1.HashMap的问题</h3><p>它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p><p>在jdk8的HashMap中，假如A线程和B线程都在做put操作，当线程A通过hash函数计算出插入位置是table[i]，它就获取了头节点，但是还没来得及写入时间片就耗尽，轮到到线程B执行了，线程B通过hash函数计算得出插入位置也是table[i]，它就获取头节点然后插入了，再轮到线程A执行的时候，它直接就在头节点处插入了。造成线程A的写操作覆盖了线程B的写操作。</p><blockquote><p>总结：在获取头结点和插入Entry之间发生了线程切换  </p></blockquote><h3 id="2-Hashtable的使用注意事项"><a href="#2-Hashtable的使用注意事项" class="headerlink" title="2.Hashtable的使用注意事项"></a>2.Hashtable的使用注意事项</h3><p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>HashTable 只有一把锁，当一个线程访问HashTable的同步方法时，会将整张table 锁住，当其他线程也想访问HashTable 同步方法时，就会进入阻塞或轮询状态。也就是确保同一时间只有一个线程对同步方法的占用，避免多个线程同时对数据的修改，确保线程的安全性。<br>但HashTable 对get，put，remove 方法都使用了同步操作，这就造成如果两个线程都只想使用get 方法去读取数据时，因为一个线程先到进行了锁操作，另一个线程就不得不等待，这样必然导致效率低下，而且竞争越激烈，效率越低下。</p><h3 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3.ConcurrentHashMap"></a>3.ConcurrentHashMap</h3><p>在HashMap 的基础上，ConcurrentHashMap 将数据分为多个segment（默认16个），然后然后每次操作对一个segment 加锁，Hashtable 在竞争激烈的并发环境下表现出效率低下的原因是，由于所有访问Hashtable的线程都必须竞争同一把锁，而ConcurrentHashMap 将数据分到多个segment 中（默认16，也可在申明时自己设置，不过一旦设定就不能更改，扩容都是扩充各个segment 的容量），每个segment 都有一个自己的锁，只要多个线程访问的不是同一个segment 就没有锁争用，就没有堵塞，也就是允许16个线程并发的更新而尽量没有锁争用。</p><p>ConcurrentHashMap 的segment 就类似一个Hashtable，但比Hashtable 更加优化，前面说过Hashtable对get，put，remove 方法都会使用锁，而ConcurrnetHashMap 中get 方法是不涉及到锁的</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务基础</title>
      <link href="/2023/10/02/spring-shi-wu-ji-chu/"/>
      <url>/2023/10/02/spring-shi-wu-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-事务机制"><a href="#1-事务机制" class="headerlink" title="1.事务机制"></a>1.事务机制</h3><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>事务：数据库中多个操作合并在一起形成的操作序列，事务特征（ACID）</p><p>作用：</p><ul><li>当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（<strong>A</strong>），保障数据库即使在异常状态下仍能保持数据一致性（<strong>C</strong>）（要么操作前状态，要么操作后状态）</li><li>当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（<strong>I</strong>）</li></ul><p>Spring 事务一般加到业务层，对应着业务的操作，Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的，Spring 只提供统一事务管理接口</p><p>Spring 在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。程序是否支持事务首先取决于数据库 ，比如 MySQL ，如果是 <strong>Innodb 引擎</strong>，是支持事务的；如果 MySQL 使用 MyISAM 引擎，那从根上就是不支持事务的</p><p><strong>保证原子性</strong>：</p><ul><li>要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong></li><li>在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong> 实现，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可</li><li>回滚日志会先于数据持久化到磁盘上，这样保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务</li></ul><hr><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p><strong>分布式事务</strong>：允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源，全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高</p><p>在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE</p><hr><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，也就是方法嵌套：</p><ul><li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p></li><li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//外层事务 Service A 的 aMethod 调用内层 Service B 的 bMethod</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span>propagation<span class="token punctuation">.</span>xxx<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span>propagation<span class="token punctuation">.</span>xxx<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>支持当前事务</strong>的情况：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务则<strong>加入该事务</strong>；如果当前没有事务则创建一个新的事务<ul><li>内外层是相同的事务，在 aMethod 或者在 bMethod 内的任何地方出现异常，事务都会被回滚</li><li>工作流程：<ul><li>线程执行到 serviceA.aMethod() 时，其实是执行的代理 serviceA 对象的 aMethod</li><li>首先执行事务增强器逻辑（环绕增强），提取事务标签属性，检查当前线程是否绑定 connection 数据库连接资源，没有就调用 datasource.getConnection()，设置事务提交为手动提交 autocommit(false)</li><li>执行其他增强器的逻辑，然后调用 target 的目标方法 aMethod() 方法，进入 serviceB 的逻辑</li><li>serviceB 也是先执行事务增强器的逻辑，提取事务标签属性，但此时会检查到线程绑定了 connection，检查注解的传播属性，所以调用 DataSourceUtils.getConnection(datasource) 共享该连接资源，执行完相关的增强和 SQL 后，发现事务并不是当前方法开启的，可以直接返回上层</li><li>serviceA.aMethod() 继续执行，执行完增强后进行提交事务或回滚事务</li></ul></li></ul></li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则以非事务的方式继续运行</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则抛出异常</li></ul><p><strong>不支持当前事务</strong>的情况：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起<ul><li>内外层是不同的事务，如果 bMethod 已经提交，如果 aMethod 失败回滚 ，bMethod 不会回滚</li><li>如果 bMethod 失败回滚，ServiceB 抛出的异常被 ServiceA 捕获，如果 B 抛出的异常是 A 会回滚的异常，aMethod 事务需要回滚，否则仍然可以提交</li></ul></li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： <strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起</li><li>TransactionDefinition.PROPAGATION_NEVER： <strong>以非事务方式运行</strong>，如果当前存在事务，则抛出异常</li></ul><p>其他情况：</p><ul><li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务（两个事务没有关系）来运行<ul><li>如果 ServiceB 异常回滚，可以通过 try-catch 机制执行 ServiceC</li><li>如果 ServiceB 提交， ServiceA 可以根据具体的配置决定是 commit 还是 rollback</li><li><strong>应用场景</strong>：在查询数据的时候要向数据库中存储一些日志，系统不希望存日志的行为影响到主逻辑，可以使用该传播</li></ul></li></ul><p>requied：必须的、supports：支持的、mandatory：强制的、nested：嵌套的</p><hr><h4 id="超时属性"><a href="#超时属性" class="headerlink" title="超时属性"></a>超时属性</h4><p>事务超时，指一个事务所允许执行的最长时间，如果超过该时间限制事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1</p><hr><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中</p><p>读操作为什么需要启用事务支持：</p><ul><li>MySQL  默认对每一个新建立的连接都启用了 <code>autocommit</code> 模式，在该模式下，每一个发送到 MySQL 服务器的 SQL 语句都会在一个<strong>单独</strong>的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务</li><li>执行多条查询语句，如果方法加上了 <code>@Transactional</code> 注解，这个方法执行的所有 SQL 会被放在一个事务中，如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的收益。如果不加 <code>@Transactional</code>，每条 SQL 会开启一个单独的事务，中间被其它事务修改了数据，比如在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则这次整体的统计查询将会出<strong>现读数据不一致的状态</strong></li></ul><hr><h3 id="2-核心对象"><a href="#2-核心对象" class="headerlink" title="2.核心对象"></a>2.核心对象</h3><h4 id="事务对象"><a href="#事务对象" class="headerlink" title="事务对象"></a>事务对象</h4><p>J2EE 开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理</p><p>Spring 为业务层提供了整套的事务解决方案：</p><ul><li><p>PlatformTransactionManager</p></li><li><p>TransactionDefinition</p></li><li><p>TransactionStatus</p></li></ul><hr><h4 id="PTM"><a href="#PTM" class="headerlink" title="PTM"></a>PTM</h4><p>PlatformTransactionManager，平台事务管理器实现类：</p><ul><li><p>DataSourceTransactionManager  适用于 Spring JDBC 或 MyBatis</p></li><li><p>HibernateTransactionManager  适用于 Hibernate3.0 及以上版本</p></li><li><p>JpaTransactionManager  适用于 JPA</p></li><li><p>JdoTransactionManager  适用于 JDO</p></li><li><p>JtaTransactionManager  适用于 JTA</p></li></ul><p>管理器：</p><ul><li><p>JPA（Java Persistence API）Java EE 标准之一，为 POJO 提供持久化标准规范，并规范了持久化开发的统一 API，符合 JPA 规范的开发可以在不同的 JPA 框架下运行</p><p><strong>非持久化一个字段</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">String</span> transient1<span class="token punctuation">;</span> <span class="token comment">// not persistent because of static</span><span class="token keyword">final</span> <span class="token class-name">String</span> transient2 <span class="token operator">=</span> “<span class="token class-name">Satish</span>”<span class="token punctuation">;</span> <span class="token comment">// not persistent because of final</span><span class="token keyword">transient</span> <span class="token class-name">String</span> transient3<span class="token punctuation">;</span> <span class="token comment">// not persistent because of transient</span><span class="token annotation punctuation">@Transient</span><span class="token class-name">String</span> transient4<span class="token punctuation">;</span> <span class="token comment">// not persistent because of @Transient</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>JDO（Java Data Object）是 Java 对象持久化规范，用于存取某种数据库中的对象，并提供标准化 API。JDBC 仅针对关系数据库进行操作，JDO 可以扩展到关系数据库、XML、对象数据库等，可移植性更强</p></li><li><p>JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与 JDBC 相比，JDBC 事务则被限定在一个单一的数据库连接，而一个 JTA 事务可以有多个参与者，比如 JDBC 连接、JDO 都可以参与到一个 JTA 事务中</p></li></ul><p>此接口定义了事务的基本操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>TransactionStatus getTransaction(TransactionDefinition definition)</td><td>获取事务</td></tr><tr><td>void commit(TransactionStatus status)</td><td>提交事务</td></tr><tr><td>void rollback(TransactionStatus status)</td><td>回滚事务</td></tr></tbody></table><hr><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>TransactionDefinition 此接口定义了事务的基本信息：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getName()</td><td>获取事务定义名称</td></tr><tr><td>boolean isReadOnly()</td><td>获取事务的读写属性</td></tr><tr><td>int getIsolationLevel()</td><td>获取事务隔离级别</td></tr><tr><td>int getTimeout()</td><td>获取事务超时时间</td></tr><tr><td>int getPropagationBehavior()</td><td>获取事务传播行为特征</td></tr></tbody></table><hr><h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>TransactionStatus 此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean isNewTransaction()</td><td>获取事务是否处于新开始事务状态</td></tr><tr><td>voin flush()</td><td>刷新事务状态</td></tr><tr><td>boolean isCompleted()</td><td>获取事务是否处于已完成状态</td></tr><tr><td>boolean hasSavepoint()</td><td>获取事务是否具有回滚储存点</td></tr><tr><td>boolean isRollbackOnly()</td><td>获取事务是否处于回滚状态</td></tr><tr><td>void setRollbackOnly()</td><td>设置事务处于回滚状态</td></tr></tbody></table><hr><h3 id="3-编程式"><a href="#3-编程式" class="headerlink" title="3.编程式"></a>3.编程式</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>编程式、声明式（XML）、声明式（注解）</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>银行转账业务</p><ul><li><p>包装类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Double</span> money<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>DAO层接口：AccountDao</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountDao</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//入账操作name:入账用户名money:入账金额</span>    <span class="token keyword">void</span> <span class="token function">inMoney</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"money"</span><span class="token punctuation">)</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//出账操作name:出账用户名money:出账金额</span>    <span class="token keyword">void</span> <span class="token function">outMoney</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"money"</span><span class="token punctuation">)</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>业务层接口提供转账操作：AccountService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountService</span> <span class="token punctuation">&#123;</span><span class="token comment">//转账操作outName:出账用户名inName:入账用户名money:转账金额</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">String</span> outName<span class="token punctuation">,</span><span class="token class-name">String</span> inName<span class="token punctuation">,</span><span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>业务层实现提供转账操作：AccountServiceImpl</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">AccountService</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">AccountDao</span> accountDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAccountDao</span><span class="token punctuation">(</span><span class="token class-name">AccountDao</span> accountDao<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>accountDao <span class="token operator">=</span> accountDao<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">String</span> outName<span class="token punctuation">,</span><span class="token class-name">String</span> inName<span class="token punctuation">,</span><span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>accountDao<span class="token punctuation">.</span><span class="token function">inMoney</span><span class="token punctuation">(</span>outName<span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>        accountDao<span class="token punctuation">.</span><span class="token function">outMoney</span><span class="token punctuation">(</span>inName<span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>映射配置文件：dao &#x2F; AccountDao.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dao.AccountDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inMoney<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        UPDATE account SET money = money + #&#123;money&#125; WHERE name = #&#123;name&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>outMoney<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        UPDATE account SET money = money - #&#123;money&#125; WHERE name = #&#123;name&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>jdbc.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">jdbc.driver</span><span class="token punctuation">=</span><span class="token value attr-value">com.mysql.jdbc.Driver</span><span class="token key attr-name">jdbc.url</span><span class="token punctuation">=</span><span class="token value attr-value">jdbc:mysql://192.168.2.185:3306/spring_db</span><span class="token key attr-name">jdbc.username</span><span class="token punctuation">=</span><span class="token value attr-value">root</span><span class="token key attr-name">jdbc.password</span><span class="token punctuation">=</span><span class="token value attr-value">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>核心配置文件：applicationContext.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath:*.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.driver&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.url&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.username&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;jdbc.password&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>service.impl.AccountServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accountDao<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>typeAliasesPackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>domain<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--扫描映射配置和Dao--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dao<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ApplicationContext</span> ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"ap...xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">AccountService</span> accountService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AccountService</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"accountService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>accountService<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token string">"Jock1"</span><span class="token punctuation">,</span> <span class="token string">"Jock2"</span><span class="token punctuation">,</span> <span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="4-声明式"><a href="#4-声明式" class="headerlink" title="4.声明式"></a>4.声明式</h3><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><h5 id="tx使用"><a href="#tx使用" class="headerlink" title="tx使用"></a>tx使用</h5><p>删除 TxAdvice 通知类，开启 tx 命名空间，配置 applicationContext.xml</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--配置平台事务管理器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txManager<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--定义事务管理的通知类--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--定义控制的事务--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transfer<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">></span></span><span class="token comment">&lt;!--使用aop:advisor在AOP配置中引用事务专属通知类，底层invoke调用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pt<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>execution(* service.*Service.*(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>advisor</span> <span class="token attr-name">advice-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pt<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>aop:advice 与 aop:advisor 区别<ul><li><p>aop:advice 配置的通知类可以是普通 Java 对象，不实现接口，也不使用继承关系</p></li><li><p>aop:advisor 配置的通知类必须实现通知接口，底层 invoke 调用</p><ul><li><p>MethodBeforeAdvice</p></li><li><p>AfterReturningAdvice</p></li><li><p>ThrowsAdvice</p></li></ul></li></ul></li></ul><p>pom.xml 文件引入依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-tx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="tx配置"><a href="#tx配置" class="headerlink" title="tx配置"></a>tx配置</h5><h6 id="advice"><a href="#advice" class="headerlink" title="advice"></a>advice</h6><p>标签：tx:advice，beans 的子标签</p><p>作用：专用于声明事务通知</p><p>格式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基本属性：</p><ul><li>id：用于配置 aop 时指定通知器的 id</li><li>transaction-manager：指定事务管理器 bean</li></ul><h6 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h6><p>类型：tx:attributes，tx:advice 的子标签</p><p>作用：定义通知属性</p><p>格式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txManager<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="method"><a href="#method" class="headerlink" title="method"></a>method</h6><p>标签：tx:method，tx:attribute 的子标签</p><p>作用：设置具体的事务属性</p><p>格式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--标准格式--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>get*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>find*<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pt<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>execution(* service.*Service.*(..))<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!--标准--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：通常事务属性会配置多个，包含 1 个读写的全事务属性，1 个只读的查询类事务属性</p><p>属性：</p><ul><li>name：待添加事务的方法名表达式（支持 * 通配符）</li><li>read-only：设置事务的读写属性，true 为只读，false 为读写</li><li>timeout：设置事务的超时时长，单位秒，-1 为无限长</li><li>isolation：设置事务的隔离界别，该隔离级设定是基于 Spring 的设定，非数据库端</li><li>no-rollback-for：设置事务中不回滚的异常，多个异常使用 <code>,</code> 分隔</li><li>rollback-for：设置事务中必回滚的异常，多个异常使用 <code>,</code> 分隔</li><li>propagation：设置事务的传播行为</li></ul><hr><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><h6 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h6><p>标签：tx:annotation-driven</p><p>归属：beans 标签</p><p>作用：开启事务注解驱动，并指定对应的事务管理器</p><p>范例：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txManager<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h6 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h6><p>名称：@EnableTransactionManagement</p><p>类型：类注解，Spring 注解配置类上方</p><p>作用：开启注解驱动，等同 XML 格式中的注解驱动</p><p>范例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">"com.seazean"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"classpath:jdbc.properties"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">JDBCConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">MyBatisConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">TransactionManagerConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableTransactionManagement</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionManagerConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span><span class="token comment">//自动装配</span>    <span class="token keyword">public</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token function">getTransactionManager</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> <span class="token class-name">DataSource</span> dataSource<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceTransactionManager</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h5><p>名称：@Transactional</p><p>类型：方法注解，类注解，接口注解</p><p>作用：设置当前类&#x2F;接口中所有方法或具体方法开启事务，并指定相关事务属性</p><p>范例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>    readOnly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    timeout <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>    isolation <span class="token operator">=</span> <span class="token class-name">Isolation</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">,</span>    rollbackFor <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    noRollbackFor <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRES_NEW</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> addAccount<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><p><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效</p></li><li><p>不推荐在接口上使用 <code>@Transactional</code> 注解</p><p>原因：在接口上使用注解，<strong>只有在使用基于接口的代理（JDK）时才会生效，因为注解是不能继承的</strong>，这就意味着如果正在使用基于类的代理（CGLIB）时，那么事务的设置将不能被基于类的代理所识别</p></li><li><p>正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</p></li><li><p>默认情况下，事务只有遇到运行期异常 和 Error 会导致事务回滚，但是在遇到检查型（Checked）异常时不会回滚</p><ul><li>继承自 RuntimeException 或 error 的是非检查型异常，比如空指针和索引越界，而继承自 Exception 的则是检查型异常，比如 IOException、ClassNotFoundException，RuntimeException 本身继承 Exception</li><li>非检查型类异常可以不用捕获，而检查型异常则必须用 try 语句块把异常交给上级方法，这样事务才能有效</li></ul></li></ul><p><strong>事务不生效的问题</strong></p><ul><li><p>情况 1：确认创建的 MySQL 数据库表引擎是 InnoDB，MyISAM 不支持事务</p></li><li><p>情况 2：注解到 protected，private 方法上事务不生效，但不会报错</p><p>原因：理论上而言，不用 public 修饰，也可以用 aop 实现事务的功能，但是方法私有化让其他业务无法调用</p><p>AopUtils.canApply：<code>methodMatcher.matches(method, targetClass) --true--&gt; return true</code><br><code>TransactionAttributeSourcePointcut.matches()</code> ，AbstractFallbackTransactionAttributeSource 中 getTransactionAttribute 方法调用了其本身的 computeTransactionAttribute 方法，当加了事务注解的方法不是 public 时，该方法直接返回 null，所以造成增强不匹配</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">TransactionAttribute</span> <span class="token function">computeTransactionAttribute</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Don't allow no-public methods as required.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allowPublicMethodsOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>情况 3：注解所在的类没有被加载成 Bean</p></li><li><p>情况 4：在业务层捕捉异常后未向上抛出，事务不生效</p><p>原因：在业务层捕捉并处理了异常（try..catch）等于把异常处理掉了，Spring 就不知道这里有错，也不会主动去回滚数据，推荐做法是在业务层统一抛出异常，然后在控制层统一处理</p></li><li><p>情况 5：遇到检测异常时，也无法回滚</p><p>原因：Spring 的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。想针对检测异常进行事务回滚，可以在 @Transactional 注解里使用 rollbackFor 属性明确指定异常</p></li><li><p>情况 6：Spring 的事务传播策略在<strong>内部方法</strong>调用时将不起作用，在一个 Service 内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务，事务注解要加到调用方法上才生效</p><p>原因：Spring 的事务都是使用 AOP 代理的模式，动态代理 invoke 后会调用原始对象，而原始对象在去调用方法时是不会触发拦截器，就是<strong>一个方法调用本对象的另一个方法</strong>，所以事务也就无法生效</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//注解添加在update方法上无效，需要添加到add()方法上</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>情况 7：注解在接口上，代理对象是 CGLIB</p></li></ul><hr><h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><ul><li><p>Dao 层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountDao</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token string">"update account set money = money + #&#123;money&#125; where name = #&#123;name&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">inMoney</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"money"</span><span class="token punctuation">)</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token string">"update account set money = money - #&#123;money&#125; where name = #&#123;name&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">outMoney</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"money"</span><span class="token punctuation">)</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>业务层</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AccountService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//对当前方法添加事务，该配置将替换接口的配置</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>        readOnly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        timeout <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>        isolation <span class="token operator">=</span> <span class="token class-name">Isolation</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">,</span>        rollbackFor <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">//java.lang.ArithmeticException.class, IOException.class</span>        noRollbackFor <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span>        <span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">String</span> outName<span class="token punctuation">,</span> <span class="token class-name">String</span> inName<span class="token punctuation">,</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccountServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">AccountService</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">AccountDao</span> accountDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">String</span> outName<span class="token punctuation">,</span> <span class="token class-name">String</span> inName<span class="token punctuation">,</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        accountDao<span class="token punctuation">.</span><span class="token function">inMoney</span><span class="token punctuation">(</span>outName<span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//int i = 1/0;</span>        accountDao<span class="token punctuation">.</span><span class="token function">outMoney</span><span class="token punctuation">(</span>inName<span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>添加文件 Spring.config、Mybatis.config、JDBCConfig (参考ioc_Mybatis)、TransactionManagerConfig</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token string">"classpath:jdbc.properties"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">JDBCConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token class-name">MyBatisConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableTransactionManagement</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringConfig</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="5-模板对象"><a href="#5-模板对象" class="headerlink" title="5.模板对象"></a>5.模板对象</h3><p>Spring 模板对象：TransactionTemplate、JdbcTemplate、RedisTemplate、RabbitTemplate、JmsTemplate、HibernateTemplate、RestTemplate</p><ul><li><p>JdbcTemplate：提供标准的 sql 语句操作API</p></li><li><p>NamedParameterJdbcTemplate：提供标准的具名 sql 语句操作API</p></li><li><p>RedisTemplate：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changeMoney</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">Double</span> money<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"account:id:"</span><span class="token operator">+</span>id<span class="token punctuation">,</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token class-name">Double</span> <span class="token function">findMondyById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> money <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"account:id:"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>money<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="/2023/10/02/spring-shi-wu-ji-chu/Spring-RedisTemplate.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言常见面试题</title>
      <link href="/2023/09/26/java-yu-yan-chang-jian-mian-shi-ti/"/>
      <url>/2023/09/26/java-yu-yan-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-说一说你对static关键字的理解"><a href="#1-说一说你对static关键字的理解" class="headerlink" title="1.说一说你对static关键字的理解"></a>1.说一说你对static关键字的理解</h3><p>在Java类里只能包含成员变量、方法、内部类3种成员，都可以使用static修饰，外加代码块可以使用static修饰，以static修饰的成员就是<strong>类成员</strong>。类成员属于整个类，而不属于单个对象。</p><p>类成员储存在方法区中，对象是存放在堆内存的。</p><p>对static关键字而言，有一条非常重要的规则：类成员不能访问实例成员，实例成员可以访问类成员。因为JVM的初始化顺序是先静态域，然后是非静态域，所以可能出现类成员已经初始化完成，但实例成员还没有初始化的情况，如果允许类成员访问实例成员将会引起大量错误。</p><h3 id="16-什么是代码块"><a href="#16-什么是代码块" class="headerlink" title="16.什么是代码块"></a>16.什么是代码块</h3><p>代码块又叫初始化块，属于类中的成员，即类的一部分 类似于方法，将逻辑语句封装在方法提中，通过{}定义的一段代码。但和方法不同，没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类显示调用，而是在加载类的时候或者创建对象的时候隐式调用。</p><ol><li><p>静态代码块：使用<code>static</code>关键字去定义，静态代码块中的代码会在JVM类加载时运行，且只被执行一次。</p></li><li><p>构造代码块：和静态代码块的唯一区别就是没有static修饰</p></li><li><p>普通代码块：定义在方法中的代码块，一般不会这么无聊去使用它。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//直接使用&#123;&#125;定义普通代码块</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x1="</span><span class="token operator">+</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x2="</span><span class="token operator">+</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论这三部分的位置如何放置，都是静态代码块先执行，然后是构造代码块。静态代码块只会执行一次，构造代码块在每次实例化对象时都会执行。</p></li></ol><h3 id="2-什么是静态内部类"><a href="#2-什么是静态内部类" class="headerlink" title="2.什么是静态内部类"></a>2.什么是静态内部类</h3><p>如果使用static来修饰一个内部类，则这个内部类就被称为静态内部类。</p><p>静态内部类需满足如下规则：</p><ol><li>静态内部类可以包含静态成员，也可以包含非静态成员；</li><li>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</li><li>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</li><li>在外部类的外部，也可以实例化静态内部类，语法如下：<code>外部类.内部类 变量名 = new 外部类.内部类构造方法();</code></li></ol><h3 id="3-说一说你对final关键字的理解"><a href="#3-说一说你对final关键字的理解" class="headerlink" title="3.说一说你对final关键字的理解"></a>3.说一说你对final关键字的理解</h3><ul><li>修饰对象：成员变量，方法，类，局部变量（方法中的变量）</li><li>final修饰的属性的初始化可以在编译期，也可以在运行期，初始化后不能被改变。</li><li>final修饰的方法表示该方法在子类中不能被重写，final修饰的类表示该类不能被继承。</li><li>对于基本类型数据，final会将值变为一个常数（创建后不能被修改）；但是对于对象句柄（亦可称作引用或者指针），final会将句柄变为一个常数（进行声明时，必须将句柄初始化到一个具体的对象。而且不能再将句柄指向另一个对象。但是，对象的本身是可以修改的。这一限制也适用于数组，数组也属于对象，数组本身也是可以修改的。方法参数中的final句柄，意味着在该方法内部，我们不能改变参数句柄指向的实际东西，也就是说在方法内部不能给形参句柄再另外赋值）。</li></ul><h3 id="3-static-final和final-static有什么区别吗？"><a href="#3-static-final和final-static有什么区别吗？" class="headerlink" title="3.static final和final static有什么区别吗？"></a>3.static final和final static有什么区别吗？</h3><p>没区别，写法问题</p><h3 id="4-static-final是什么？"><a href="#4-static-final是什么？" class="headerlink" title="4.static final是什么？"></a>4.static final是什么？</h3><p>static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。</p><p>static final也可以修饰方法，表示该方法不能重写，可以通过类名调用。</p><h3 id="5-final、finally、finalize的区别？"><a href="#5-final、finally、finalize的区别？" class="headerlink" title="5.final、finally、finalize的区别？"></a>5.final、finally、finalize的区别？</h3><ol><li>final就是不可变的意思，可以修饰成员变量、局部变量、⽅法和类。修饰变量时，这个变量必须初始化，所以也称为常量。</li><li>finally是异常处理的⼀部分，只能⽤在try&#x2F;catch中，并且附带⼀个语句块表示这段语句⼀定会被执⾏，⽆论是否抛出异常。</li><li>finalize是java.lang.Object中的⽅法，也就是每⼀个对象都有这个⽅法，⼀个对象的finalize⽅法只会调⽤⼀次，调⽤了不⼀定被回收，因为只有对象被回收的时候才会被回收，就会导致前⾯调⽤，后⾯回收的时候出现问题，不推荐使⽤。</li></ol><h3 id="6-浅拷贝和深拷贝有什么区别？"><a href="#6-浅拷贝和深拷贝有什么区别？" class="headerlink" title="6.浅拷贝和深拷贝有什么区别？"></a>6.浅拷贝和深拷贝有什么区别？</h3><ul><li>浅拷⻉：浅拷⻉创建⼀个新对象，然后将原对象的⾮静态字段复制到新对象。如果字段是基本数据类型，那么就复制其值；如果字段是引⽤类型，复制的就是引⽤⽽不是实际对象。</li><li>创建⼀个新对象，并递归复制原对象中的所有引⽤类型的字段指向的对象，⽽不是共享引⽤。因此，新对象和原对象中的引⽤类型字段引⽤的是两组不同的对象。</li></ul><p>总结：</p><ul><li><p>浅拷⻉复制对象，包括对象的引⽤，两者共享引⽤对象。</p></li><li><p>深拷⻉复制对象及其引⽤的对象，两者不共享引⽤对象，即使引⽤对象也会被复制。</p></li><li><p>在Java中，浅拷⻉通常通过 clone ⽅法实现，深拷⻉可以通过⼿动实现 clone ⽅法、序列化和反序列化，或</p><p>者使⽤第三⽅库来实现。</p></li></ul><h3 id="7-反射机制是什么？"><a href="#7-反射机制是什么？" class="headerlink" title="7.反射机制是什么？"></a>7.反射机制是什么？</h3><p>反射的核心类是<code>Class</code>类，它是Java反射机制的入口。通过Class类，可以获取类的构造器、方法、字段等信息，而不需要在编译时确定这些信息。</p><p>反射的基本步骤包括获取<code>Class</code>对象，获取类的信息（构造器、方法、字段等），然后通过Constructor、Method、Field等类的实例进行具体的操作。</p><p>优点：程序可以在运行时动态的获取和操作类的信息，这使得代码更加灵活，能够使用不同的场景和需求。</p><p>缺点：反射允许绕过编译时的类型检查，这可能导致在运⾏时出现类型安全性问题，并且它涉及到在运⾏时进⾏类型检查和动态分派。这可能导致性能开销。</p><h3 id="8-如何对Integer和Double类型判断值相等？"><a href="#8-如何对Integer和Double类型判断值相等？" class="headerlink" title="8.如何对Integer和Double类型判断值相等？"></a>8.如何对Integer和Double类型判断值相等？</h3><p>Integer、Double不能直接进行比较，这包括：</p><ul><li>不能用&#x3D;&#x3D;进行直接比较，因为它们是不同的数据类型；</li><li>不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；</li><li>不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。</li></ul><p>正确方法：整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用&#x3D;&#x3D;进行比较。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token class-name">Double</span> d <span class="token operator">=</span> <span class="token number">100.00</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="9-和equals-有什么区别？"><a href="#9-和equals-有什么区别？" class="headerlink" title="9.&#x3D;&#x3D;和equals()有什么区别？"></a>9.&#x3D;&#x3D;和equals()有什么区别？</h3><p>&#x3D;&#x3D;运算符：</p><ul><li>作用于基本数据类型时，是比较两个数值是否相等；</li><li>作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；</li></ul><p>equals()方法：</p><ul><li>没有重写时，Object默认以 &#x3D;&#x3D; 来实现，即比较两个对象的内存地址是否相同；</li><li>进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。</li></ul><h3 id="10-说一说hashCode-和equals-的关系"><a href="#10-说一说hashCode-和equals-的关系" class="headerlink" title="10.说一说hashCode()和equals()的关系"></a>10.说一说hashCode()和equals()的关系</h3><p>hashCode()用于获取哈希码（散列码），eauqls()用于比较两个对象是否相等，它们应遵守如下规定：</p><ul><li>如果两个对象相等，则它们必须有相同的哈希码。</li><li>如果两个对象有相同的哈希码，则它们未必相等。</li></ul><p><strong>扩展阅读：</strong></p><p>在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。</p><p>当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。</p><p>HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。</p><h3 id="11-为什么要重写hashCode-和equals"><a href="#11-为什么要重写hashCode-和equals" class="headerlink" title="11.为什么要重写hashCode()和equals()?"></a>11.为什么要重写hashCode()和equals()?</h3><p>Object类提供的equals()方法默认是用&#x3D;&#x3D;来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。</p><p>⽽由于hashCode()与equals()具有联动关系（如果两个对象相等，则它们必须有相同的哈希码），所以equals()⽅法重写时，通常也要将hashCode()进⾏重写，使得这两个⽅法始终保持⼀致性。</p><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="12-String类可以被继承吗？"><a href="#12-String类可以被继承吗？" class="headerlink" title="12.String类可以被继承吗？"></a>12.String类可以被继承吗？</h3><p>String类由final修饰，所以不能被继承。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//省略</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>扩展阅读</strong></p><p>在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。</p><ul><li>Java 9之前字符串采用char[]数组来保存字符，即 private final char[] value；</li><li>Java 9做了改进，采用byte[]数组来保存字符，即 private final byte[] value；</li></ul><p>之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下2点。</p><ol><li>是保证了线程安全，由于 String 的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。如果在多线程的环境中，我们需要对某个字符串频繁的修改，可以使用StringBuffer类。</li><li>节约内存，JVM里面有字符串常量池，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。</li></ol><h3 id="13-使用字符串时，new和””更推荐使用哪种方式？"><a href="#13-使用字符串时，new和””更推荐使用哪种方式？" class="headerlink" title="13.使用字符串时，new和””更推荐使用哪种方式？"></a>13.使用字符串时，new和””更推荐使用哪种方式？</h3><p>先看看 “hello” 和 new String(“hello”) 的区别：</p><ul><li>当Java程序直接使用 “hello” 的字符串直接量时，JVM将会使用常量池来管理这个字符串；</li><li>当使用 new String(“hello”) 时，JVM会先使用常量池来管理 “hello” 直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。</li></ul><p>显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用直接量的方式创建字符串。</p><h3 id="14-字符串拼接"><a href="#14-字符串拼接" class="headerlink" title="14.字符串拼接"></a>14.字符串拼接</h3><p>拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。</p><ol><li>+ 运算符：如果拼接的都是字符串字面量，则适合使用 + 运算符实现拼接；</li><li>StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；</li><li>StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；</li><li>String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；</li></ol><p><strong>扩展阅读</strong></p><p>采用 + 运算符拼接字符串时：</p><ul><li>如果拼接的都是字符串字面量，拼接操作在编译器的编译期间就执行了，会直接把拼接后的常量放入字符串常量池中。</li><li>如果拼接操作包含字符串引用，那么它是在Java运行期间执行的，新创建的字符串存放在堆内存中。</li></ul><p>采用StringBuilder&#x2F;StringBuffer拼接字符串时：</p><ul><li>StringBuilder&#x2F;StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。</li><li>缓冲区频繁的扩容会降低拼接的性能，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。</li></ul><p>采用String类的concat方法拼接字符串时：</p><ul><li>concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。</li><li>在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以只拼2个字符串时建议优先选择concat方法。</li></ul><hr><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><h3 id="15-面向对象有哪三大特性？详细讲讲这些特性的含义"><a href="#15-面向对象有哪三大特性？详细讲讲这些特性的含义" class="headerlink" title="15.面向对象有哪三大特性？详细讲讲这些特性的含义"></a>15.面向对象有哪三大特性？详细讲讲这些特性的含义</h3><p>三大特性是封装、继承和多态</p><ol><li>封装：是指将对象的数据和操作数据的方法捆绑在一起，形成一个独立的对象（类）。封装还意味着隐藏对象的内部状态和实现细节，仅通过对象提供的接口（方法）来访问对象的属性和行为。这样做的好处是提高了代码的安全性和可维护性，因为对象的内部实现可以自由更改，而不影响外部代码。</li><li>继承：继承是一种创建新类的方式，子类可以继承父类或超类的属性和方法。继承支持代码的复用，允许开发者在现有类的基础上添加新功能，而不必重写现有代码。继承还支持建立类之间的层次结构，使得代码更加有组织。</li><li>多态： 是指允许不同类的对象对同一消息做出响应的能力，即同一个接口可以被不同的实例以不同的方式实现。这意味着一个函数或者方法可以有多个不同的行为。多态使得代码更加灵活，因为可以用统一的接口来处理不同类型的对象，而具体的行为则取决于对象的实际类型。</li></ol><h3 id="16-在创建子类对象时类的初始化过程"><a href="#16-在创建子类对象时类的初始化过程" class="headerlink" title="16.在创建子类对象时类的初始化过程"></a>16.在创建子类对象时类的初始化过程</h3><p><strong>第一次创建子类对象：</strong></p><ol><li>父类静态域</li><li>子类静态域</li><li>父类构造代码块</li><li>父类构造方法</li><li>子类构造代码块</li><li>子类构造方法</li></ol><p><strong>规律就是 父类先于子类 静态的先于非静态的</strong></p><p><strong>之后创建子类对象，父类和子类的静态代码块不会执行，其余不变</strong></p><p><strong>解释：</strong></p><p>1、java的机制是先编译成字节码文件.class  然后在JVM上解释器逐行翻译成机器码文件，那从.class 到JVM加载的时候，就执行static代码块和static变量，所以先执行静态代码块，并且执行顺序是先执行父类的在执行子类的。</p><p>2、创建对象的时候，调用了它的构造方法，所有子类的构造方法第一行的时候都隐含 super()，所以会先调用父类的构造方法，而每次在执行构造方法之前都会执行代码块，父类的代码块，父类的构造方法执行完毕之后，开始执行子类的代码块，构造方法。</p><p>3、补充：</p><p>​    （1）如果有多个构造方法（比如：有参的、无参的、参数个数不同的），根据创建对象时传的参数找对应的构造方法（比如：无参的找无参的，有参的找有参的）。</p><p>​    （2）多态的顺序也是这样的。</p><p>​    （3）加上main方法</p><p>​            子类和main方法在同一个类中，如果在new子类对象之前main方法中有语句，那么顺序就是：静态、main（）的语句、父类代码块、父类构造方法…… </p><p>​            如果新建一个测试类、在new子类对象之前main方法中有语句，顺序为：main（）的语句、静态、父类代码块。</p><p>​       解释：如果子类和main在同一个类中，加载子类，静态、执行main。如果不在同一个类，先加载main的类，执行到new子类时，才加载子类。</p><h3 id="18-为什么Java是单继承的，可以实现多个接口？"><a href="#18-为什么Java是单继承的，可以实现多个接口？" class="headerlink" title="18.为什么Java是单继承的，可以实现多个接口？"></a>18.为什么Java是单继承的，可以实现多个接口？</h3><p>多继承会产生钻石问题(菱形继承)：</p><ul><li>类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法</li><li>类 D 同时继承了类 B 和类 C</li><li>对于类 B、C 重写的类 A 中的方法，类 D 会继承哪一个？这里就会产生歧义</li><li>考虑到这种二义性问题，Java 不支持多重继承</li></ul><p>Java 支持类实现多接口</p><ul><li>接口中的方法是抽象的，一个类实现可以多个接口</li><li>假设这些接口中存在相同方法(方法名与参数相同)，在实现接口时，这个方法需要实现类来实现，并不会出现二义性的问题</li></ul><h3 id="19-谈谈你对super和this的理解"><a href="#19-谈谈你对super和this的理解" class="headerlink" title="19.谈谈你对super和this的理解"></a>19.谈谈你对super和this的理解</h3><p><img src="/2023/09/26/java-yu-yan-chang-jian-mian-shi-ti/this_super_20250107152609.jpg"></p><ul><li>this:代表当前对象名（在程序易产生二义性之处，应该使用this来指明当前对象；如果函数的形参与类中的成员属性同名，这时需要this来指明成员属性名）</li><li>this()和super()都是指的是对象，所以均不可在static环境中使用</li><li>从本质上讲，this是一个指向本对象的指针，而super是一个java关键字</li></ul><p>在java中，所有的子类构造器会默认调用super()，用于初始化父类，同时当父类中存在有参构造器时，必须再提供无参构造器，否则子类构造器默认调用super()方法时就会出现找不到的报错。</p><h3 id="20-谈谈你对重载和重写的理解"><a href="#20-谈谈你对重载和重写的理解" class="headerlink" title="20.谈谈你对重载和重写的理解"></a>20.谈谈你对重载和重写的理解</h3><ol><li>方法重载（overload）：在一个类中有相同的函数名，但是参数不同，参数不同包括个数不同，顺序不同，类型不同，然后重载的返回值可以不同</li><li>方法重写（override）:方法重写要求遵守两同两小一大原则：方法名相同，参数相同；子类返回类型小于等于父类方法返回类型，子类抛出异常小于等于父类方法抛出异常；子类访问权限大于等于父类方法访问权限</li></ol><h4 id="21-谈谈你对ThreadLocal的理解"><a href="#21-谈谈你对ThreadLocal的理解" class="headerlink" title="21.谈谈你对ThreadLocal的理解"></a>21.谈谈你对ThreadLocal的理解</h4><p>ThreadLoca是线程局部存储TLS(thread local storage)的一种实现，是解决多线程中的对同一变量的的访问冲突的一种技术，ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本。</p><p>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。ThreadLocal 不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是为了方便每个线程处理自己的状态而引入的一个机制.</p><p>它是一种采用空间换时间的技术，用副本代替加锁。threadlocal就像一个key，具体的副本值value保存在thread对象的map里面，多个线程可以通过同一个key取出自己map里面对应的value，本质上threadlocal的get和set都操作的是每个thread自己的数据，实际上threadlocal对象自身没有变化，只是每个线程把同一个threadlocal对象当做一把打开自己map的钥匙而已，多个thread是可以并发调用get和set的并且不出错。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常机制详解</title>
      <link href="/2023/09/20/java-yi-chang-ji-zhi-xiang-jie/"/>
      <url>/2023/09/20/java-yi-chang-ji-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p><p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p><p>Java 中异常继承的根类是：Throwable</p><pre class="line-numbers language-none"><code class="language-none">异常的体系:         Throwable(根类，不是异常类)      &#x2F;              \    Error           Exception（异常，需要研究和处理）                    &#x2F;            \                   编译时异常     RuntimeException(运行时异常)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exception 异常的分类:</p><ul><li><strong>编译时异常（Checked异常）</strong>：在编译时必须被处理的异常，程序运行时可能出现的可预见的错误，例如文件找不到、输入输出错误等，如IOException。</li><li><strong>运行时异常（Runtime异常）</strong>：RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错，如空指针异常、数组越界等。</li></ul><hr><h3 id="2-处理过程"><a href="#2-处理过程" class="headerlink" title="2.处理过程"></a>2.处理过程</h3><p>异常的产生默认的处理过程解析：（自动处理的过程）</p><ol><li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li><li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li><li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li><li>直接从当前执行的异常点终止当前程序</li><li>后续代码没有机会执行了，因为程序已经死亡</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序开始。。。。。。。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">chu</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束。。。。。。。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不执行</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">chu</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">/</span> b <span class="token punctuation">;</span><span class="token comment">// 出现了运行时异常,自动创建异常对象：ArithmeticException</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结果是："</span><span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/09/20/java-yi-chang-ji-zhi-xiang-jie/Snipaste_2024-03-21_17-06-56.png"></p><hr><h3 id="3-编译异常"><a href="#3-编译异常" class="headerlink" title="3.编译异常"></a>3.编译异常</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p><p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ParseException</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> date <span class="token operator">=</span> <span class="token string">"2015-01-12 10:23:21"</span><span class="token punctuation">;</span><span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Date</span> d <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/09/20/java-yi-chang-ji-zhi-xiang-jie/Snipaste_2024-03-21_17-11-51.png"></p><hr><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p><p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序开始。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"2013-03-23 10:19:23"</span><span class="token punctuation">;</span>    <span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Date</span> date <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束。。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h5><p>可以处理异常，并且出现异常后代码也不会死亡</p><ul><li><p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 监视可能出现异常的代码！</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">1</span> 变量<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 处理异常</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">2</span> 变量<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 处理异常</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>finall<span class="token punctuation">&#123;</span><span class="token comment">//资源释放</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 可能出现异常的代码！</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// **直接打印异常栈信息**</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>Throwable成员方法:</strong></p><ul><li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li><li><code>public String toString()</code>：返回此可抛出的简短描述</li><li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序开始。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"2013-03-23 10:19:23"</span><span class="token punctuation">;</span>        <span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Date</span> date <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/meinv.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束。。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h5 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h5><p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionDemo</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序开始。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">parseDate</span><span class="token punctuation">(</span><span class="token string">"2013-03-23 10:19:23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">parseDate</span><span class="token punctuation">(</span><span class="token class-name">String</span> time<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-运行异常"><a href="#3-运行异常" class="headerlink" title="3.运行异常"></a>3.运行异常</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行异常编译阶段不管处不处理，代码编译都能通过</p><p><strong>常见的运行时异常</strong>：</p><ol><li>数组索引越界异常：ArrayIndexOutOfBoundsException</li><li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li><li>类型转换异常：ClassCastException</li><li>迭代器遍历没有此元素异常：NoSuchElementException</li><li>算术异常（数学操作异常）：ArithmeticException</li><li>数字转换异常：NumberFormatException</li></ol><hr><h4 id="处理机制-1"><a href="#处理机制-1" class="headerlink" title="处理机制"></a>处理机制</h4><p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p><p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionDemo</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序开始。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token function">chu</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ArithmeticException: / by zero</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//没输出</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"操作失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出了</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序结束。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出了</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">chu</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> a <span class="token operator">/</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="4-Finally"><a href="#4-Finally" class="headerlink" title="4.Finally"></a>4.Finally</h3><p>用在捕获处理的异常格式中的，放在最后面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 可能出现异常的代码！</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 无论代码是出现异常还是正常执行，最终一定要执行这里的代码！！</span><span class="token punctuation">&#125;</span><span class="token keyword">try</span><span class="token operator">:</span> <span class="token number">1</span>次。<span class="token keyword">catch</span>：<span class="token number">0</span><span class="token operator">-</span><span class="token class-name">N</span>次  <span class="token punctuation">(</span>如果有<span class="token keyword">finally</span>那么<span class="token keyword">catch</span>可以没有<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token operator">:</span> <span class="token number">0</span><span class="token operator">-</span><span class="token number">1</span>次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p><p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p><p>注意：如果在 finally 中出现了 return，会吞掉异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinallyDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">chu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//一定会输出 finally,优先级比return高</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">chu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">;</span>            <span class="token keyword">return</span> a <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====finally被执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//return 111; // 不建议在finally中写return，会覆盖前面所有的return值!</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">&#123;</span>            is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/cang.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"==finally被执行==="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 回收资源。用于在代码执行完毕以后进行资源的回收操作！</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>is<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span>is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="5-自定义Exception"><a href="#5-自定义Exception" class="headerlink" title="5.自定义Exception"></a>5.自定义Exception</h3><p>自定义异常:</p><ul><li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li><li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li></ul><p>throws：用在方法上，用于抛出方法中的异常</p><p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//需求：认为年龄小于0岁，大于200岁就是一个异常。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">checkAge</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AgeIllegalException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">checkAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ItheimaAgeIllegalException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> age <span class="token operator">></span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//年龄在0-200之间</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AgeIllegalException</span><span class="token punctuation">(</span><span class="token string">"/ age is illegal!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//throw new AgeIllegalRuntimeException("/ age is illegal!");</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"年龄是："</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgeIllegalException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Alt</span> <span class="token operator">+</span> <span class="token class-name">Insert</span><span class="token operator">-></span><span class="token class-name">Constructor</span> <span class="token punctuation">&#125;</span><span class="token comment">//编译时异常</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgeIllegalRuntimeException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token class-name">AgeIllegalRuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">AgeIllegalRuntimeException</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行时异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="6-try-语法含义及用法"><a href="#6-try-语法含义及用法" class="headerlink" title="6.try(){}语法含义及用法"></a>6.try(){}语法含义及用法</h3><blockquote><p>try(){}语法自jdk1.7引入，主要用于简化try{}catch{}语法中关闭流的系列操作</p></blockquote><p>带资源的try语句（try-with-resource）的最简形式为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> res <span class="token operator">=</span> xxx<span class="token punctuation">)</span><span class="token comment">//可指定多个资源</span><span class="token punctuation">&#123;</span>     work <span class="token keyword">with</span> <span class="token namespace">res</span><span class="token punctuation">&#125;</span>                                                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>try块退出时，会自动调用res.close()方法，关闭资源。不用写一大堆finally来关闭资源,所有实现Closeable的类声明都可以写在里面,最常见于流操作,socket操作,新版的httpclient也可以;</p><p>需要注意的是,try()的括号中可以写多行声明,每个声明的变量类型都必须是Closeable的子类,用分号隔开.</p><hr><h3 id="7-处理规范"><a href="#7-处理规范" class="headerlink" title="7.处理规范"></a>7.处理规范</h3><p>异常的语法注意：</p><ol><li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li><li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li><li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li><li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li><li>在 try&#x2F;catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li></ol><p>异常的作用：</p><ol><li><p>可以处理代码问题，防止程序出现异常后的死亡</p></li><li><p>提高了程序的健壮性和安全性</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//请输入一个合法的年龄</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">try</span><span class="token punctuation">&#123;</span>                <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请您输入您的年年龄："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> age <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"年龄："</span><span class="token operator">+</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"您的年龄是瞎输入的！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-常见面试题"><a href="#8-常见面试题" class="headerlink" title="8.常见面试题"></a>8.常见面试题</h3><h4 id="遇到过异常吗？如何处理？"><a href="#遇到过异常吗？如何处理？" class="headerlink" title="遇到过异常吗？如何处理？"></a>遇到过异常吗？如何处理？</h4><p>在Java中，可以按照如下三个步骤处理异常：</p><ol><li><p>捕获异常</p><p>将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。</p></li><li><p>处理异常</p><p>在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。</p></li><li><p>回收资源</p><p>如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p></li></ol><h4 id="说一说java的异常机制"><a href="#说一说java的异常机制" class="headerlink" title="说一说java的异常机制"></a>说一说java的异常机制</h4><p>关于异常处理：</p><p>在Java中，处理异常的语句由try、catch、finally三部分组成。其中，try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p><p>关于抛出异常：</p><p>当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。</p><p>关于异常跟踪栈：</p><p>程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p><h4 id="请介绍Java的异常接口"><a href="#请介绍Java的异常接口" class="headerlink" title="请介绍Java的异常接口"></a>请介绍Java的异常接口</h4><p>Throwable是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是Error、Exception。</p><p>Error是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。</p><p>Exception是异常，它被分为两大类，分别是Checked异常和Runtime异常。所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现。</p><h4 id="finally是无条件执行的吗"><a href="#finally是无条件执行的吗" class="headerlink" title="finally是无条件执行的吗"></a>finally是无条件执行的吗</h4><p>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p><blockquote><p>注意：如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p></blockquote><h4 id="在finally中return会发生什么？"><a href="#在finally中return会发生什么？" class="headerlink" title="在finally中return会发生什么？"></a>在finally中return会发生什么？</h4><p>在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句失效。</p><p><strong>详细解析：</strong></p><p>当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止；如果有finally块，系统立即开始执行finally块。只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用集合及其底层原理剖析</title>
      <link href="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/"/>
      <url>/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-框架体系"><a href="#1-框架体系" class="headerlink" title="1. 框架体系"></a>1. 框架体系</h3><p>先来看一张图，脑海里有一个知识体系的印象</p><p><img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/%E9%9B%86%E5%90%88.png"></p><p>集合主要有两类：Collection 和 Map。<br><strong>Collection</strong> 接口的实现子类都是<strong>单列集合</strong>（即操作元素时是一个一个的操作）。<br><strong>Map</strong> 接口的实现子类是<strong>双列集合</strong>（即操作元素时是键值对的方式来操作的，键值对是以内部类Enrty来实现的)</p><p><strong>List</strong>:存储有序的、可重复的数据（“动态”数组）<br><strong>Set</strong>:存储无序的、不可重复的数据（类似高中学习的集合）</p><p><strong>Collections</strong>是一个工具类，提供一些静态方法，如让集合元素排序（类似数组的工具类Arrays）</p><hr><h3 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2. Collection"></a>2. Collection</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><p><strong>集合的特点：</strong></p><ul><li>Set 系列集合：添加的元素是无序，不重复，无索引的<ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul></li><li>List 系列集合：添加的元素是有序，可重复，有索引<ul><li>ArrayList：添加的元素是有序，可重复，有索引</li><li>LinekdList：添加的元素是有序，可重复，有索引</li></ul></li></ul><h4 id="2-2-API"><a href="#2-2-API" class="headerlink" title="2.2 API"></a>2.2 API</h4><p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p><p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p><ul><li><p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p></li><li><p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p></li></ul><p>Collection API 如下：</p><ul><li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>：清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li><li><code>public int size()</code>：返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li><li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> sets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"MyBatis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>        sets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Spring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"MySQL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sets<span class="token punctuation">)</span><span class="token comment">//[]无序的;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sets<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true 存在</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs <span class="token operator">=</span> sets<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数组："</span><span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"ee"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// c1:[java,ee]  c2:[ee];</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-遍历"><a href="#2-3-遍历" class="headerlink" title="2.3 遍历"></a>2.3 遍历</h4><p>Collection 集合的遍历方式有三种:</p><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><ol><li><p>迭代器</p><ul><li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li><li><code>E next()</code>：获取下一个元素值</li><li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li><li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li></ul></li><li><p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>被遍历集合或者数组中元素的类型 变量名称 <span class="token operator">:</span> 被遍历集合或者数组<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p></li><li><p>JDK 1.8 开始之后的新技术 Lambda 表达式</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lists<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lists = [aa, bb, cc]</span><span class="token comment">//迭代器流程</span>        <span class="token comment">// 1.得到集合的迭代器对象。</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> it <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2.使用while循环遍历。</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> ele <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//增强for</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> ele <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//lambda表达式</span>        lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-List"><a href="#2-4-List" class="headerlink" title="2.4 List"></a>2.4 List</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>List 集合继承了 Collection 集合全部的功能。</p><p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p><p>List 系列集合：</p><ul><li><p>ArrayList：添加的元素是有序，可重复，有索引</p></li><li><p>LinekdList：添加的元素是有序，可重复，有索引</p></li></ul><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>ArrayList 添加的元素，是有序，可重复，有索引的</p><ul><li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li><li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素</li><li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li><li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//多态</span>    lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以重复</span>    lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> ele <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h6><p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li><li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li></ul><p>核心方法：</p><ul><li><p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p></li><li><p>添加元素：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// e 插入的元素  elementData底层数组   size 插入的位置</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">// 插入size位置，然后加一</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断elementData是不是空数组</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 返回默认值和最小需求容量最大的一个</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要的容量大于数组长度，进行扩容：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 判断是否需要扩容</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 索引越界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">// 调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>指定索引插入，<strong>在旧数组上操作</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>    <span class="token comment">// 将指定索引后的数据后移</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity&#x2F;2</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查新容量是否大于最小需要容量，若小于最小需要容量，就把最小需要容量当作数组的新容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span><span class="token comment">//不需要扩容计算</span>    <span class="token comment">//检查新容量是否大于最大数组容量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`</span>        <span class="token comment">//否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p><ul><li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li><li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li></ul></li><li><p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> elementData<span class="token punctuation">.</span>length        <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>             <span class="token operator">&amp;&amp;</span> minCapacity <span class="token operator">&lt;=</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>       <span class="token comment">// index of next element to return</span>    <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// index of last element returned; -1 if no such</span>    <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">// 获取下一个元素时首先判断结构是否发生变化</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// .....</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// modCount 被其他线程改变抛出并发修改异常</span>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 【允许删除操作】</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>        <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// ...</span>        <span class="token comment">// 删除后重置 expectedModCount</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p><p>构造：默认长度为 10 的数组</p><p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p><p>对比 ArrayList</p><ol><li><p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p></li><li><p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p></li><li><p>底层都是 <code>Object[]</code> 数组存储</p></li></ol><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><h6 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h6><p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p><p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p><ul><li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li><li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li><li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li><li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li><li><code>public E remove(int index)</code>：删除指定位置的元素</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1.用LinkedList做一个队列:先进先出，后进后出。</span>        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 入队</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"1号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"2号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"3号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1号, 2号, 3号]</span>        <span class="token comment">// 出队</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1号</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2号</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[3号]</span>        <span class="token comment">// 做一个栈 先进后出</span>        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 压栈</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"第1颗子弹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//addFirst(e);</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"第2颗子弹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"第3颗子弹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ 第3颗子弹, 第2颗子弹, 第1颗子弹]</span>        <span class="token comment">// 弹栈</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//removeFirst(); 第3颗子弹</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// [第1颗子弹]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="源码剖析-1"><a href="#源码剖析-1" class="headerlink" title="源码剖析"></a>源码剖析</h6><p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p><p><img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p><p>核心方法：</p><ul><li><p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>私有内部类 Node：这个类代表双端链表的节点 Node</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token class-name">E</span> item<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p></li><li><p>添加元素：默认加到尾部</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p><ul><li>获取头节点 (index&#x3D;0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li><li>获取尾节点 (index&#x3D;-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li></ul></li><li><p>删除元素：</p><ul><li>remove()、removeFirst()、pop()：删除头节点</li><li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li></ul></li></ul><p>对比 ArrayList</p><ol><li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li><li>底层数据结构： <ul><li>Arraylist 底层使用的是 <code>Object</code> 数组</li><li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li></ul></li><li>插入和删除是否受元素位置的影响：<ul><li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li><li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li></ul></li><li>是否支持快速随机访问：<ul><li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li><li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li></ul></li><li>内存空间占用：<ul><li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li><li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li></ul></li></ol><h4 id="2-5-Set"><a href="#2-5-Set" class="headerlink" title="2.5 Set"></a>2.5 Set</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>Set 系列集合：</p><ul><li>HashSet：添加的元素是无序，不重复，无索引的</li><li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li><li>TreeSet：不重复，无索引，按照大小默认升序排序</li></ul><p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>哈希值：</p><ul><li><p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p></li><li><p>获取哈希值：Object 类中的 public int hashCode()</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT &#x3D; new Object()</strong></p><p>Set 集合添加的元素是无序，不重复的。</p><ul><li><p>是如何去重复的？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.</span>对于有值特性的，<span class="token class-name">Set</span>集合可以直接判断进行去重复。<span class="token number">2.</span>对于引用数据类型的类对象，<span class="token class-name">Set</span>集合是按照如下流程进行是否重复的判断。    <span class="token class-name">Set</span>集合会让两两对象，先调用自己的<span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法得到彼此的哈希值（所谓的内存地址）    然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。    如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了    如果不相同认为不重复。            <span class="token class-name">Set</span>集合会先让对象调用<span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法获取两个对象的哈希值比较               <span class="token operator">/</span>                     \            <span class="token boolean">false</span>                    <span class="token boolean">true</span>            <span class="token operator">/</span>                          \        不重复                        继续让两个对象进行equals比较                                       <span class="token operator">/</span>          \                                     <span class="token boolean">false</span>        <span class="token boolean">true</span>                                      <span class="token operator">/</span>             \                                    不重复          重复了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Set 系列集合元素无序的根本原因</p><p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p><ul><li>JDK 1.8 之前：哈希表 &#x3D; 数组（初始容量16) + 链表  + （哈希算法）</li><li>JDK 1.8 之后：哈希表 &#x3D; 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）<ul><li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li><li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li></ul></li></ul></li></ul><p><img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/HashSet%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p><ul><li><p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p></li><li><p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p></li></ul><h5 id="Linked"><a href="#Linked" class="headerlink" title="Linked"></a>Linked</h5><p>LinkedHashSet 为什么是有序的？</p><p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet 集合自排序的方式：</p><ol><li>有值特性的元素直接可以升序排序（浮点型，整型）</li><li>字符串类型的元素会按照首字符的编号排序</li><li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li></ol><p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p><ul><li><p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p><p>方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li><li><p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p><p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p><ul><li>比较者大于被比较者，返回正数</li><li>比较者小于被比较者，返回负数</li><li>比较者等于被比较者，返回 0</li></ul></li></ul><p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeSetDemo</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>students<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按照年龄比较 升序</span>                <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o1<span class="token punctuation">,</span> <span class="token class-name">Student</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// o1比较者   o2被比较者</span>                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//降序</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment">// 重写了比较方法。</span>    <span class="token comment">// e1.compareTo(o)</span>    <span class="token comment">// 比较者：this</span>    <span class="token comment">// 被比较者：o</span>    <span class="token comment">// 需求：按照年龄比较 升序，年龄相同按照姓名</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">-</span> o<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        <span class="token keyword">return</span> result <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>getName<span class="token punctuation">)</span><span class="token operator">:</span>result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p><h4 id="2-6-Queue"><a href="#2-6-Queue" class="headerlink" title="2.6 Queue"></a>2.6 Queue</h4><p>Queue：队列，先进先出的特性</p><p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p><p>构造方法：</p><ul><li><p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p></li><li><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span> <span class="token operator">-></span> v2 <span class="token operator">-</span> v1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实现大顶堆</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>常用 API：</p><ul><li><code>public boolean offer(E e)</code>：将指定的元素插入到此优先级队列的<strong>尾部</strong></li><li><code>public E poll() </code>：检索并删除此队列的<strong>头元素</strong>，如果此队列为空，则返回 null </li><li><code>public E peek()</code>：检索但不删除此队列的头，如果此队列为空，则返回 null</li><li><code>public boolean remove(Object o)</code>：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</li></ul><h4 id="2-7-Collections"><a href="#2-7-Collections" class="headerlink" title="2.7 Collections"></a>2.7 Collections</h4><p>java.utils.Collections：集合<strong>工具类</strong>，Collections 并不属于集合，是用来操作集合的工具类</p><p>Collections 有几个常用的API：</p><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... e)</code>：给集合对象批量添加元素</li><li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合顺序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; )</code>：集合中元素按照指定规则排序</li><li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回由指定 list 支持的线程安全 list</li><li><code>public static &lt;T&gt; Set&lt;T&gt; singleton(T o)</code>：返回一个只包含指定对象的不可变组</li></ul><hr><h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p><p>Map集合的每个元素的格式：key&#x3D;value（键值对元素），Map集合也被称为键值对集合</p><p>Map集合的完整格式：<code>&#123;key1=value1, key2=value2, key3=value3, ...&#125;</code></p><p>Map 集合的特点：</p><ol><li>Map 集合的特点都是由键决定的</li><li>Map 集合的键是无序，不重复的，无索引的（Set）</li><li>Map 集合的值无要求（List）</li><li>Map 集合的键值对都可以为 null</li><li>Map 集合后面重复的键对应元素会覆盖前面的元素</li></ol><p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p><p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p><h4 id="3-2-常用API"><a href="#3-2-常用API" class="headerlink" title="3.2 常用API"></a>3.2 常用API</h4><p>Map 集合的常用 API</p><ul><li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li><li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li><li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li><li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li><li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li><li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span> <span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> maps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        maps<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>maps<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>        <span class="token class-name">Integer</span> value <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回键值对象</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取Map集合中所有的键，</span>        <span class="token comment">//Map集合的键是无序不重复的，所以返回的是一个Set集合</span>        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> values <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//Map集合的值是不做要求的，可能重复，所以值要用Collection集合接收!</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-遍历方式"><a href="#3-3-遍历方式" class="headerlink" title="3.3 遍历方式"></a>3.3 遍历方式</h4><p>Map集合的遍历方式有：3种。</p><ol><li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li><li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li><li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li></ol><p>集合可以直接输出内容，因为底层重写了 toString() 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span> <span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> maps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(1)键找值</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keys <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> maps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//Iterator&lt;String> iterator = hm.keySet().iterator();</span>        <span class="token comment">//(2)键值对</span>    <span class="token comment">//(2.1)普通方式</span>    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entries <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span> entries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"=>"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//(2.2)迭代器方式</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> iterator <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//(3) Lamda</span>    maps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token string">"==>"</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-HashMap"><a href="#3-4-HashMap" class="headerlink" title="3.4 HashMap"></a>3.4 HashMap</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p><p>特点：</p><ul><li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li><li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li><li>key、value 都可以为null，但是 key 位置只能是一个null</li><li>HashMap 中的映射不是有序的，即存取是无序的</li><li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li></ul><p>JDK7 对比 JDK8：</p><ul><li>7 &#x3D; 数组 + 链表，8 &#x3D; 数组 + 链表 + 红黑树</li><li>7 中是头插法，多线程容易造成环，8 中是尾插法</li><li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li><li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li></ul><p>底层数据结构：</p><ul><li><p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>JDK1.8 之前 HashMap 由数组+链表组成</p><ul><li>数组是 HashMap 的主体</li><li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li></ul></li><li><p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p><ul><li>解决哈希冲突时有了较大的变化</li><li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li><li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的**时间复杂度是 O(n)<strong>，所以 JDK1.8 中引入了 红黑树（查找</strong>时间复杂度为 O(logn)**）来优化这个问题，使得查找效率更高</li></ul><p><img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p></li></ul><h5 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h5><p>HashMap 继承关系如下图所示：</p><p><img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/HashMap%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.bmp"></p><p>说明：</p><ul><li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li><li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li><li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li></ul><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><ol><li><p>序列化版本号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>HashMap 构造方法指定集合的初始化容量大小：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token comment">// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p><p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p><p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">例如长度为<span class="token number">8</span>时候，<span class="token number">3</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">3</span>  <span class="token number">2</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">2</span> ，不同位置上，不碰撞；例如长度为<span class="token number">9</span>时候，<span class="token number">3</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token number">2</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span> ，都在<span class="token number">0</span>上，碰撞了；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果输入值不是 2 的幂会怎么样？</p><p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p></li></ul></li><li><p>默认的负载因子，默认值是 0.75 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>集合最大容量 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 集合最大容量的上限是：2的30次幂</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment">// 0100 0000 0000 0000 0000 0000 0000 0000 = 2 ^ 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为什么 Map 桶中节点个数大于 8 才转为红黑树？</p><ul><li><p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeNodes</span>占用空间大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点。当节点变少<span class="token punctuation">(</span>由于删除或调整大小<span class="token punctuation">)</span>时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从<span class="token string">"泊松分布"</span>，默认调整阈值为<span class="token number">0.75</span>，平均参数约为<span class="token number">0.5</span>，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是<span class="token punctuation">(</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">factorial</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span><span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span><span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span><span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span><span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span><span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span><span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span><span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span><span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span>more<span class="token operator">:</span> less than <span class="token number">1</span> in ten million一个bin中链表长度达到<span class="token number">8</span>个元素的概率为<span class="token number">0.00000006</span>，几乎是不可能事件，所以我们选择<span class="token number">8</span>这个数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其他说法<br>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)&#x3D;3，链表的平均查找长度为 n&#x2F;2，当长度为 8 时，平均查找长度为 8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于 6，6&#x2F;2&#x3D;3，而 log(6)&#x3D;2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p></li></ul></li><li><p>当链表的值小于 6 则会从红黑树转回链表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 桶中结构转化为红黑树对应的数组长度最小的值 </span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p></li><li><p>table 用来初始化（必须是二的 n 次幂）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 存储元素的数组 </span><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>HashMap 中<strong>存放元素的个数</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 存放元素的个数，HashMap中K-V的实时数量，不是table数组的长度</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>记录 HashMap 的修改次数 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 每次扩容和更改map结构的计数器</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 临界值，当实际大小(容量*负载因子)超过临界值时，会进行扩容</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>哈希表的加载因子</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>加载因子的概述</p><p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size&#x2F;capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p><p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token comment">//构造指定初始容量和加载因子的空HashMap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为什么加载因子设置为 0.75，初始化临界值是 12？</p><p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p></li><li><p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;&#x3D; threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p></li></ul></li></ol><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li><p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token comment">// 将默认的加载因子0.75赋值给loadFactor，并没有创建数组</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 指定“容量大小”的构造函数</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>构造一个具有指定的初始容量和负载因子的 HashMap</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 进行判断</span>    <span class="token comment">// 将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>  <span class="token comment">// 最后调用了tableSizeFor</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code> </p><p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p></li></ul></li><li><p>包含另一个 <code>Map</code> 的构造函数 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 构造一个映射关系与指定 Map 相同的新 HashMap</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 负载因子loadFactor变为默认的负载因子0.75</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>    <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>putMapEntries 源码分析：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获取参数集合的长度</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//判断参数集合的长度是否大于0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 判断table是否已经初始化</span>            <span class="token comment">// pre-size</span>            <span class="token comment">// 未初始化，s为m的实际元素个数</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span>                     <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 计算得到的t大于阈值，则初始化阈值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将m中的所有元素添加至HashMap中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">K</span> key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">V</span> value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p><p>s &#x2F; loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p></li></ul><h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul><li><p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p><ul><li><p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p></li><li><p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p><p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token comment">// 1）如果key等于null：可以看到当key等于null的时候也是有哈希值的，返回的是0</span>    <span class="token comment">// 2）如果key不等于null：首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p><p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p><p>哈希冲突的处理方式：</p><ul><li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li><li>链地址法：拉链法</li></ul></li><li><p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p><p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p><p>存储数据步骤（存储过程）：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li><li>如果桶上没有碰撞冲突，则直接插入</li><li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li><li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li><li>最后判断 size 是否大于阈值 threshold，则进行扩容</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//。。。。。。。。。。。。。。</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//这里的n表示数组长度16</span>  <span class="token comment">//.....</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// existing mapping for key</span>              <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>              <span class="token comment">//onlyIfAbsent默认为false，所以可以覆盖已经存在的数据，如果为true说明不能覆盖</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                  e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>              <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 如果这里允许覆盖，就直接返回了</span>              <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果是添加操作，modCount ++，如果不是替换，不会走这里的逻辑，modCount用来记录逻辑的变化</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">// 数量大于扩容阈值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>(n - 1) &amp; hash</code>：计算下标位置</li></ul>  <img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/HashMap-putVal%E5%93%88%E5%B8%8C%E8%BF%90%E7%AE%97.png" style="zoom: 67%;"><ul><li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li></ul></li><li><p>treeifyBin()</p><p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>   <span class="token comment">//转换为红黑树 tab表示数组名  hash表示哈希值</span>   <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY &#x3D; 64 就去扩容，而不是将节点变为红黑树</li><li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li><li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li></ol></li><li><p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//int cap = 10</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析算法：</p><ol><li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li><li>n&#x3D;0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li><li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li><li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li></ol><p>例如初始化的值为 10：</p><ul><li><p>第一次右移</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//cap=10  n=9</span>n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001001</span> <span class="token comment">//9</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000100</span> <span class="token comment">//9右移之后变为4</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001101</span> <span class="token comment">//按位或之后是13</span><span class="token comment">//使得n的二进制表示中与最高位的1紧邻的右边一位为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第二次右移</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//n通过第一次右移变为了：n=13</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001101</span>  <span class="token comment">// 13</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000011</span>  <span class="token comment">// 13右移之后变为3</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00000000</span> <span class="token number">00001111</span> <span class="token comment">//按位或之后是15</span><span class="token comment">//无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p></li><li><p>得到的 capacity 被赋值给了 threshold</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//initialCapacity=10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>JDK 11</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//无符号右移，高位补0</span><span class="token comment">//-1补码: 11111111 11111111 11111111 11111111</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>>></span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//返回最高位之前的0的位数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">32</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 如果i>0，那么就表明在二进制表示中其至少有一位为1</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>    <span class="token comment">// i的最高位1在高16位，把i右移16位，让最高位1进入低16位继续递进判断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span> <span class="token number">16</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span>  <span class="token number">8</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span>  <span class="token number">8</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span>  <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span>  <span class="token number">4</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span>  <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> n <span class="token operator">-=</span>  <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>>>=</span>  <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>resize()：</p><p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p><p>扩容机制为扩容为原来容量的 2 倍：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 以前的容量已经是最大容量了，这时调大 扩容阈值 threshold</span>        threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span>             oldCap <span class="token operator">>=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>        newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 初始化的threshold赋值给newCap</span>    newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span>    newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到”原位置+旧容量”的位置</strong></p><p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p><p>注意：这里要求<strong>数组长度 2 的幂</strong></p><p><img src="/2023/09/16/chang-yong-ji-he-ji-qi-di-ceng-yuan-li-pou-xi/HashMap-resize%E6%89%A9%E5%AE%B9.png"></p><p>普通节点：把所有节点分成高低位两个链表，转移到数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 遍历所有的节点</span><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>    next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// oldCap 旧数组大小，2 的 n 次幂</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            loHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//指向低位链表头节点</span>        <span class="token keyword">else</span>            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>        loTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//指向低位链表尾节点</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">else</span>            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>        hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 低位链表的最后一个节点可能在原哈希表中指向其他节点，需要断开</span>    newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//如果低位链表首节点不为null，说明有这个链表存在</span><span class="token keyword">if</span> <span class="token punctuation">(</span>loHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//如果链表下的元素小于等于6</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span>        <span class="token comment">//那就从红黑树转链表了，低位链表，迁移到新数组中下标不变，还是等于原数组到下标</span>        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">.</span><span class="token function">untreeify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//低位链表，迁移到新数组中下标不变，把低位链表整个赋值到这个下标下</span>        tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>        <span class="token comment">//如果高位首节点不为空，说明原来的红黑树已经被拆分成两个链表了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">//需要构建新的红黑树了</span>            loHead<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​</p><ul><li><p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>    <span class="token comment">// 节点数组tab不为空、数组长度n大于0、根据hash定位到的节点对象p，</span>    <span class="token comment">// 该节点为树的根节点或链表的首节点）不为空，从该节点p向下遍历，找到那个和key匹配的节点对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span><span class="token comment">//临时变量，储存要返回的节点信息</span>        <span class="token comment">//key和value都相等，直接返回该节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//如果是树节点，调用getTreeNode方法从树结构中查找满足条件的节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//遍历链表</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//e节点的键是否和key相等，e节点就是要删除的节点，赋值给node变量</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token comment">//跳出循环</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//把当前节点p指向e 继续遍历</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//如果node不为空，说明根据key匹配到了要删除的节点</span>        <span class="token comment">//如果不需要对比value值或者对比value值但是value值也相等，可以直接删除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token comment">//node是首节点</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token comment">//node不是首节点</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token comment">//LinkedHashMap</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>get()</p><ol><li><p>通过 hash 值获取该 key 映射到的桶</p></li><li><p>桶上的 key 就是要查找的 key，则直接找到并返回</p></li><li><p>桶上的 key 不是要找的 key，则查看后续的节点：</p><ul><li><p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p></li><li><p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value</p></li></ul></li><li><p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p><ul><li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li><li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li></ul></li><li><p>时间复杂度 O(1)</p><ul><li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong> </li><li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li></ul></li></ol></li></ul><h5 id="并发异常"><a href="#并发异常" class="headerlink" title="并发异常"></a>并发异常</h5><p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashMap</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">KeySet</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 底层获取的是 KeyIterator</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">KeyIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">KeyIterator</span> <span class="token keyword">extends</span> <span class="token class-name">HashIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 回调 HashMap.HashIterator#nextNode</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">HashIterator</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>        <span class="token comment">// next entry to return</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> current<span class="token punctuation">;</span>     <span class="token comment">// current entry</span>    <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>  <span class="token comment">// for 【fast-fail】，快速失败</span>    <span class="token keyword">int</span> index<span class="token punctuation">;</span>             <span class="token comment">// current slot</span>    <span class="token class-name">HashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把当前 map 的数量赋值给 expectedModCount，迭代时判断</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> table<span class="token punctuation">;</span>        current <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// advance to first entry</span>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// iterator.next() 会调用这个函数</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> t<span class="token punctuation">;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token comment">// 这里会判断 集合的结构是否发生了变化，变化后 modCount 会改变，直接抛出并发异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">=</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 迭代器允许删除集合的元素，【删除后会重置 expectedModCount = modCount】</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">K</span> key <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 同步expectedModCount</span>        expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-LinkedMap"><a href="#3-5-LinkedMap" class="headerlink" title="3.5 LinkedMap"></a>3.5 LinkedMap</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>LinkedHashMap 是 HashMap 的子类</p><ul><li><p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p></li><li><p>缺点：会占用一些内存空间</p></li></ul><p>对比 Set：</p><ul><li>HashSet 集合相当于是 HashMap 集合的键，不带值</li><li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li><li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li></ul><p>源码解析：</p><ul><li><p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> head<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> tail<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>维护顺序的函数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>put()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 调用父类HashMap的put方法</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span>→ <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// evict为true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">;</span>    <span class="token comment">// evict 只有在构建 Map 的时候才为 false，这里为 true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//移除头节点</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>get()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> last<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 向下转型</span>        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span>            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 判断 p 是否是首节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">//是头节点 让p后继节点成为头节点</span>            head <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">//不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span>            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">// 判断p是否是尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// 不是尾节点 让p后继节点指向p的前驱节点</span>            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token comment">// 是尾节点 让last指向p的前驱节点</span>            last <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token comment">// 判断last是否是空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token comment">// last为空说明p是尾节点或者只有p一个节点</span>            head <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// last和p相互连接</span>            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>remove()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//调用HashMap的remove方法</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span><span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span>→ <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span>        <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>    <span class="token comment">// 让p节点与前驱节点和后继节点断开链接</span>    p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// 判断p是否是头节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// p是头节点 让head指向p的后继节点</span>        head <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">// p不是头节点 让p的前驱节点的next指向p的后继节点，维护链表的连接</span>        b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">// 判断p是否是尾节点，是就让tail指向p的前驱节点，不是就让p.after指向前驱节点，双向</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tail <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">else</span>        a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把1放入尾部</span>    cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[3, 1, 4]只能存3个，移除2</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ENTRIES</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token constant">MAX_ENTRIES</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">MAX_ENTRIES</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-6-TreeMap"><a href="#3-6-TreeMap" class="headerlink" title="3.6 TreeMap"></a>3.6 TreeMap</h4><p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p><p>TreeMap 集合指定大小规则有 2 种方式：</p><ul><li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li><li>直接为集合设置比较器 Comparator 对象，重写比较方法</li></ul><p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p><p>成员属性：</p><ul><li><p>Entry 节点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>     <span class="token class-name">K</span> key<span class="token punctuation">;</span>     <span class="token class-name">V</span> value<span class="token punctuation">;</span>     <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> left<span class="token punctuation">;</span><span class="token comment">//左孩子节点</span>     <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> right<span class="token punctuation">;</span><span class="token comment">//右孩子节点</span>     <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> parent<span class="token punctuation">;</span><span class="token comment">//父节点</span>     <span class="token keyword">boolean</span> color <span class="token operator">=</span> <span class="token constant">BLACK</span><span class="token punctuation">;</span><span class="token comment">//节点的颜色，在红黑树中只有两种颜色，红色和黑色</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>compare()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//如果comparator为null，采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k1<span class="token punctuation">,</span> <span class="token class-name">Object</span> k2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> comparator <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>k1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">K</span><span class="token punctuation">)</span>k2<span class="token punctuation">)</span>        <span class="token operator">:</span> comparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">K</span><span class="token punctuation">)</span>k1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">K</span><span class="token punctuation">)</span>k2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h3><h4 id="4-1HashMap关于存储null值"><a href="#4-1HashMap关于存储null值" class="headerlink" title="4.1HashMap关于存储null值"></a>4.1HashMap关于存储null值</h4><p>Hashtable中，key和value都不允许出现null值。在HashMap中，key出现null最多只能有一个，value出现null值可以有多个，所以我们用get()方法返回null值时既可以表示hashMap中没有这个键，也可以表示这个键对应的值就是null，因此在hashMap中要判断是否存在某个键要使用containsKey()方法而不是get()方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式-学习小结</title>
      <link href="/2023/08/28/lambda-biao-da-shi-xue-xi-xiao-jie/"/>
      <url>/2023/08/28/lambda-biao-da-shi-xue-xi-xiao-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要：看到大佬的代码有 “-&gt;” 以及 “::” 这种符号，后面查询后得知这是λ表达式，本质上就是一种语法糖</p></blockquote><h3 id="1-lambda"><a href="#1-lambda" class="headerlink" title="1. lambda"></a>1. lambda</h3><h4 id="1-1基本介绍"><a href="#1-1基本介绍" class="headerlink" title="1.1基本介绍"></a>1.1基本介绍</h4><p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p><p>作用：为了简化匿名内部类的代码写法</p><p>Lambda 表达式的格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span>匿名内部类被重写方法的形参列表<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span><span class="token comment">//被重写方法的方法体代码</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p><p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p><p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p><hr><h4 id="1-2简化方法"><a href="#1-2简化方法" class="headerlink" title="1.2简化方法"></a>1.2简化方法</h4><p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p><ul><li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li><li>参数类型可以省略不写</li><li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="1-3常用简化"><a href="#1-3常用简化" class="headerlink" title="1.3常用简化"></a>1.3常用简化</h4><p>Comparator</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionsDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//...s1 s2 s3</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>lists <span class="token punctuation">,</span> s1 <span class="token punctuation">,</span> s2 <span class="token punctuation">,</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> s1<span class="token punctuation">,</span> <span class="token class-name">Student</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> s2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 简化写法</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lists <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">Student</span> t1<span class="token punctuation">,</span> <span class="token class-name">Student</span> t2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> t1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> t2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 参数类型可以省略,最简单的</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lists <span class="token punctuation">,</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">)</span> <span class="token operator">-></span> t1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>t2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2. 方法引用"></a>2. 方法引用</h3><h4 id="2-1基本介绍"><a href="#2-1基本介绍" class="headerlink" title="2.1基本介绍"></a>2.1基本介绍</h4><p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p><p>方法引用的格式：类型或者对象::引用的方法</p><p>关键语法是：<code>::</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> s <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 方法引用！</span>lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-2静态方法"><a href="#2-2静态方法" class="headerlink" title="2.2静态方法"></a>2.2静态方法</h4><p>引用格式：<code>类名::静态方法</code></p><p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p><p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义集合加入几个Student元素</span><span class="token comment">// 使用静态方法进行简化！</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token function">compareByAge</span><span class="token punctuation">(</span>o1 <span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果前后参数是一样的，而且方法是静态方法，既可以使用静态方法引用</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">compareByAge</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name <span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareByAge</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o1 <span class="token punctuation">,</span> <span class="token class-name">Student</span> o2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>  o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-3实例方法"><a href="#2-3实例方法" class="headerlink" title="2.3实例方法"></a>2.3实例方法</h4><p>引用格式：<code>对象::实例方法</code></p><p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p><p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 对象是 System.out = new PrintStream();</span>        <span class="token comment">// 实例方法：println()</span>        <span class="token comment">// 前后参数正好都是一个</span>        lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-4特定类型"><a href="#2-4特定类型" class="headerlink" title="2.4特定类型"></a>2.4特定类型</h4><p>特定类型：String，任何类型</p><p>引用格式：<code>特定类型::方法</code></p><p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodDemo</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"James"</span><span class="token punctuation">,</span> <span class="token string">"AA"</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">,</span>                <span class="token string">"Patricia"</span><span class="token punctuation">,</span><span class="token string">"Dlei"</span> <span class="token punctuation">,</span> <span class="token string">"Robert"</span><span class="token punctuation">,</span><span class="token string">"Boom"</span><span class="token punctuation">,</span> <span class="token string">"Cao"</span> <span class="token punctuation">,</span><span class="token string">"black"</span> <span class="token punctuation">,</span>                <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token string">"Linda"</span><span class="token punctuation">,</span><span class="token string">"cao"</span><span class="token punctuation">,</span><span class="token string">"after"</span><span class="token punctuation">,</span><span class="token string">"sa"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">// public static &lt;T> void sort(T[] a, Comparator&lt;? super T> c)</span>        <span class="token comment">// 需求：按照元素的首字符(忽略大小写)升序排序！！！</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//按照元素的首字符(忽略大小写)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token punctuation">(</span> s1<span class="token punctuation">,</span>  s2 <span class="token punctuation">)</span> <span class="token operator">-></span>  s1<span class="token punctuation">.</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 特定类型的方法引用：</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span>  <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-5构造器"><a href="#2-5构造器" class="headerlink" title="2.5构造器"></a>2.5构造器</h4><p>格式：<code>类名::new</code></p><p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstructorDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lists <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lists<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 集合默认只能转成Object类型的数组。</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objs <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 我们想指定转换成字符串类型的数组！最新的写法可以结合构造器引用实现 </span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IntFunction</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs1 <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>s <span class="token operator">-></span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs2 <span class="token operator">=</span> lists<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String类型的数组："</span><span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>strs2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
